{
  "manifest_version": "2",
  "task_list": [
    {
      "name": "Convert Cellvoyager to OME-Zarr",
      "category": "Conversion",
      "modality": "HCS",
      "tags": [
        "Yokogawa",
        "Cellvoyager",
        "2D",
        "3D"
      ],
      "docs_info": "### Purpose\n- Converts **2D and 3D images from CellVoyager CV7000/8000** systems into OME-Zarr format, creating OME-Zarr HCS plates and combining all fields of view in a well into a single image.\n- Saves Fractal **region-of-interest (ROI) tables** for both individual fields of view and the entire well.\n- Handles overlapping fields of view by adjusting their positions to be non-overlapping while retaining the original position data as additional columns in the ROI tables.\n- Supports processing multiple plates in a single task.\n\n### Limitations\n- Currently, this task does not support time-resolved data and ignores the time fields in CellVoyager metadata.\n",
      "type": "converter_compound",
      "executable_non_parallel": "tasks/cellvoyager_to_ome_zarr_init.py",
      "executable_parallel": "tasks/cellvoyager_to_ome_zarr_compute.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "meta_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "args_schema_non_parallel": {
        "$defs": {
          "OmeroChannel": {
            "description": "Custom class for Omero channels, based on OME-NGFF v0.4.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "string",
                "description": "Unique ID for the channel wavelength, e.g. `A01_C01`."
              },
              "index": {
                "title": "Index",
                "type": "integer",
                "description": "Do not change. For internal use only."
              },
              "label": {
                "title": "Label",
                "type": "string",
                "description": "Name of the channel."
              },
              "window": {
                "allOf": [
                  {
                    "$ref": "#/$defs/Window"
                  }
                ],
                "title": "Window",
                "description": "Optional `Window` object to set default display settings. If unset, it will be set to the full bit range of the image (e.g. 0-65535 for 16 bit images)."
              },
              "color": {
                "title": "Color",
                "type": "string",
                "description": "Optional hex colormap to display the channel in napari (it must be of length 6, e.g. `00FFFF`)."
              },
              "active": {
                "default": true,
                "title": "Active",
                "type": "boolean",
                "description": "Should this channel be shown in the viewer?"
              },
              "coefficient": {
                "default": 1,
                "title": "Coefficient",
                "type": "integer",
                "description": "Do not change. Omero-channel attribute."
              },
              "inverted": {
                "default": false,
                "title": "Inverted",
                "type": "boolean",
                "description": "Do not change. Omero-channel attribute."
              }
            },
            "required": [
              "wavelength_id"
            ],
            "title": "OmeroChannel",
            "type": "object"
          },
          "Window": {
            "description": "Custom class for Omero-channel window, based on OME-NGFF v0.4.",
            "properties": {
              "min": {
                "title": "Min",
                "type": "integer",
                "description": "Do not change. It will be set to `0` by default."
              },
              "max": {
                "title": "Max",
                "type": "integer",
                "description": "Do not change. It will be set according to bit-depth of the images by default (e.g. 65535 for 16 bit images)."
              },
              "start": {
                "title": "Start",
                "type": "integer",
                "description": "Lower-bound rescaling value for visualization."
              },
              "end": {
                "title": "End",
                "type": "integer",
                "description": "Upper-bound rescaling value for visualization."
              }
            },
            "required": [
              "start",
              "end"
            ],
            "title": "Window",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "image_dirs": {
            "items": {
              "type": "string"
            },
            "title": "Image Dirs",
            "type": "array",
            "description": "list of paths to the folders that contains the Cellvoyager image files. Each entry is a path to a folder that contains the image files themselves for a multiwell plate and the MeasurementData & MeasurementDetail metadata files."
          },
          "allowed_channels": {
            "items": {
              "$ref": "#/$defs/OmeroChannel"
            },
            "title": "Allowed Channels",
            "type": "array",
            "description": "A list of `OmeroChannel` s, where each channel must include the `wavelength_id` attribute and where the `wavelength_id` values must be unique across the list."
          },
          "include_glob_patterns": {
            "items": {
              "type": "string"
            },
            "title": "Include Glob Patterns",
            "type": "array",
            "description": "If specified, only parse images with filenames that match with all these patterns. Patterns must be defined as in https://docs.python.org/3/library/fnmatch.html, Example: `image_glob_pattern=[\"*_B03_*\"]` => only process well B03 `image_glob_pattern=[\"*_C09_*\", \"*F016*\", \"*Z[0-5][0-9]C*\"]` => only process well C09, field of view 16 and Z planes 0-59. Can interact with exclude_glob_patterns: All included images - all excluded images gives the final list of images to process"
          },
          "exclude_glob_patterns": {
            "items": {
              "type": "string"
            },
            "title": "Exclude Glob Patterns",
            "type": "array",
            "description": "If specified, exclude any image where the filename matches any of the exclusion patterns. Patterns are specified the same as for include_glob_patterns."
          },
          "num_levels": {
            "default": 5,
            "title": "Num Levels",
            "type": "integer",
            "description": "Number of resolution-pyramid levels. If set to `5`, there will be the full-resolution level and 4 levels of downsampled images."
          },
          "coarsening_xy": {
            "default": 2,
            "title": "Coarsening Xy",
            "type": "integer",
            "description": "Linear coarsening factor between subsequent levels. If set to `2`, level 1 is 2x downsampled, level 2 is 4x downsampled etc."
          },
          "image_extension": {
            "default": "tif",
            "title": "Image Extension",
            "type": "string",
            "description": "Filename extension of images (e.g. `\"tif\"` or `\"png\"`)"
          },
          "metadata_table_file": {
            "title": "Metadata Table File",
            "type": "string",
            "description": "If `None`, parse Yokogawa metadata from mrf/mlf files in the input_path folder; else, the full path to a csv file containing the parsed metadata table."
          },
          "overwrite": {
            "default": false,
            "title": "Overwrite",
            "type": "boolean",
            "description": "If `True`, overwrite the task output."
          }
        },
        "required": [
          "zarr_dir",
          "image_dirs",
          "allowed_channels"
        ],
        "type": "object",
        "title": "CellvoyagerToOmeZarrInit"
      },
      "args_schema_parallel": {
        "$defs": {
          "ChunkSizes": {
            "description": "Chunk size settings for OME-Zarrs.",
            "properties": {
              "t": {
                "title": "T",
                "type": "integer"
              },
              "c": {
                "default": 1,
                "title": "C",
                "type": "integer"
              },
              "z": {
                "default": 10,
                "title": "Z",
                "type": "integer"
              },
              "y": {
                "title": "Y",
                "type": "integer"
              },
              "x": {
                "title": "X",
                "type": "integer"
              }
            },
            "title": "ChunkSizes",
            "type": "object"
          },
          "InitArgsCellVoyager": {
            "description": "Arguments to be passed from cellvoyager converter init to compute",
            "properties": {
              "image_dir": {
                "title": "Image Dir",
                "type": "string"
              },
              "plate_prefix": {
                "title": "Plate Prefix",
                "type": "string"
              },
              "well_ID": {
                "title": "Well Id",
                "type": "string"
              },
              "image_extension": {
                "title": "Image Extension",
                "type": "string"
              },
              "include_glob_patterns": {
                "items": {
                  "type": "string"
                },
                "title": "Include Glob Patterns",
                "type": "array"
              },
              "exclude_glob_patterns": {
                "items": {
                  "type": "string"
                },
                "title": "Exclude Glob Patterns",
                "type": "array"
              },
              "acquisition": {
                "title": "Acquisition",
                "type": "integer"
              }
            },
            "required": [
              "image_dir",
              "plate_prefix",
              "well_ID",
              "image_extension"
            ],
            "title": "InitArgsCellVoyager",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsCellVoyager",
            "title": "Init Args",
            "description": "Intialization arguments provided by `create_cellvoyager_ome_zarr_init`."
          },
          "chunk_sizes": {
            "$ref": "#/$defs/ChunkSizes",
            "title": "Chunk Sizes",
            "description": "Used to overwrite the default chunk sizes for the OME-Zarr. By default, the task will chunk the same as the microscope field of view size, with 10 z planes per chunk. For example, that can mean c: 1, z: 10, y: 2160, x:2560"
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "type": "object",
        "title": "CellvoyagerToOmeZarrCompute"
      },
      "docs_link": "https://fractal-analytics-platform.github.io/fractal-tasks-core"
    },
    {
      "name": "Convert Cellvoyager Multiplexing to OME-Zarr",
      "category": "Conversion",
      "modality": "HCS",
      "tags": [
        "Yokogawa",
        "Cellvoyager",
        "2D",
        "3D"
      ],
      "docs_info": "### Purpose\n- Converts **multiplexed 2D and 3D images from CellVoyager CV7000/8000** systems into OME-Zarr format, storing each acquisition as a separate OME-Zarr image in the same OME-Zarr plate.\n- Creates **OME-Zarr HCS plates**, combining all fields of view for each acquisition in a well into a single image.\n- Saves Fractal **region-of-interest (ROI) tables** for both individual fields of view and the entire well.\n- Handles overlapping fields of view by adjusting their positions to be non-overlapping, while preserving the original position data as additional columns in the ROI tables.\n\n### Limitations\n- This task currently does not support time-resolved data and ignores the time fields in CellVoyager metadata.\n",
      "type": "converter_compound",
      "executable_non_parallel": "tasks/cellvoyager_to_ome_zarr_init_multiplex.py",
      "executable_parallel": "tasks/cellvoyager_to_ome_zarr_compute.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "meta_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "args_schema_non_parallel": {
        "$defs": {
          "MultiplexingAcquisition": {
            "description": "Input class for Multiplexing Cellvoyager converter",
            "properties": {
              "image_dir": {
                "title": "Image Dir",
                "type": "string",
                "description": "Path to the folder that contains the Cellvoyager image files for that acquisition and the MeasurementData & MeasurementDetail metadata files."
              },
              "allowed_channels": {
                "items": {
                  "$ref": "#/$defs/OmeroChannel"
                },
                "title": "Allowed Channels",
                "type": "array",
                "description": "A list of `OmeroChannel` objects, where each channel must include the `wavelength_id` attribute and where the `wavelength_id` values must be unique across the list."
              }
            },
            "required": [
              "image_dir",
              "allowed_channels"
            ],
            "title": "MultiplexingAcquisition",
            "type": "object"
          },
          "OmeroChannel": {
            "description": "Custom class for Omero channels, based on OME-NGFF v0.4.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "string",
                "description": "Unique ID for the channel wavelength, e.g. `A01_C01`."
              },
              "index": {
                "title": "Index",
                "type": "integer",
                "description": "Do not change. For internal use only."
              },
              "label": {
                "title": "Label",
                "type": "string",
                "description": "Name of the channel."
              },
              "window": {
                "allOf": [
                  {
                    "$ref": "#/$defs/Window"
                  }
                ],
                "title": "Window",
                "description": "Optional `Window` object to set default display settings. If unset, it will be set to the full bit range of the image (e.g. 0-65535 for 16 bit images)."
              },
              "color": {
                "title": "Color",
                "type": "string",
                "description": "Optional hex colormap to display the channel in napari (it must be of length 6, e.g. `00FFFF`)."
              },
              "active": {
                "default": true,
                "title": "Active",
                "type": "boolean",
                "description": "Should this channel be shown in the viewer?"
              },
              "coefficient": {
                "default": 1,
                "title": "Coefficient",
                "type": "integer",
                "description": "Do not change. Omero-channel attribute."
              },
              "inverted": {
                "default": false,
                "title": "Inverted",
                "type": "boolean",
                "description": "Do not change. Omero-channel attribute."
              }
            },
            "required": [
              "wavelength_id"
            ],
            "title": "OmeroChannel",
            "type": "object"
          },
          "Window": {
            "description": "Custom class for Omero-channel window, based on OME-NGFF v0.4.",
            "properties": {
              "min": {
                "title": "Min",
                "type": "integer",
                "description": "Do not change. It will be set to `0` by default."
              },
              "max": {
                "title": "Max",
                "type": "integer",
                "description": "Do not change. It will be set according to bit-depth of the images by default (e.g. 65535 for 16 bit images)."
              },
              "start": {
                "title": "Start",
                "type": "integer",
                "description": "Lower-bound rescaling value for visualization."
              },
              "end": {
                "title": "End",
                "type": "integer",
                "description": "Upper-bound rescaling value for visualization."
              }
            },
            "required": [
              "start",
              "end"
            ],
            "title": "Window",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "acquisitions": {
            "additionalProperties": {
              "$ref": "#/$defs/MultiplexingAcquisition"
            },
            "title": "Acquisitions",
            "type": "object",
            "description": "dictionary of acquisitions. Each key is the acquisition identifier (normally 0, 1, 2, 3 etc.). Each item defines the acquisition by providing the image_dir and the allowed_channels."
          },
          "include_glob_patterns": {
            "items": {
              "type": "string"
            },
            "title": "Include Glob Patterns",
            "type": "array",
            "description": "If specified, only parse images with filenames that match with all these patterns. Patterns must be defined as in https://docs.python.org/3/library/fnmatch.html, Example: `image_glob_pattern=[\"*_B03_*\"]` => only process well B03 `image_glob_pattern=[\"*_C09_*\", \"*F016*\", \"*Z[0-5][0-9]C*\"]` => only process well C09, field of view 16 and Z planes 0-59. Can interact with exclude_glob_patterns: All included images - all excluded images gives the final list of images to process"
          },
          "exclude_glob_patterns": {
            "items": {
              "type": "string"
            },
            "title": "Exclude Glob Patterns",
            "type": "array",
            "description": "If specified, exclude any image where the filename matches any of the exclusion patterns. Patterns are specified the same as for include_glob_patterns."
          },
          "num_levels": {
            "default": 5,
            "title": "Num Levels",
            "type": "integer",
            "description": "Number of resolution-pyramid levels. If set to `5`, there will be the full-resolution level and 4 levels of downsampled images."
          },
          "coarsening_xy": {
            "default": 2,
            "title": "Coarsening Xy",
            "type": "integer",
            "description": "Linear coarsening factor between subsequent levels. If set to `2`, level 1 is 2x downsampled, level 2 is 4x downsampled etc."
          },
          "image_extension": {
            "default": "tif",
            "title": "Image Extension",
            "type": "string",
            "description": "Filename extension of images (e.g. `\"tif\"` or `\"png\"`)."
          },
          "metadata_table_files": {
            "additionalProperties": {
              "type": "string"
            },
            "title": "Metadata Table Files",
            "type": "object",
            "description": "If `None`, parse Yokogawa metadata from mrf/mlf files in the input_path folder; else, a dictionary of key-value pairs like `(acquisition, path)` with `acquisition` a string like the key of the `acquisitions` dict and `path` pointing to a csv file containing the parsed metadata table."
          },
          "overwrite": {
            "default": false,
            "title": "Overwrite",
            "type": "boolean",
            "description": "If `True`, overwrite the task output."
          }
        },
        "required": [
          "zarr_dir",
          "acquisitions"
        ],
        "type": "object",
        "title": "CellvoyagerToOmeZarrInitMultiplex"
      },
      "args_schema_parallel": {
        "$defs": {
          "ChunkSizes": {
            "description": "Chunk size settings for OME-Zarrs.",
            "properties": {
              "t": {
                "title": "T",
                "type": "integer"
              },
              "c": {
                "default": 1,
                "title": "C",
                "type": "integer"
              },
              "z": {
                "default": 10,
                "title": "Z",
                "type": "integer"
              },
              "y": {
                "title": "Y",
                "type": "integer"
              },
              "x": {
                "title": "X",
                "type": "integer"
              }
            },
            "title": "ChunkSizes",
            "type": "object"
          },
          "InitArgsCellVoyager": {
            "description": "Arguments to be passed from cellvoyager converter init to compute",
            "properties": {
              "image_dir": {
                "title": "Image Dir",
                "type": "string"
              },
              "plate_prefix": {
                "title": "Plate Prefix",
                "type": "string"
              },
              "well_ID": {
                "title": "Well Id",
                "type": "string"
              },
              "image_extension": {
                "title": "Image Extension",
                "type": "string"
              },
              "include_glob_patterns": {
                "items": {
                  "type": "string"
                },
                "title": "Include Glob Patterns",
                "type": "array"
              },
              "exclude_glob_patterns": {
                "items": {
                  "type": "string"
                },
                "title": "Exclude Glob Patterns",
                "type": "array"
              },
              "acquisition": {
                "title": "Acquisition",
                "type": "integer"
              }
            },
            "required": [
              "image_dir",
              "plate_prefix",
              "well_ID",
              "image_extension"
            ],
            "title": "InitArgsCellVoyager",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsCellVoyager",
            "title": "Init Args",
            "description": "Intialization arguments provided by `create_cellvoyager_ome_zarr_init`."
          },
          "chunk_sizes": {
            "$ref": "#/$defs/ChunkSizes",
            "title": "Chunk Sizes",
            "description": "Used to overwrite the default chunk sizes for the OME-Zarr. By default, the task will chunk the same as the microscope field of view size, with 10 z planes per chunk. For example, that can mean c: 1, z: 10, y: 2160, x:2560"
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "type": "object",
        "title": "CellvoyagerToOmeZarrCompute"
      },
      "docs_link": "https://fractal-analytics-platform.github.io/fractal-tasks-core"
    },
    {
      "name": "Project Image (HCS Plate)",
      "input_types": {
        "is_3D": true
      },
      "output_types": {
        "is_3D": false
      },
      "category": "Image Processing",
      "modality": "HCS",
      "tags": [
        "Preprocessing",
        "3D"
      ],
      "docs_info": "### Purpose\n- Performs **Z-axis projection of intensity images** using a specified projection method.\n- **Generates a new OME-Zarr HCS plate** to store the projected data.\n\n### Limitations\n- Supports projections only for OME-Zarr HCS plates; other collections of OME-Zarrs are not yet supported.\n- Currently limited to data in the CZYX format.\n",
      "type": "compound",
      "executable_non_parallel": "tasks/copy_ome_zarr_hcs_plate.py",
      "executable_parallel": "tasks/projection.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "meta_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "args_schema_non_parallel": {
        "$defs": {
          "DaskProjectionMethod": {
            "description": "Registration method selection",
            "enum": [
              "mip",
              "minip",
              "meanip",
              "sumip"
            ],
            "title": "DaskProjectionMethod",
            "type": "string"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "method": {
            "allOf": [
              {
                "$ref": "#/$defs/DaskProjectionMethod"
              }
            ],
            "default": "mip",
            "title": "Method",
            "description": "Choose which method to use for intensity projection along the Z axis. mip is the default and performs a maximum intensity projection. minip performs a minimum intensity projection, meanip a mean intensity projection and sumip a sum intensity projection."
          },
          "overwrite": {
            "default": false,
            "title": "Overwrite",
            "type": "boolean",
            "description": "If `True`, overwrite the MIP images if they are already present in the new OME-Zarr Plate."
          },
          "re_initialize_plate": {
            "default": false,
            "title": "Re Initialize Plate",
            "type": "boolean",
            "description": "If `True`, re-initialize the plate, deleting all existing wells and images. If `False`, the task will only incrementally add new wells and images to the plate."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "CopyOmeZarrHcsPlate"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsMIP": {
            "description": "Init Args for MIP task.",
            "properties": {
              "origin_url": {
                "title": "Origin Url",
                "type": "string"
              },
              "method": {
                "title": "Method",
                "type": "string"
              },
              "overwrite": {
                "title": "Overwrite",
                "type": "boolean"
              },
              "new_plate_name": {
                "title": "New Plate Name",
                "type": "string"
              }
            },
            "required": [
              "origin_url",
              "method",
              "overwrite",
              "new_plate_name"
            ],
            "title": "InitArgsMIP",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsMIP",
            "title": "Init Args",
            "description": "Intialization arguments provided by `create_cellvoyager_ome_zarr_init`."
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "type": "object",
        "title": "Projection"
      },
      "docs_link": "https://fractal-analytics-platform.github.io/fractal-tasks-core"
    },
    {
      "name": "Illumination Correction",
      "input_types": {
        "illumination_corrected": false
      },
      "output_types": {
        "illumination_corrected": true
      },
      "category": "Image Processing",
      "tags": [
        "Preprocessing",
        "2D",
        "3D"
      ],
      "docs_info": "### Purpose\n- **Corrects illumination** in OME-Zarr images using **pre-calculated flatfield profiles**.\n- Optionally performs **background subtraction**.\n\n### Limitations\n- Requires pre-calculated flatfield profiles in TIFF format.\n- Supports only fixed-value background subtraction; background subtraction profiles are not supported.\n",
      "type": "parallel",
      "executable_parallel": "tasks/illumination_correction.py",
      "meta_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "args_schema_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "illumination_profiles_folder": {
            "title": "Illumination Profiles Folder",
            "type": "string",
            "description": "Path of folder of illumination profiles."
          },
          "illumination_profiles": {
            "additionalProperties": {
              "type": "string"
            },
            "title": "Illumination Profiles",
            "type": "object",
            "description": "Dictionary where keys match the `wavelength_id` attributes of existing channels (e.g. `A01_C01` ) and values are the filenames of the corresponding illumination profiles."
          },
          "background": {
            "default": 0,
            "title": "Background",
            "type": "integer",
            "description": "Background value that is subtracted from the image before the illumination correction is applied. Set it to `0` if you don't want any background subtraction."
          },
          "input_ROI_table": {
            "default": "FOV_ROI_table",
            "title": "Input Roi Table",
            "type": "string",
            "description": "Name of the ROI table that contains the information about the location of the individual field of views (FOVs) to which the illumination correction shall be applied. Defaults to \"FOV_ROI_table\", the default name Fractal converters give the ROI tables that list all FOVs separately. If you generated your OME-Zarr with a different converter and used Import OME-Zarr to generate the ROI tables, `image_ROI_table` is the right choice if you only have 1 FOV per Zarr image and `grid_ROI_table` if you have multiple FOVs per Zarr image and set the right grid options during import."
          },
          "overwrite_input": {
            "default": true,
            "title": "Overwrite Input",
            "type": "boolean",
            "description": "If `True`, the results of this task will overwrite the input image data. If false, a new image is generated and the illumination corrected data is saved there."
          },
          "suffix": {
            "default": "_illum_corr",
            "title": "Suffix",
            "type": "string",
            "description": "What suffix to append to the illumination corrected images. Only relevant if `overwrite_input=False`."
          }
        },
        "required": [
          "zarr_url",
          "illumination_profiles_folder",
          "illumination_profiles"
        ],
        "type": "object",
        "title": "IlluminationCorrection"
      },
      "docs_link": "https://fractal-analytics-platform.github.io/fractal-tasks-core"
    },
    {
      "name": "Cellpose Segmentation",
      "category": "Segmentation",
      "tags": [
        "Deep Learning",
        "Convolutional Neural Network",
        "Instance Segmentation",
        "2D",
        "3D"
      ],
      "docs_info": "### Purpose\n- **Segments images using Cellpose models**.\n- Supports both **built-in Cellpose models** (shipped with Cellpose) and **user-trained models**.\n- Accepts dual image input for segmentation.\n- Can process **arbitrary regions of interest (ROIs)**, including whole images, fields of view (FOVs), or masked outputs from prior segmentations, based on corresponding ROI tables.\n- Provides access to all advanced Cellpose parameters.\n- Allows custom rescaling options per channel, particularly useful for sparse images.\n\n### Limitations\n- Compatible only with Cellpose 2.x models; does not yet support 3.x models.\n",
      "type": "parallel",
      "executable_parallel": "tasks/cellpose_segmentation.py",
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000,
        "needs_gpu": true
      },
      "args_schema_parallel": {
        "$defs": {
          "CellposeChannel1InputModel": {
            "description": "Channel input for cellpose with normalization options.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "string",
                "description": "Unique ID for the channel wavelength, e.g. `A01_C01`. Can only be specified if label is not set."
              },
              "label": {
                "title": "Label",
                "type": "string",
                "description": "Name of the channel. Can only be specified if wavelength_id is not set."
              },
              "normalize": {
                "$ref": "#/$defs/CellposeCustomNormalizer",
                "title": "Normalize",
                "description": "Validator to handle different normalization scenarios for Cellpose models"
              }
            },
            "title": "CellposeChannel1InputModel",
            "type": "object"
          },
          "CellposeChannel2InputModel": {
            "description": "Channel input for secondary cellpose channel with normalization options.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "string",
                "description": "Unique ID for the channel wavelength, e.g. `A01_C01`. Can only be specified if label is not set."
              },
              "label": {
                "title": "Label",
                "type": "string",
                "description": "Name of the channel. Can only be specified if wavelength_id is not set."
              },
              "normalize": {
                "$ref": "#/$defs/CellposeCustomNormalizer",
                "title": "Normalize",
                "description": "Validator to handle different normalization scenarios for Cellpose models"
              }
            },
            "title": "CellposeChannel2InputModel",
            "type": "object"
          },
          "CellposeCustomNormalizer": {
            "description": "Validator to handle different normalization scenarios for Cellpose models",
            "properties": {
              "type": {
                "default": "default",
                "enum": [
                  "default",
                  "custom",
                  "no_normalization"
                ],
                "title": "Type",
                "type": "string",
                "description": "One of `default` (Cellpose default normalization), `custom` (using the other custom parameters) or `no_normalization`."
              },
              "lower_percentile": {
                "maximum": 100.0,
                "minimum": 0.0,
                "title": "Lower Percentile",
                "type": "number",
                "description": "Specify a custom lower-bound percentile for rescaling as a float value between 0 and 100. Set to 1 to run the same as default). You can only specify percentiles or bounds, not both."
              },
              "upper_percentile": {
                "maximum": 100.0,
                "minimum": 0.0,
                "title": "Upper Percentile",
                "type": "number",
                "description": "Specify a custom upper-bound percentile for rescaling as a float value between 0 and 100. Set to 99 to run the same as default, set to e.g. 99.99 if the default rescaling was too harsh. You can only specify percentiles or bounds, not both."
              },
              "lower_bound": {
                "title": "Lower Bound",
                "type": "integer",
                "description": "Explicit lower bound value to rescale the image at. Needs to be an integer, e.g. 100. You can only specify percentiles or bounds, not both."
              },
              "upper_bound": {
                "title": "Upper Bound",
                "type": "integer",
                "description": "Explicit upper bound value to rescale the image at. Needs to be an integer, e.g. 2000. You can only specify percentiles or bounds, not both."
              }
            },
            "title": "CellposeCustomNormalizer",
            "type": "object"
          },
          "CellposeModelParams": {
            "description": "Advanced Cellpose Model Parameters",
            "properties": {
              "cellprob_threshold": {
                "default": 0.0,
                "title": "Cellprob Threshold",
                "type": "number",
                "description": "Parameter of `CellposeModel.eval` method. Valid values between -6 to 6. From Cellpose documentation: \"Decrease this threshold if cellpose is not returning as many ROIs as you'd expect. Similarly, increase this threshold if cellpose is returning too ROIs particularly from dim areas.\""
              },
              "flow_threshold": {
                "default": 0.4,
                "title": "Flow Threshold",
                "type": "number",
                "description": "Parameter of `CellposeModel.eval` method. Valid values between 0.0 and 1.0. From Cellpose documentation: \"Increase this threshold if cellpose is not returning as many ROIs as you'd expect. Similarly, decrease this threshold if cellpose is returning too many ill-shaped ROIs.\""
              },
              "anisotropy": {
                "title": "Anisotropy",
                "type": "number",
                "description": "Ratio of the pixel sizes along Z and XY axis (ignored if the image is not three-dimensional). If unset, it is inferred from the OME-NGFF metadata."
              },
              "min_size": {
                "default": 15,
                "title": "Min Size",
                "type": "integer",
                "description": "Parameter of `CellposeModel` class. Minimum size of the segmented objects (in pixels). Use `-1` to turn off the size filter."
              },
              "augment": {
                "default": false,
                "title": "Augment",
                "type": "boolean",
                "description": "Parameter of `CellposeModel` class. Whether to use cellpose augmentation to tile images with overlap."
              },
              "net_avg": {
                "default": false,
                "title": "Net Avg",
                "type": "boolean",
                "description": "Parameter of `CellposeModel` class. Whether to use cellpose net averaging to run the 4 built-in networks (useful for `nuclei`, `cyto` and `cyto2`, not sure it works for the others)."
              },
              "use_gpu": {
                "default": true,
                "title": "Use Gpu",
                "type": "boolean",
                "description": "If `False`, always use the CPU; if `True`, use the GPU if possible (as defined in `cellpose.core.use_gpu()`) and fall-back to the CPU otherwise."
              },
              "batch_size": {
                "default": 8,
                "title": "Batch Size",
                "type": "integer",
                "description": "number of 224x224 patches to run simultaneously on the GPU (can make smaller or bigger depending on GPU memory usage)"
              },
              "invert": {
                "default": false,
                "title": "Invert",
                "type": "boolean",
                "description": "invert image pixel intensity before running network (if True, image is also normalized)"
              },
              "tile": {
                "default": true,
                "title": "Tile",
                "type": "boolean",
                "description": "tiles image to ensure GPU/CPU memory usage limited (recommended)"
              },
              "tile_overlap": {
                "default": 0.1,
                "title": "Tile Overlap",
                "type": "number",
                "description": "fraction of overlap of tiles when computing flows"
              },
              "resample": {
                "default": true,
                "title": "Resample",
                "type": "boolean",
                "description": "run dynamics at original image size (will be slower but create more accurate boundaries)"
              },
              "interp": {
                "default": true,
                "title": "Interp",
                "type": "boolean",
                "description": "interpolate during 2D dynamics (not available in 3D) (in previous versions it was False, now it defaults to True)"
              },
              "stitch_threshold": {
                "default": 0.0,
                "title": "Stitch Threshold",
                "type": "number",
                "description": "if stitch_threshold>0.0 and not do_3D and equal image sizes, masks are stitched in 3D to return volume segmentation"
              }
            },
            "title": "CellposeModelParams",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "level": {
            "title": "Level",
            "type": "integer",
            "description": "Pyramid level of the image to be segmented. Choose `0` to process at full resolution."
          },
          "channel": {
            "$ref": "#/$defs/CellposeChannel1InputModel",
            "title": "Channel",
            "description": "Primary channel for segmentation; requires either `wavelength_id` (e.g. `A01_C01`) or `label` (e.g. `DAPI`), but not both. Also contains normalization options. By default, data is normalized so 0.0=1st percentile and 1.0=99th percentile of image intensities in each channel. This automatic normalization can lead to issues when the image to be segmented is very sparse. You can turn off the default rescaling. With the \"custom\" option, you can either provide your own rescaling percentiles or fixed rescaling upper and lower bound integers."
          },
          "channel2": {
            "$ref": "#/$defs/CellposeChannel2InputModel",
            "title": "Channel2",
            "description": "Second channel for segmentation (in the same format as `channel`). If specified, cellpose runs in dual channel mode. For dual channel segmentation of cells, the first channel should contain the membrane marker, the second channel should contain the nuclear marker."
          },
          "input_ROI_table": {
            "default": "FOV_ROI_table",
            "title": "Input Roi Table",
            "type": "string",
            "description": "Name of the ROI table over which the task loops to apply Cellpose segmentation. Examples: `FOV_ROI_table` => loop over the field of views, `organoid_ROI_table` => loop over the organoid ROI table (generated by another task), `well_ROI_table` => process the whole well as one image."
          },
          "output_ROI_table": {
            "title": "Output Roi Table",
            "type": "string",
            "description": "If provided, a ROI table with that name is created, which will contain the bounding boxes of the newly segmented labels. ROI tables should have `ROI` in their name."
          },
          "output_label_name": {
            "title": "Output Label Name",
            "type": "string",
            "description": "Name of the output label image (e.g. `\"organoids\"`)."
          },
          "diameter_level0": {
            "default": 30.0,
            "title": "Diameter Level0",
            "type": "number",
            "description": "Expected diameter of the objects that should be segmented in pixels at level 0. Initial diameter is rescaled using the `level` that was selected. The rescaled value is passed as the diameter to the `CellposeModel.eval` method."
          },
          "model_type": {
            "default": "cyto2",
            "enum": [
              "cyto",
              "nuclei",
              "tissuenet",
              "livecell",
              "cyto2",
              "general",
              "CP",
              "CPx",
              "TN1",
              "TN2",
              "TN3",
              "LC1",
              "LC2",
              "LC3",
              "LC4"
            ],
            "title": "Model Type",
            "type": "string",
            "description": "Parameter of `CellposeModel` class. Defines which model should be used. Typical choices are `nuclei`, `cyto`, `cyto2`, etc."
          },
          "pretrained_model": {
            "title": "Pretrained Model",
            "type": "string",
            "description": "Parameter of `CellposeModel` class (takes precedence over `model_type`). Allows you to specify the path of a custom trained cellpose model."
          },
          "relabeling": {
            "default": true,
            "title": "Relabeling",
            "type": "boolean",
            "description": "If `True`, apply relabeling so that label values are unique for all objects in the well."
          },
          "use_masks": {
            "default": true,
            "title": "Use Masks",
            "type": "boolean",
            "description": "If `True`, try to use masked loading and fall back to `use_masks=False` if the ROI table is not suitable. Masked loading is relevant when only a subset of the bounding box should actually be processed (e.g. running within `organoid_ROI_table`)."
          },
          "advanced_cellpose_model_params": {
            "$ref": "#/$defs/CellposeModelParams",
            "title": "Advanced Cellpose Model Params",
            "description": "Advanced Cellpose model parameters that are passed to the Cellpose `model.eval` method."
          },
          "overwrite": {
            "default": true,
            "title": "Overwrite",
            "type": "boolean",
            "description": "If `True`, overwrite the task output."
          }
        },
        "required": [
          "zarr_url",
          "level",
          "channel"
        ],
        "type": "object",
        "title": "CellposeSegmentation"
      },
      "docs_link": "https://fractal-analytics-platform.github.io/fractal-tasks-core"
    },
    {
      "name": "Calculate Registration (image-based)",
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "Multiplexing",
        "2D",
        "3D"
      ],
      "docs_info": "### Purpose\n- **Computes image-based registration** transformations for acquisitions in **HCS** OME-Zarr datasets.\n- Processes images grouped by well, under the assumption that each well contains one image per acquisition.\n- Calculates transformations for **specified regions of interest (ROIs)** and stores the results in the corresponding ROI table.\n- Typically used as the first task in a workflow, followed by `Find Registration Consensus` and optionally `Apply Registration to Image`.\n\n### Limitations\n- Supports only HCS OME-Zarr datasets, leveraging their acquisition metadata and well-based image grouping.\n- Assumes each well contains a single image per acquisition.\n",
      "type": "compound",
      "executable_non_parallel": "tasks/image_based_registration_hcs_init.py",
      "executable_parallel": "tasks/calculate_registration_image_based.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 1,
        "mem": 8000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Needs to match the acquisition metadata in the OME-Zarr image."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "ImageBasedRegistrationHcsInit"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistration": {
            "description": "Registration init args.",
            "properties": {
              "reference_zarr_url": {
                "title": "Reference Zarr Url",
                "type": "string"
              }
            },
            "required": [
              "reference_zarr_url"
            ],
            "title": "InitArgsRegistration",
            "type": "object"
          },
          "RegistrationMethod": {
            "description": "RegistrationMethod Enum class",
            "enum": [
              "phase_cross_correlation",
              "chi2_shift"
            ],
            "title": "RegistrationMethod",
            "type": "string"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistration",
            "title": "Init Args",
            "description": "Intialization arguments provided by `image_based_registration_hcs_init`. They contain the reference_zarr_url that is used for registration. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "wavelength_id": {
            "title": "Wavelength Id",
            "type": "string",
            "description": "Wavelength that will be used for image-based registration; e.g. `A01_C01` for Yokogawa, `C01` for MD."
          },
          "method": {
            "allOf": [
              {
                "$ref": "#/$defs/RegistrationMethod"
              }
            ],
            "default": "phase_cross_correlation",
            "title": "Method",
            "description": "Method to use for image registration. The available methods are `phase_cross_correlation` (scikit-image package, works for 2D & 3D) and \"chi2_shift\" (image_registration package, only works for 2D images)."
          },
          "lower_rescale_quantile": {
            "default": 0.0,
            "title": "Lower Rescale Quantile",
            "type": "number",
            "description": "Lower quantile for rescaling the image intensities before applying registration. Can be helpful to deal with image artifacts. Default is 0."
          },
          "upper_rescale_quantile": {
            "default": 0.99,
            "title": "Upper Rescale Quantile",
            "type": "number",
            "description": "Upper quantile for rescaling the image intensities before applying registration. Can be helpful to deal with image artifacts. Default is 0.99."
          },
          "roi_table": {
            "default": "FOV_ROI_table",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table over which the task loops to calculate the registration. Examples: `FOV_ROI_table` => loop over the field of views, `well_ROI_table` => process the whole well as one image."
          },
          "level": {
            "default": 2,
            "title": "Level",
            "type": "integer",
            "description": "Pyramid level of the image to be used for registration. Choose `0` to process at full resolution."
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "wavelength_id"
        ],
        "type": "object",
        "title": "CalculateRegistrationImageBased"
      },
      "docs_link": "https://fractal-analytics-platform.github.io/fractal-tasks-core"
    },
    {
      "name": "Find Registration Consensus",
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "Multiplexing",
        "2D",
        "3D"
      ],
      "docs_info": "### Purpose\n- Determines the **consensus alignment** region across all selected acquisitions **within each well of an HCS OME-Zarr dataset**.\n- Generates a new ROI table for each image, defining consensus regions that are aligned across all acquisitions.\n- Typically used as the second task in a workflow, following `Calculate Registration (image-based)` and optionally preceding `Apply Registration to Image`.\n\n### Limitations\n- Supports only HCS OME-Zarr datasets, leveraging their acquisition metadata and well-based image grouping.\n",
      "type": "compound",
      "executable_non_parallel": "tasks/init_group_by_well_for_multiplexing.py",
      "executable_parallel": "tasks/find_registration_consensus.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Uses the OME-NGFF HCS well metadata acquisition keys to find the reference acquisition."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "InitGroupByWellForMultiplexing"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistrationConsensus": {
            "description": "Registration consensus init args.",
            "properties": {
              "zarr_url_list": {
                "items": {
                  "type": "string"
                },
                "title": "Zarr Url List",
                "type": "array"
              }
            },
            "required": [
              "zarr_url_list"
            ],
            "title": "InitArgsRegistrationConsensus",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. Refers to the zarr_url of the reference acquisition. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistrationConsensus",
            "title": "Init Args",
            "description": "Intialization arguments provided by `init_group_by_well_for_multiplexing`. It contains the zarr_url_list listing all the zarr_urls in the same well as the zarr_url of the reference acquisition that are being processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "roi_table": {
            "default": "FOV_ROI_table",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table over which the task loops to calculate the registration. Examples: `FOV_ROI_table` => loop over the field of views, `well_ROI_table` => process the whole well as one image."
          },
          "new_roi_table": {
            "title": "New Roi Table",
            "type": "string",
            "description": "Optional name for the new, registered ROI table. If no name is given, it will default to \"registered_\" + `roi_table`"
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "type": "object",
        "title": "FindRegistrationConsensus"
      },
      "docs_link": "https://fractal-analytics-platform.github.io/fractal-tasks-core"
    },
    {
      "name": "Apply Registration to Image",
      "input_types": {
        "registered": false
      },
      "output_types": {
        "registered": true
      },
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "Multiplexing",
        "2D",
        "3D"
      ],
      "docs_info": "### Purpose\n- **Applies pre-calculated registration** transformations to images in an **HCS** OME-Zarr dataset, aligning all acquisitions to a specified reference acquisition.\n- **Masks regions not included** in the registered ROI table and aligns both intensity and label images.\n- Replaces the non-aligned image with the newly aligned image in the dataset if `overwrite input` is selected.\n- Typically used as the third task in a workflow, following `Calculate Registration (image-based)` and `Find Registration Consensus`.\n\n### Limitations\n- If `overwrite input` is selected, the non-aligned image is permanently deleted, which may impact workflows requiring access to the original images.\n",
      "type": "parallel",
      "executable_parallel": "tasks/apply_registration_to_image.py",
      "meta_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "args_schema_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "registered_roi_table": {
            "title": "Registered Roi Table",
            "type": "string",
            "description": "Name of the ROI table which has been registered and will be applied to mask and shift the images. Examples: `registered_FOV_ROI_table` => loop over the field of views, `registered_well_ROI_table` => process the whole well as one image."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Uses the OME-NGFF HCS well metadata acquisition keys to find the reference acquisition."
          },
          "overwrite_input": {
            "default": true,
            "title": "Overwrite Input",
            "type": "boolean",
            "description": "Whether the old image data should be replaced with the newly registered image data. Currently only implemented for `overwrite_input=True`."
          }
        },
        "required": [
          "zarr_url",
          "registered_roi_table"
        ],
        "type": "object",
        "title": "ApplyRegistrationToImage"
      },
      "docs_link": "https://fractal-analytics-platform.github.io/fractal-tasks-core"
    },
    {
      "name": "Import OME-Zarr",
      "tags": [
        "2D",
        "3D"
      ],
      "docs_info": "### Purpose\n- Imports a **single OME-Zarr dataset** into the Fractal framework for further processing.\n- Supports importing either a **full OME-Zarr HCS plate** or an **individual OME-Zarr image**.\n- Ensures the OME-Zarr dataset is located in the `zarr_dir` specified by the dataset.\n- Generates the necessary **image list metadata** required for processing the OME-Zarr with Fractal.\n- Optionally **adds new ROI tables** to the existing OME-Zarr, enabling compatibility with many other tasks.\n\n### Limitations\n- Supports only OME-Zarr datasets already present in the `zarr_dir` of the corresponding dataset.\n- Assumes the input OME-Zarr is correctly structured and formatted for compatibility with the Fractal framework.\n",
      "type": "converter_non_parallel",
      "executable_non_parallel": "tasks/import_ome_zarr.py",
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_name": {
            "title": "Zarr Name",
            "type": "string",
            "description": "The OME-Zarr name, without its parent folder. The parent folder is provided by zarr_dir; e.g. `zarr_name=\"array.zarr\"`, if the OME-Zarr path is in `/zarr_dir/array.zarr`."
          },
          "update_omero_metadata": {
            "default": true,
            "title": "Update Omero Metadata",
            "type": "boolean",
            "description": "Whether to update Omero-channels metadata, to make them Fractal-compatible."
          },
          "add_image_ROI_table": {
            "default": true,
            "title": "Add Image Roi Table",
            "type": "boolean",
            "description": "Whether to add a `image_ROI_table` table to each image, with a single ROI covering the whole image."
          },
          "add_grid_ROI_table": {
            "default": true,
            "title": "Add Grid Roi Table",
            "type": "boolean",
            "description": "Whether to add a `grid_ROI_table` table to each image, with the image split into a rectangular grid of ROIs."
          },
          "grid_y_shape": {
            "default": 2,
            "title": "Grid Y Shape",
            "type": "integer",
            "description": "Y shape of the ROI grid in `grid_ROI_table`."
          },
          "grid_x_shape": {
            "default": 2,
            "title": "Grid X Shape",
            "type": "integer",
            "description": "X shape of the ROI grid in `grid_ROI_table`."
          },
          "overwrite": {
            "default": false,
            "title": "Overwrite",
            "type": "boolean",
            "description": "Whether new ROI tables (added when `add_image_ROI_table` and/or `add_grid_ROI_table` are `True`) can overwite existing ones."
          }
        },
        "required": [
          "zarr_dir",
          "zarr_name"
        ],
        "type": "object",
        "title": "ImportOmeZarr"
      },
      "docs_link": "https://fractal-analytics-platform.github.io/fractal-tasks-core"
    },
    {
      "name": "Napari Workflows Wrapper",
      "category": "Measurement",
      "tags": [
        "2D",
        "3D"
      ],
      "docs_info": "### Purpose\n- Executes a **napari workflow** on the regions of interest (ROIs) within a single OME-NGFF image.\n- Processes specified images and labels as inputs to the workflow, producing outputs such as new labels and data tables.\n- Offers **flexibility in defining input and output** specifications to customize the workflow for specific datasets and analysis needs.\n\n### Limitations\n- Currently supports only Napari workflows that utilize functions from the `napari-segment-blobs-and-things-with-membranes` module. Other Napari-compatible modules are not supported.\n\n### Input Specifications\nNapari workflows require explicit definitions of input and output data.\nExample of valid `input_specs`:\n```json\n{\n    \"in_1\": {\"type\": \"image\", \"channel\": {\"wavelength_id\": \"A01_C02\"}},\n    \"in_2\": {\"type\": \"image\", \"channel\": {\"label\": \"DAPI\"}},\n    \"in_3\": {\"type\": \"label\", \"label_name\": \"label_DAPI\"}\n}\n```\n\nExample of valid `output_specs`:\n```json\n{\n    \"out_1\": {\"type\": \"label\", \"label_name\": \"label_DAPI_new\"},\n    \"out_2\": {\"type\": \"dataframe\", \"table_name\": \"measurements\"},\n}\n```\n",
      "type": "parallel",
      "executable_parallel": "tasks/napari_workflows_wrapper.py",
      "meta_parallel": {
        "cpus_per_task": 8,
        "mem": 32000
      },
      "args_schema_parallel": {
        "$defs": {
          "ChannelInputModel": {
            "description": "A channel which is specified by either `wavelength_id` or `label`.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "string",
                "description": "Unique ID for the channel wavelength, e.g. `A01_C01`. Can only be specified if label is not set."
              },
              "label": {
                "title": "Label",
                "type": "string",
                "description": "Name of the channel. Can only be specified if wavelength_id is not set."
              }
            },
            "title": "ChannelInputModel",
            "type": "object"
          },
          "NapariWorkflowsInput": {
            "description": "A value of the `input_specs` argument in `napari_workflows_wrapper`.",
            "properties": {
              "type": {
                "enum": [
                  "image",
                  "label"
                ],
                "title": "Type",
                "type": "string",
                "description": "Input type (either `image` or `label`)."
              },
              "label_name": {
                "title": "Label Name",
                "type": "string",
                "description": "Label name (for label inputs only)."
              },
              "channel": {
                "allOf": [
                  {
                    "$ref": "#/$defs/ChannelInputModel"
                  }
                ],
                "title": "Channel",
                "description": "`ChannelInputModel` object (for image inputs only)."
              }
            },
            "required": [
              "type"
            ],
            "title": "NapariWorkflowsInput",
            "type": "object"
          },
          "NapariWorkflowsOutput": {
            "description": "A value of the `output_specs` argument in `napari_workflows_wrapper`.",
            "properties": {
              "type": {
                "enum": [
                  "label",
                  "dataframe"
                ],
                "title": "Type",
                "type": "string",
                "description": "Output type (either `label` or `dataframe`)."
              },
              "label_name": {
                "title": "Label Name",
                "type": "string",
                "description": "Label name (for label outputs, it is used as the name of the label; for dataframe outputs, it is used to fill the `region[\"path\"]` field)."
              },
              "table_name": {
                "title": "Table Name",
                "type": "string",
                "description": "Table name (for dataframe outputs only)."
              }
            },
            "required": [
              "type",
              "label_name"
            ],
            "title": "NapariWorkflowsOutput",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "workflow_file": {
            "title": "Workflow File",
            "type": "string",
            "description": "Absolute path to napari-workflows YAML file"
          },
          "input_specs": {
            "additionalProperties": {
              "$ref": "#/$defs/NapariWorkflowsInput"
            },
            "title": "Input Specs",
            "type": "object",
            "description": "A dictionary of `NapariWorkflowsInput` values."
          },
          "output_specs": {
            "additionalProperties": {
              "$ref": "#/$defs/NapariWorkflowsOutput"
            },
            "title": "Output Specs",
            "type": "object",
            "description": "A dictionary of `NapariWorkflowsOutput` values."
          },
          "input_ROI_table": {
            "default": "FOV_ROI_table",
            "title": "Input Roi Table",
            "type": "string",
            "description": "Name of the ROI table over which the task loops to apply napari workflows. Examples: `FOV_ROI_table` => loop over the field of views; `organoid_ROI_table` => loop over the organoid ROI table (generated by another task); `well_ROI_table` => process the whole well as one image."
          },
          "level": {
            "default": 0,
            "title": "Level",
            "type": "integer",
            "description": "Pyramid level of the image to be used as input for napari-workflows. Choose `0` to process at full resolution. Levels > 0 are currently only supported for workflows that only have intensity images as input and only produce a label images as output."
          },
          "relabeling": {
            "default": true,
            "title": "Relabeling",
            "type": "boolean",
            "description": "If `True`, apply relabeling so that label values are unique across all ROIs in the well."
          },
          "expected_dimensions": {
            "default": 3,
            "title": "Expected Dimensions",
            "type": "integer",
            "description": "Expected dimensions (either `2` or `3`). Useful when loading 2D images that are stored in a 3D array with shape `(1, size_x, size_y)` [which is the default way Fractal stores 2D images], but you want to make sure the napari workflow gets a 2D array to process. Also useful to set to `2` when loading a 2D OME-Zarr that is saved as `(size_x, size_y)`."
          },
          "overwrite": {
            "default": true,
            "title": "Overwrite",
            "type": "boolean",
            "description": "If `True`, overwrite the task output."
          }
        },
        "required": [
          "zarr_url",
          "workflow_file",
          "input_specs",
          "output_specs"
        ],
        "type": "object",
        "title": "NapariWorkflowsWrapper"
      },
      "docs_link": "https://fractal-analytics-platform.github.io/fractal-tasks-core"
    }
  ],
  "has_args_schemas": true,
  "args_schema_version": "pydantic_v2",
  "authors": "Fractal Core Team"
}
