{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Fractal Tasks Core's documentation!","text":"<p>Fractal tasks core is the official task package for the Fractal framework. It provides essential tools for building Fractal tasks, helpful utility functions, and a collection of ready-to-use tasks for processing bioimaging data. These tasks include OME-Zarr conversion, image registration, segmentation, and measurements.</p> <p>This project is under active development \ud83d\udd28. If you need help or found a bug, open an issue here.</p> <p> Fractal is a framework developed at the BioVisionCenter to process bioimaging data at scale in the OME-Zarr format and prepare the images for interactive visualization.</p>"},{"location":"#available-tasks","title":"Available Tasks","text":"<p>This package includes the following tasks. For all available Fractal tasks, check the task list page.</p> <p>Image Conversion:</p> <ul> <li>Convert Cellvoyager to OME-Zarr: Converts CV7000/CV8000 images to OME-Zarr format.</li> <li>Convert Cellvoyager Multiplexing to OME-Zarr: Converts multiplexed images from CV7000/CV8000 to OME-Zarr.</li> </ul> <p>Image Processing:</p> <ul> <li>Project Image (HCS Plate): Generates intensity projections (e.g., maximum intensity projection) for images in an HCS plate.</li> <li>Illumination Correction: Applies flatfield correction and background subtraction using pre-calculated illumination profiles.</li> </ul> <p>Segmentation:</p> <ul> <li>Cellpose Segmentation: Segments images using custom or pre-trained Cellpose models, with user-tunable options.</li> </ul> <p>Registration:</p> <ul> <li>Calculate Registration: Computes translations for aligning images in multiplexed image analysis.</li> <li>Find Registration Consensus: Generates consensus transformations for aligning multiple acquisitions, updating ROI tables as necessary.</li> <li>Apply Registration to Image: Applies registration to images based on existing or newly created ROI tables.</li> </ul> <p>Measurements:</p> <ul> <li>Napari Workflows Wrapper: Task to run existing napari workflows through Fractal to process images and labels and to generate new labels or measurement tables. Takes an arbitrary napari workflow yaml file to run.</li> </ul> <p>Other Utilities:</p> <ul> <li>Import OME-Zarr: Validates and processes existing OME-Zarr files, adding ROI tables and metadata for further processing in Fractal.</li> </ul>"},{"location":"#contributors-and-license","title":"Contributors and license","text":"<p>Fractal was conceived in the Liberali Lab at the Friedrich Miescher Institute for Biomedical Research and in the Pelkmans Lab at the University of Zurich by @jluethi and @gusqgm. The Fractal project is now developed at the BioVisionCenter at the University of Zurich and the project lead is with @jluethi. The core development is done under contract by eXact lab S.r.l..</p> <p>Unless otherwise specified, Fractal components are released under the BSD 3-Clause License, and copyright is with the BioVisionCenter at the University of Zurich.</p>"},{"location":"all_tasks/","title":"Task list","text":"<p>Here is a list of tasks that are available within Fractal-compatible packages, including both <code>fractal-tasks-core</code> and others.</p> <p>These are the tasks that we are aware of; if you created your own package of Fractal tasks, reach out to have it listed here (or, if you want to build your own tasks, follow these instructions).</p>"},{"location":"all_tasks/#fractal-tasks-core","title":"<code>fractal-tasks-core</code>","text":"<p>Package: <code>fractal-tasks-core</code></p> <p>Home page: https://fractal-analytics-platform.github.io/fractal-tasks-core</p> <p>Description: The Fractal tasks core package is the reference implementation for Fractal tasks. It contains tasks to convert Cellvoyager CV7000 and CV8000 images to OME-Zarr, to make 3D projections, apply flatfield illumination corrections, segment objects using Cellpose, run napari workflows, calculate &amp; apply registration and to import OME-Zarrs into a Fractal workflow.</p> <p>Tasks:</p> <ul> <li>Convert Cellvoyager to OME-Zarr</li> <li>Convert Cellvoyager Multiplexing to OME-Zarr</li> <li>Project Image (HCS Plate)</li> <li>Illumination Correction</li> <li>Cellpose Segmentation</li> <li>Calculate Registration (image-based)</li> <li>Find Registration Consensus</li> <li>Apply Registration to Image</li> <li>Import OME-Zarr</li> <li>Napari Workflows Wrapper</li> </ul>"},{"location":"all_tasks/#scmultiplex","title":"<code>scMultiplex</code>","text":"<p>Package: <code>scMultiplex</code></p> <p>Home page: https://github.com/fmi-basel/gliberal-scMultipleX</p> <p>Description: The scMultipleX package contains tasks to perform object-based registration, multiplexed measurements, mesh generations and more.</p> <p>Tasks:</p> <ul> <li>scMultiplex Calculate Object Linking</li> <li>scMultiplex Calculate Linking Consensus</li> <li>scMultiplex Relabel by Linking Consensus</li> <li>scMultiplex Calculate Platymatch Registration</li> <li>scMultiplex Surface Mesh Multiscale</li> <li>scMultiplex Segment by Intensity Threshold</li> <li>scMultiplex Spherical Harmonics from Label Image</li> <li>scMultiplex Mesh Measurements</li> <li>scMultiplex Feature Measurements</li> <li>scMultiplex Expand Labels</li> <li>scMultiplex Calculate Z-Illumination Correction</li> <li>scMultiplex Apply Z-Illumination Correction</li> <li>scMultiplex Fuse Touching Labels</li> <li>Convert 3D Segmentation to MIP</li> <li>Build Label Image</li> <li>Annotate Mesh by Child Features</li> <li>Cleanup 3D Child Labels</li> <li>scMultiplex Shift by Shift</li> <li>scMultiplex Calculate Warpfield Registration</li> <li>scMultiplex Apply Warpfield Registration</li> <li>scMultiplex Post Registration Cleanup</li> </ul>"},{"location":"all_tasks/#fractal-faim-ipa","title":"<code>fractal-faim-ipa</code>","text":"<p>Package: <code>fractal-faim-ipa</code></p> <p>Home page: https://github.com/fractal-analytics-platform/fractal-faim-ipa</p> <p>Description: Provides Fractal tasks for the conversion of Molecular Devices ImageXpress microscope to OME-Zarr. This package is based on the faim-ipa library developed by FAIM at FMI.</p> <p>Tasks:</p> <ul> <li>Convert MD to OME-Zarr</li> <li>FAIM-IPA Convert Cellvoyager to OME-Zarr</li> </ul>"},{"location":"all_tasks/#fractal-helper-tasks","title":"<code>fractal-helper-tasks</code>","text":"<p>Package: <code>fractal-helper-tasks</code></p> <p>Home page: https://github.com/fractal-analytics-platform/fractal-helper-tasks</p> <p>Description: Collection of Fractal helper tasks.</p> <p>Tasks:</p> <ul> <li>Drop T Dimension</li> <li>Convert 2D segmentation to 3D</li> <li>Rechunk OME-Zarr</li> <li>Add Z Singleton Dimension</li> <li>Assign Label by Overlap</li> </ul>"},{"location":"all_tasks/#apx_fractal_task_collection","title":"<code>APx_fractal_task_collection</code>","text":"<p>Package: <code>APx_fractal_task_collection</code></p> <p>Home page: https://github.com/Apricot-Therapeutics/APx_fractal_task_collection</p> <p>Description: The APx Fractal Task Collection is mainainted by Apricot Therapeutics AG, Switzerland. This is a collection of tasks intended to be used in combination with the Fractal Analytics Platform maintained by the BioVisionCenter Zurich (co-founded by the Friedrich Miescher Institute and the University of Zurich). The tasks in this collection are focused on extending Fractal's capabilities of processing 2D image data, with a special focus on multiplexed 2D image data. Most tasks work with 3D image data, but they have not specifically been developed for this scenario.</p> <p>Tasks:</p> <ul> <li>Measure Features</li> <li>Calculate Pixel Intensity Correlation</li> <li>Segment Secondary Objects</li> <li>Expand Labels</li> <li>Convert IC6000 to OME-Zarr</li> <li>Add Multiplexing Cycle IC6000</li> <li>Label Assignment by Overlap</li> <li>Clip Label Image</li> <li>Mask Label Image</li> <li>Filter Label by Size</li> <li>Calculate BaSiCPy Illumination Models</li> <li>Apply BaSiCPy Illumination Models</li> <li>Aggregate Feature Tables</li> <li>Stitch FOVs with Overlap</li> <li>Multiplexed Pixel Clustering</li> <li>Correct Chromatic Shift</li> <li>Convert Channel to Label</li> <li>Detect Blob Centroids</li> <li>Ashlar Stitching and Registration</li> <li>Merge Plate Metadata</li> <li>Normalize Feature Table</li> <li>Correct 4i Bleaching Artifacts</li> </ul>"},{"location":"all_tasks/#operetta-compose","title":"<code>operetta-compose</code>","text":"<p>Package: <code>operetta-compose</code></p> <p>Home page: https://github.com/leukemia-kispi/operetta-compose</p> <p>Description: Fractal tasks for the Opera/Operetta microscope and drug response profiling.</p> <p>Tasks:</p> <ul> <li>Harmony to OME-Zarr</li> <li>Stardist segmentation</li> <li>Regionprops measurement</li> <li>Feature classification</li> <li>Condition registration</li> </ul>"},{"location":"all_tasks/#fractal-plantseg-tasks","title":"<code>fractal-plantseg-tasks</code>","text":"<p>Package: <code>fractal-plantseg-tasks</code></p> <p>Home page: https://github.com/fractal-analytics-platform/fractal-plantseg-tasks</p> <p>Description: Collection of Fractal task with the PlantSeg segmentation pipeline.</p> <p>Tasks:</p> <ul> <li>H5 Converter Task</li> <li>Tiff Converter Task</li> <li>PlantSeg Workflow Task</li> </ul>"},{"location":"all_tasks/#fractal-ome-zarr-hcs-stitching","title":"<code>fractal-ome-zarr-hcs-stitching</code>","text":"<p>Package: <code>fractal-ome-zarr-hcs-stitching</code></p> <p>Home page: https://github.com/m-albert/fractal-ome-zarr-hcs-stitching</p> <p>Description: Fractal task(s) for registering and fusing OME-Zarr HCS using multiview-stitcher.</p> <p>Tasks:</p> <ul> <li>Stitching Task</li> </ul>"},{"location":"all_tasks/#fractal-lif-converters","title":"<code>fractal-lif-converters</code>","text":"<p>Package: <code>fractal-lif-converters</code></p> <p>Home page: https://github.com/fractal-analytics-platform/fractal-lif-converters</p> <p>Description: OME-Zarr converters for Leica Lif files built using bioio</p> <p>Tasks:</p> <ul> <li>Convert Lif Plate to OME-Zarr</li> <li>Convert Lif Scene to OME-Zarr</li> </ul>"},{"location":"all_tasks/#fractal-ilastik-tasks","title":"<code>fractal-ilastik-tasks</code>","text":"<p>Package: <code>fractal-ilastik-tasks</code></p> <p>Home page: https://github.com/fractal-analytics-platform/fractal-ilastik-tasks</p> <p>Description: Collection of Fractal task to run Headless ilastik workflows. Early prototype version, feedback is welcome.</p> <p>Tasks:</p> <ul> <li>Ilastik Pixel Classification Segmentation</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>Note: Numbers like (#123) point to closed Pull Requests on the fractal-tasks-core repository.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":"<ul> <li>Bump versions of <code>pre-commit</code> tools (#975).</li> <li>Testing:<ul> <li>Update poetry to 1.8.5 (#972).</li> <li>Run GHAs on ubuntu-24.04 (#972).</li> </ul> </li> </ul>"},{"location":"changelog/#154","title":"1.5.4","text":"<ul> <li>Tasks:<ul> <li>Catch <code>FileNotFoundError</code> in <code>apply_registration_to_image</code> task when race conditions with the reference cycle are hit (#971).</li> </ul> </li> <li>Dependencies:<ul> <li>Pin <code>lxml</code> to <code>&lt;=5.4.0</code> (#963).</li> </ul> </li> </ul>"},{"location":"changelog/#153","title":"1.5.3","text":"<ul> <li>Tasks:<ul> <li>Fix the heuristic in the Apply registration task to handle the registration of the reference cycle better (#959).</li> </ul> </li> </ul>"},{"location":"changelog/#152","title":"1.5.2","text":"<ul> <li>Library<ul> <li>Update masked loading wrapper to support loading masking ROIs written by ngio (#957).</li> </ul> </li> </ul>"},{"location":"changelog/#151","title":"1.5.1","text":"<ul> <li>Tasks:<ul> <li>In <code>Convert Cellvoyager to OME-Zarr</code> &amp; <code>Convert Cellvoyager Multiplexing to OME-Zarr</code> tasks, handle unset window start &amp; end better (#953).</li> <li>In <code>Convert Cellvoyager to OME-Zarr</code> &amp; <code>Convert Cellvoyager Multiplexing to OME-Zarr</code> tasks, normalize plate names to avoid special characters &amp; spaces (#953).</li> <li>In <code>Convert Cellvoyager Multiplexing to OME-Zarr</code>, improve error message when no images are found (#953).</li> <li>In <code>Convert Cellvoyager Multiplexing to OME-Zarr</code>, handle order of acquisitions better (#953).</li> </ul> </li> </ul>"},{"location":"changelog/#150","title":"1.5.0","text":"<ul> <li>Tasks:<ul> <li>Refactor <code>projection</code> task to use the new <code>ngio</code> API (#937, #943, #944).</li> <li>Refactor <code>copy_ome_zarr_plate</code> init task to support the upcoming flexibility.</li> <li>Rely on <code>fractal-task-tools</code> for <code>run_fractal_task</code> wrapper (#923).</li> <li>Mark some existing tasks as converter tasks(#923).</li> <li>Mark existing <code>run_fractal_task</code> wrapper as deprecated (#923).</li> </ul> </li> <li>Manifest generation:<ul> <li>Rely on <code>fractal-task-tools</code> for manifest building (#923).</li> <li>Mark existing tools as deprecated (#923).</li> </ul> </li> <li>Testing:<ul> <li>Add new (redundand) <code>ngio</code>-based testing.</li> <li>Fix links to ome/ngff specs (#930).</li> </ul> </li> <li>Dependencies:<ul> <li>Add <code>fractal-task-tools==0.0.10</code> dependency (#923).</li> <li>Bump <code>ngio</code> to <code>&gt;=0.2.4,&lt;0.3.0</code> (#943).</li> <li>Drop support for Python 3.10 (#932).</li> <li>Bump <code>fractal-task-tools</code> to <code>0.0.12</code> (#933).</li> <li>Pin <code>numcodecs</code> to <code>&lt;0.16</code> (#932).</li> </ul> </li> </ul>"},{"location":"changelog/#143","title":"1.4.3","text":"<ul> <li>Tasks:<ul> <li>Update <code>apply_registration_to_image</code> to handle race conditions better (#919).</li> </ul> </li> <li>Testing<ul> <li>Add <code>spherical-harmonics</code> extra to scmultiplex, for testing manifest build (#899).</li> <li>Move manifest-creation CI to Python 3.11 (#915).</li> </ul> </li> </ul>"},{"location":"changelog/#142","title":"1.4.2","text":"<ul> <li>Dependencies:<ul> <li>Relax <code>ngio</code> from <code>0.1.4</code> to <code>&gt;=0.1.5,&lt;0.2.0</code> (#900).</li> </ul> </li> <li>Library<ul> <li>Ensure <code>build_pyramid</code> uses directory store by default (#902).</li> </ul> </li> </ul>"},{"location":"changelog/#141","title":"1.4.1","text":"<ul> <li>Tasks:<ul> <li>Remove overlap checking for output ROIs in Cellpose task to address performance issues (#889).</li> <li>Expose chunking options in Cellvoyager OME-Zarr converter &amp; set default Z chunking to 10 (#898).</li> </ul> </li> <li>Library<ul> <li>Expose kwargs for <code>build_pyramid</code> (#895).</li> </ul> </li> <li>Testing:<ul> <li>Fix issues with coverage report listing <code>.venv</code> Python modules for other dependencies (#892).</li> <li>Add <code>persist-credentials: false</code> to all <code>actions/checkout@v4</code> GitHub Action steps (#893).</li> </ul> </li> </ul>"},{"location":"changelog/#140","title":"1.4.0","text":"<ul> <li>Tasks:<ul> <li>Refactor projection task to use ngio (#866).</li> </ul> </li> <li>Dependencies:<ul> <li>Add <code>ngio==0.1.4</code> to the dependencies</li> <li>Require <code>python &gt;=3.10,&lt;3.13</code></li> </ul> </li> <li>CI:<ul> <li>Remove Python 3.9 from the CI matrix</li> </ul> </li> <li>Tests:<ul> <li>Use locked version of <code>coverage</code> in GitHub action (#882).</li> <li>Bump <code>coverage</code> version from 6.5 to 7.6 (#882).</li> <li>Skip <code>test_import_ome_zarr_image_BIA</code> (#879).</li> </ul> </li> </ul>"},{"location":"changelog/#134","title":"1.3.4","text":"<ul> <li>Manifest creation:<ul> <li>Support providing <code>docs_info=file:task_info/description.md</code> (#876).</li> <li>Deprecate <code>check_manifest.py</code> module, in favor of additional GitHub action steps (#876).</li> </ul> </li> </ul>"},{"location":"changelog/#133","title":"1.3.3","text":"<ul> <li>Add new metadata (authors, category, modality, tags) to manifest models and to tasks (#855).</li> </ul>"},{"location":"changelog/#132","title":"1.3.2","text":"<ul> <li>Tasks:<ul> <li>Add percentile-based rescaling to calculate registration task to make it more robust (#848)</li> </ul> </li> <li>Dependencies:</li> <li>Relax pandas constraint to <code>&lt;2</code>.</li> <li>Relax torch constraint to <code>&lt;=3.0.0</code>.</li> <li>Relax numpy constraint to <code>&lt;2.1.0</code>.</li> <li>Add python 3.12 to the CI matrix (#770).</li> <li>Chores:</li> <li>fix future warning when using Series.getitem with positional arguments.</li> </ul>"},{"location":"changelog/#131","title":"1.3.1","text":"<ul> <li>Testing<ul> <li>Use latest version of Zenodo tiny-ome-zarr dataset (#817).</li> <li>Relax pip-version constraint in external-packages-manifest tests (#825).</li> <li>Run pip-based CI also regularly and on-demand (#829).</li> <li>Update GitHub actions for upload/download/coverage (#832).</li> </ul> </li> <li>Dependencies:<ul> <li>Require <code>pydantic&lt;=2.8.2</code> (#836).</li> <li>Require <code>stackview&lt;=0.9.0</code> (#829).</li> </ul> </li> <li>Documentation:<ul> <li>Bump <code>mkdocstrings</code> and <code>mkdocstrings-python</code> to support <code>griffe</code> v1 (#818).</li> </ul> </li> </ul>"},{"location":"changelog/#130","title":"1.3.0","text":"<ul> <li>Tasks:<ul> <li><code>image_glob_patterns</code> are renamed to <code>include_glob_patterns</code> in Convert Cellvoyager to OME-Zarr (regular &amp; multiplexing) (#812).</li> <li>Convert Cellvoyager to OME-Zarr (regular &amp; multiplexing) gain exclusion patterns to exclude specific patterns of images from being processed (#812).</li> <li>Fix issue with arbitrary acquisition names in Convert Cellvoyager Multiplexing to OME-Zarr (#812).</li> <li>In Convert Cellvoyager to OME-Zarr (regular &amp; multiplexing), handle channels in the mrf metadata file that aren't present in the mlf metadata better (#812).</li> <li>In Convert Cellvoyager to OME-Zarr, improve plate metadata for image list when multiple plates with the same plate name are processed (#812).</li> <li>Catch errors for missing mlf &amp; mrf files better in Convert Cellvoyager to OME-Zarr (regular &amp; multiplexing) (#812).</li> <li>Drop defusexml dependency for cellvoyager metadata conversion (#812).</li> <li>Rename <code>Maximum Intensity Projection HCS Plate</code> task to <code>Project Image (HCS Plate)</code> (#814).</li> <li>Expose selection of projection modes in <code>Project Image (HCS Plate)</code>: MIP, MINIP, MEANIP &amp; SUMIP (#814).</li> <li>Rename task function from <code>maximum_intensity_projection</code> to <code>projection</code> and modified parameters in <code>fractal_tasks_core.tasks.io_models.InitArgsMIP</code> (#814).</li> </ul> </li> </ul>"},{"location":"changelog/#121","title":"1.2.1","text":"<ul> <li>Core-library<ul> <li>Add <code>create_roi_table_from_df_list</code> library function in <code>fractal_tasks_core.v1.roi</code>: It combines a list of ROI table dataframes into an AnnData ROI table and handles repeating labels (#811).</li> <li>Move <code>create_well_acquisition_dict</code> &amp; <code>_split_well_path_image_path</code> from <code>fractal_tasks_core.tasks._registration_utils.py</code> &amp; <code>fractal_tasks_core.tasks._zarr_utils</code> into <code>fractal_tasks_core.utils</code> (#811).</li> </ul> </li> <li>Tasks:<ul> <li>Fixes issue 810 for Cellpose task: Avoids creating duplicated entries in ROI tables when masking ROI table input was used (#811).</li> </ul> </li> </ul>"},{"location":"changelog/#120","title":"1.2.0","text":"<ul> <li>Core-library and tasks:<ul> <li>Switch all core models to Pydantic V2 (#793).</li> </ul> </li> <li>JSON Schema generation tools:<ul> <li>Move JSON-Schema tools to Pydantic V2 (#793).</li> </ul> </li> <li>Testing:<ul> <li>Remove dependency on <code>pytest-pretty</code> (#793).</li> <li>Update <code>manifest_external_packages.yml</code> GitHub Action so that it installs the current <code>fractal-tasks-core</code> (#793).</li> </ul> </li> </ul>"},{"location":"changelog/#111","title":"1.1.1","text":"<ul> <li>Tasks:<ul> <li>Fix issue with masked ROI &amp; relabeling in Cellpose task (#786).</li> <li>Fix issue with masking ROI label types in <code>masked_loading_wrapper</code> for Cellpose task (#786).</li> <li>Enable workaround to support yx images in Cellpose task (#789).</li> <li>Fix error handling in <code>calculate_registration_image_based</code> (#799).</li> <li>Fix minor issues with call-signature and type hints in <code>calculate_registration_image_based</code> (#799).</li> </ul> </li> </ul>"},{"location":"changelog/#110","title":"1.1.0","text":"<p>NOTE: Starting from this release, <code>fractal-tasks-core</code> can coexist with Pydantic V2 but it still uses pydantic v1 under the hood for the time being. When working with Pydantic V1, the required version is <code>&gt;=1.10.16</code>.</p> <ul> <li>Tasks:<ul> <li>Refactor Cellpose Task inputs: Combine Channel inputs &amp; channel normalization parameters (#738).</li> <li>Refactor Cellpose Task inputs: Group advanced Cellpose parameters into the <code>CellposeModelParams</code> model that's provided via <code>advanced_cellpose_model_params</code> (#738).</li> <li>Refactor Cellpose Task inputs: Support independent normalization of 2 input channels in the Cellpose task (#738).</li> <li>Rename <code>task.cellpose_transforms</code> into <code>tasks.cellpose_utils</code> (#738).</li> <li>Fix wrong repeated overlap checks for bounding-boxes in Cellpose task (#778).</li> <li>Fix minor MIP issues related to plate metadata and expecting acquisition metadata in all NGFF plates (#781).</li> <li>Add <code>chi2_shift</code> option to Calculate Registration (image-based) task (#741).</li> </ul> </li> <li>Development:<ul> <li>Switch to transitional pydantic.v1 imports, changes pydantic requirement to <code>==1.10.16</code> or <code>&gt;=2.6.3</code> (#760).</li> <li>Support JSON-Schema generation for <code>Enum</code> task arguments (#749).</li> <li>Make JSON-Schema generation tools more flexible, to simplify testing (#749).</li> </ul> </li> <li>Documentation:<ul> <li>Update documentation (#751).</li> <li>Improve/extend page showing tasks from other packages (#759, #777).</li> </ul> </li> <li>JSON Schema generation:<ul> <li>Test manifest creation for three other tasks packages (#763).</li> </ul> </li> <li>NGFF subpackage<ul> <li>Fix Plate model to correspond better to 0.4.0 NGFF spec: Now makes acquisition metadata optional (#781).</li> </ul> </li> <li>Dependencies:<ul> <li>Add <code>image_registration</code> within <code>fractal-tasks</code> extra (#741).</li> </ul> </li> </ul>"},{"location":"changelog/#102","title":"1.0.2","text":"<ul> <li>Fix bug in plate metadata in MIP task (in the <code>copy_ome_zarr_hcs_plate</code> init function) (#736).</li> </ul>"},{"location":"changelog/#101","title":"1.0.1","text":"<ul> <li>Add support for converting 1536 well plates in cellvoyager converters (#715).</li> <li>Testing:<ul> <li>Make validation of NGFF Zarr attributes more strict, in tests (#732).</li> </ul> </li> <li>Development:<ul> <li>Update poetry to 1.8.2 (#734).</li> </ul> </li> </ul>"},{"location":"changelog/#100","title":"1.0.0","text":"<ul> <li>Update all tasks to use the new Fractal API from Fractal server 2.0 (#671)</li> <li>Provide new dev tooling to create Fractal manifest for new task API (#671)</li> <li>Add Pydantic models for OME-NGFF HCS Plate validation (#671)</li> <li>Breaking changes in core library:<ul> <li>In <code>get_acquisition_paths</code> helper function of <code>NgffWellMeta</code>:     The dictionary now contains a list of paths as values, not single paths.     The NotImplementedError for multiple images with the same acquisition was removed.</li> <li>The <code>utils.get_table_path_dict</code> helper function was made private &amp; changed its input parameters:     It's now <code>_get_table_path_dict(zarr_url: str)</code></li> </ul> </li> <li>Breaking changes in task sub-package:<ul> <li>Rename tasks for increase clarity (#671 &amp; #706).</li> <li>Changed registration tasks flow: Now 2 Compound tasks, 1 Parallel task (#671).</li> <li>Changed parameter names in registration tasks: acquisition instead of cycle (#719).</li> <li>Changed parameter names &amp; defaults in illumination correction task: (#671).<ul> <li>Now uses <code>illumination_profiles</code> instead of <code>dict_corr</code>.</li> <li>Changes default of background subtraction from 110 to 0.</li> </ul> </li> </ul> </li> <li>Dependencies:<ul> <li>Add <code>filelock</code> (#718).</li> </ul> </li> </ul>"},{"location":"changelog/#0143","title":"0.14.3","text":"<ul> <li>Make Cellpose task work for non HCS plate OME-Zarr images (#659)</li> <li>Add option to Illumination Correction to specify the ROI table name (#665)</li> </ul>"},{"location":"changelog/#0142","title":"0.14.2","text":"<ul> <li>Add custom normalization options to the Cellpose task (#650)</li> <li>Add more options to the Cellpose task to control model behavior (#650)</li> <li>For Cellpose task, switch to using Enums for <code>model_type</code> (see issue #401)</li> </ul>"},{"location":"changelog/#0141","title":"0.14.1","text":"<ul> <li>Fix bug in <code>cellpose_segmentation</code> upon using masked loading and setting <code>channel2</code> (#639). Thanks @FranziskaMoos-FMI and @enricotagliavini.</li> <li>Improve handling of potential race condition in \"Apply Registration to image\" task (#638).</li> </ul>"},{"location":"changelog/#0140","title":"0.14.0","text":"<ul> <li>Breaking changes in tasks:<ul> <li>Make <code>NapariWorkflowsOutput.label_name</code> attribute required, and use it to fill the <code>region[\"path\"]</code> table attribute (#613).</li> </ul> </li> <li>Breaking changes in core library:<ul> <li>\u26a0\ufe0f Refactor the whole package structure, leading to breaking changes for most imports (#613); more details at this page.</li> <li>In <code>prepare_label_group</code> helper function:<ul> <li>Make <code>label_attrs</code> function argument required (#613).</li> <li>Validate <code>label_attrs</code> with <code>NgffImageMeta</code> model (#613).</li> <li>Override multiscale name in <code>label_attrs</code> with <code>label_name</code> (#613).</li> </ul> </li> <li>In <code>write_table</code> helper function:<ul> <li>Drop <code>logger</code> function argument (#613).</li> <li>Add <code>table_name</code> function argument, taking priority over <code>table_attrs</code> (#613).</li> <li>Raise an error if no table type is not provided (#613).</li> <li>Raise an error if table attributes do not comply with table specs (#613).</li> </ul> </li> </ul> </li> <li>Other internal changes:<ul> <li>Comply with table specs V1, by writing all required Zarr attributes (#613).</li> <li>Remove <code>has_args_schema</code> obsolete property from manifest (#603).</li> <li>Handle <code>GroupNotFoundError</code> in <code>load_NgffImageMeta</code> and <code>load_NgffWellMeta</code> (#622).</li> </ul> </li> <li>Bug fixes:<ul> <li>Fix table selection in calculate registration image-based (#615).</li> </ul> </li> <li>Documentation<ul> <li>Clarify table specs V1 (#613).</li> </ul> </li> <li>Testing:<ul> <li>Use more recent Zenodo datasets, created with <code>fractal-tasks-core&gt;=0.12</code> (#623).</li> <li>Use poetry 1.7.1 in GitHub actions (#620).</li> <li>Align with new Zenodo API (#601).</li> <li>Update <code>test_valid_manifest</code> (#606).</li> <li>Use pooch to download test files (#610).</li> </ul> </li> <li>Documentation:<ul> <li>Add list of tasks (#625).</li> </ul> </li> <li>Dependencies:<ul> <li>Remove Pillow <code>&lt;10.1.0</code> constraint (#626).</li> </ul> </li> </ul>"},{"location":"changelog/#0131","title":"0.13.1","text":"<ul> <li>Always use <code>write_table</code> in tasks, rather than AnnData <code>write_elem</code> (#581).</li> <li>Remove assumptions on ROI-table columns from <code>get_ROI_table_with_translation</code> helper function of <code>calculate_registration_image_based</code> task (#591).</li> <li>Testing:<ul> <li>Cache Zenodo data, within GitHub actions (#585).</li> </ul> </li> <li>Documentation:<ul> <li>Define V1 of table specs (#582).</li> <li>Add mathjax support (#582).</li> <li>Add cross-reference inventories to external APIs (#582).</li> </ul> </li> </ul>"},{"location":"changelog/#0130","title":"0.13.0","text":"<ul> <li>Tasks:<ul> <li>New task and helper functions:<ul> <li>Introduce <code>import_ome_zarr</code> task (#557, #579).</li> <li>Introduce <code>get_single_image_ROI</code> and <code>get_image_grid_ROIs</code> (#557).</li> <li>Introduce <code>detect_ome_ngff_type</code> (#557).</li> <li>Introduce <code>update_omero_channels</code> (#579).</li> </ul> </li> <li>Make <code>maximum_intensity_projection</code> independent from ROI tables (#557).</li> <li>Make Cellpose task work when <code>input_ROI_table</code> is empty (#566).</li> <li>Fix bug of missing attributes in ROI-table Zarr group (#573).</li> </ul> </li> <li>Dependencies:<ul> <li>Restrict <code>Pillow</code> version to <code>&lt;10.1</code> (#571).</li> <li>Support AnnData <code>0.10</code> (#574).</li> </ul> </li> <li>Testing:<ul> <li>Align with new Zenodo API (#568).</li> <li>Use ubuntu-22 for GitHub CI (#576).</li> </ul> </li> </ul>"},{"location":"changelog/#0122","title":"0.12.2","text":"<ul> <li>Relax <code>check_valid_ROI_indices</code> to support search-first scenario (#555).</li> <li>Do not install <code>docs</code> dependencies in GitHub CI (#551).</li> </ul>"},{"location":"changelog/#0121","title":"0.12.1","text":"<ul> <li>Make <code>Channel.window</code> attribute optional in <code>lib_ngff.py</code> (#548).</li> <li>Automate procedure for publishing package to PyPI (#545).</li> </ul>"},{"location":"changelog/#0120","title":"0.12.0","text":"<p>This release includes work on Pydantic models for NGFF specs and on ROI tables.</p> <ul> <li>NGFF Pydantic models:<ul> <li>Introduce Pydantic models for NGFF metadata in <code>lib_ngff.py</code> (#528).</li> <li>Extract <code>num_levels</code> and <code>coarsening_xy</code> parameters from NGFF objects, rather than from <code>metadata</code> task input (#528).</li> <li>Transform several <code>lib_zattrs_utils.py</code> functions (<code>get_axes_names</code>, <code>extract_zyx_pixel_sizes</code> and <code>get_acquisition_paths</code>) into <code>lib_ngff.py</code> methods (#528).</li> <li>Load Zarr attributes from groups, rather than from <code>.zattrs</code> files (#528).</li> </ul> </li> <li>Regions of interest:<ul> <li>Set <code>FOV_ROI_table</code> and <code>well_ROI_table</code> ZYX origin to zero (#524).</li> <li>Remove heuristics to determine whether to reset origin, in <code>cellpose_segmentation</code> task (#524).</li> <li>Remove obsolete <code>reset_origin</code> argument from <code>convert_ROI_table_to_indices</code> function (#524).</li> <li>Remove redundant <code>reset_origin</code> call from <code>apply_registration_to_ROI_tables</code> task (#524).</li> <li>Add check on non-negative ROI indices (#534).</li> <li>Add check on ROI indices not starting at <code>(0,0,0)</code>, to highlight v0.12/v0.11 incompatibility (#534).</li> <li>Fix bug in creation of bounding-box ROIs when <code>cellpose_segmentation</code> loops of FOVs (#524).</li> <li>Update type of <code>metadata</code> parameter of <code>prepare_FOV_ROI_table</code> and <code>prepare_well_ROI_table</code> functions (#524).</li> <li>Fix <code>reset_origin</code> so that it returns an updated copy of its input (#524).</li> </ul> </li> <li>Dependencies:<ul> <li>Relax <code>fsspec&lt;=2023.6</code> constraint into <code>fsspec!=2023.9.0</code> (#539).</li> </ul> </li> </ul>"},{"location":"changelog/#0110","title":"0.11.0","text":"<ul> <li>Tasks:<ul> <li>(major) Introduce new tasks for registration of multiplexing cycles: <code>calculate_registration_image_based</code>, <code>apply_registration_to_ROI_tables</code>, <code>apply_registration_to_image</code> (#487).</li> <li>(major) Introduce new <code>overwrite</code> argument for tasks <code>create_ome_zarr</code>, <code>create_ome_zarr_multiplex</code>, <code>yokogawa_to_ome_zarr</code>, <code>copy_ome_zarr</code>, <code>maximum_intensity_projection</code>, <code>cellpose_segmentation</code>, <code>napari_workflows_wrapper</code> (#499).</li> <li>(major) Rename <code>illumination_correction</code> parameter from <code>overwrite</code> to <code>overwrite_input</code> (#499).</li> <li>Fix plate-selection bug in <code>copy_ome_zarr</code> task (#513).</li> <li>Fix bug in definition of <code>metadata[\"plate\"]</code> in <code>create_ome_zarr_multiplex</code> task (#513).</li> <li>Introduce new helper functions <code>write_table</code>, <code>prepare_label_group</code> and <code>open_zarr_group_with_overwrite</code> (#499).</li> <li>Introduce new helper functions <code>are_ROI_table_columns_valid</code>, <code>convert_indices_to_regions</code>, <code>reset_origin</code>, <code>is_standard_roi_table</code>, <code>get_acquisition_paths</code>, <code>get_table_path_dict</code>, <code>get_axes_names</code>, <code>add_zero_translation_columns</code>, <code>calculate_min_max_across_dfs</code>, <code>apply_registration_to_single_ROI_table</code>, <code>write_registered_zarr</code>, <code>calculate_physical_shifts</code>, <code>get_ROI_table_with_translation</code> (#487).</li> </ul> </li> <li>Testing:<ul> <li>Add tests for <code>overwrite</code>-related task behaviors (#499).</li> <li>Introduce mock-up of <code>napari_skimage_regionprops</code> package, for testing of   <code>napari_workflows_wrapper</code> task (#499).</li> </ul> </li> <li>Dependencies:<ul> <li>Require <code>fsspec</code> version to be <code>&lt;=2023.6</code> (#509).</li> </ul> </li> </ul>"},{"location":"changelog/#0101","title":"0.10.1","text":"<ul> <li>Tasks:<ul> <li>Improve validation for <code>OmeroChannel.color</code> field (#488).</li> <li>Include <code>image-label/source/image</code> OME-NGFF attribute when creating labels (#478).</li> <li>Update default values for tolerance (<code>tol</code>) in <code>lib_ROI_overlaps.py</code> functions (#466).</li> </ul> </li> <li>Development tools:<ul> <li>Include <code>docs_info</code> and <code>docs_link</code> attributes in manifest tasks (#486).</li> <li>Rename and revamp scripts to update/check the manifest (#486).</li> <li>Improve logging and error-handling in tools for args-schema creation (#469).</li> </ul> </li> <li>Documentation:<ul> <li>Convert docstrings to Google style (#473, #479).</li> <li>Switch from sphinx to mkdocs for documentation (#479).</li> <li>Update generic type hints (#462, #479).</li> <li>Align examples to recent package version, and mention them in the documentation (#470).</li> </ul> </li> <li>Testing:<ul> <li>Improve coverage of core library (#459, #467, #468).</li> <li>Update Zenodo datasets used in tests (#454).</li> <li>Run tests both for the poetry-installed and pip-installed package (#455).</li> </ul> </li> <li>Dependencies:<ul> <li>Relax <code>numpy</code> required version to <code>&lt;2</code> (#477).</li> <li>Relax <code>dask</code> required version to <code>&gt;=2023.1.0</code> (#455).</li> <li>Relax <code>zarr</code> required version to <code>&gt;=2.13.6,&lt;3</code> (#455).</li> <li>Relax <code>pandas</code> required version to <code>&gt;=1.2.0,&lt;2</code> (#455).</li> <li>Relax <code>Pillow</code> required version to <code>&gt;=9.1.1,&lt;10.0.0</code> (#455).</li> <li>Full update of <code>poetry.lock</code> file (mutiple PRs, e.g. #472).</li> <li>Include <code>requests</code> and <code>wget</code> in the <code>dev</code> poetry dependency group (#455).</li> </ul> </li> </ul>"},{"location":"changelog/#0100","title":"0.10.0","text":"<ul> <li>Restructure the package and repository:<ul> <li>Move tasks to <code>tasks</code> subpackage (#390)</li> <li>Create new <code>dev</code> subpackage (#384).</li> <li>Make tasks-related dependencies optional, and installable via <code>fractal-tasks</code> extra (#390).</li> <li>Remove <code>tools</code> package extra (#384), and split the subpackage content into <code>lib_ROI_overlaps</code> and <code>examples</code> (#390).</li> </ul> </li> <li>(major) Modify task arguments<ul> <li>Add Pydantic model <code>lib_channels.OmeroChannel</code> (#410, #422);</li> <li>Add Pydantic model <code>tasks._input_models.Channel</code> (#422);</li> <li>Add Pydantic model <code>tasks._input_models.NapariWorkflowsInput</code> (#422);</li> <li>Add Pydantic model <code>tasks._input_models.NapariWorkflowsOutput</code> (#422);</li> <li>Move all Pydantic models to main package (#438).</li> <li>Modify arguments of <code>illumination_correction</code> task (#431);</li> <li>Modify arguments of <code>create_ome_zarr</code> and <code>create_ome_zarr_multiplex</code> (#433).</li> <li>Modify argument default for <code>ROI_table_names</code>, in <code>copy_ome_zarr</code> (#449).</li> <li>Remove the delete option from yokogawa to ome zarr (#443).</li> <li>Reorder task inputs (#451).</li> </ul> </li> <li>JSON Schemas for task arguments:<ul> <li>Add JSON Schemas for task arguments in the package manifest (#369, #384).</li> <li>Add JSON Schemas for attributes of custom task-argument Pydantic models (#436).</li> <li>Make schema-generation tools more general, when handling custom Pydantic models (#445).</li> <li>Include titles for custom-model-typed arguments and argument attributes (#447).</li> <li>Remove <code>TaskArguments</code> models and switch to Pydantic V1 <code>validate_arguments</code> (#369).</li> <li>Make coercing&amp;validating task arguments required, rather than optional (#408).</li> <li>Remove <code>default_args</code> from manifest (#379, #393).</li> </ul> </li> <li>Other:<ul> <li>Make pydantic dependency required for running tasks, and pin it to V1 (#408).</li> <li>Remove legacy executor definitions from manifest (#361).</li> <li>Add GitHub action for testing <code>pip install</code> with/without <code>fractal-tasks</code> extra (#390).</li> <li>Remove <code>sqlmodel</code> from dev dependencies (#374).</li> <li>Relax constraint on torch version, from <code>==1.12.1</code> to <code>&lt;=2.0.0</code> (#406).</li> <li>Review task docstrings and improve documentation (#413, #416).</li> <li>Update <code>anndata</code> dependency requirements (from <code>^0.8.0</code> to <code>&gt;=0.8.0,&lt;=0.9.1</code>), and replace <code>anndata.experimental.write_elem</code> with <code>anndata._io.specs.write_elem</code> (#428).</li> </ul> </li> </ul>"},{"location":"changelog/#094","title":"0.9.4","text":"<ul> <li>Relax constraint on <code>scikit-image</code> version, by only requiring a version <code>&gt;=0.19</code> (#367).</li> </ul>"},{"location":"changelog/#093","title":"0.9.3","text":"<ul> <li>For labeling tasks (<code>cellpose_segmentation</code> or <code>napari_worfklows_wrapper</code>), allow empty ROI tables as input or output (#365).</li> <li>Relax constraint related to the presence of channels in <code>create_zarr_structure_multiplex</code> task (#365).</li> </ul>"},{"location":"changelog/#092","title":"0.9.2","text":"<ul> <li>Increase memory requirements for some tasks in manifest (#363).</li> </ul>"},{"location":"changelog/#091","title":"0.9.1","text":"<ul> <li>Add <code>use_gpu</code> argument for <code>cellpose_segmentation</code> task (#350).</li> <li>Add dummy return object to napari-workflows task (#359).</li> <li>Include memory/cpu/gpu requirements in manifest, in view of new fractal-server SLURM backend (#360).</li> </ul>"},{"location":"changelog/#090","title":"0.9.0","text":"<ul> <li>Introduce a module for masked loading of ROIs, and update the <code>cellpose_segmentation</code> task accordingly (#306).</li> <li>Rename task arguments: <code>ROI_table_name-&gt;input_ROI_table</code> and <code>bounding_box_ROI_table_name-&gt;output_ROI_table</code> (#306).</li> <li>Implement part of the proposed table support in OME-NGFF specs, both for the <code>tables</code> zarr group and then for each table subgroup (#306).</li> <li>Rename module: <code>lib_remove_FOV_overlaps.py-&gt;lib_ROI_overlaps.py</code> (#306).</li> <li>Add new functions to existing modules: <code>lib_regions_of_interest.convert_region_to_low_res</code>, <code>lib_ROI_overlaps.find_overlaps_in_ROI_indices</code> (#306).</li> </ul>"},{"location":"changelog/#081","title":"0.8.1","text":"<ul> <li>Disable bugged validation of <code>model_type</code> argument in <code>cellpose_segmentation</code> (#344).</li> <li>Raise an error if the user provides an unexpected argument to a task (#337); this applies to the case of running a task as a script, with a pydantic model for task-argument validation.</li> </ul>"},{"location":"changelog/#080","title":"0.8.0","text":"<ul> <li>(major) Update task interface: remove filename extension from <code>input_paths</code> and <code>output_path</code> for all tasks, and add new arguments <code>(image_extension,image_glob_pattern)</code> to <code>create_ome_zarr</code> task (#323).</li> <li>Implement logic for handling <code>image_glob_patterns</code> argument, both when globbing images and in Yokogawa metadata parsing (#326).</li> <li>Fix minor bugs in task arguments (#329).</li> </ul>"},{"location":"changelog/#075","title":"0.7.5","text":"<ul> <li>Update <code>cellpose_segmentation</code> defaults and parse additional parameters (#316).</li> <li>Add dual-channel input for <code>cellpose_segmentation</code> task (#315).</li> </ul>"},{"location":"changelog/#074","title":"0.7.4","text":"<ul> <li>Add tests for python 3.10 (#309).</li> <li>Drop support for python 3.8 (#319).</li> <li>Update task interface: use string arguments instead of <code>pathlib.Path</code>, and only set defaults in function call signatures (#303).</li> </ul>"},{"location":"changelog/#073","title":"0.7.3","text":"<ul> <li>Add <code>reset_origin</code> argument to <code>convert_ROI_table_to_indices</code> (#305).</li> <li>Do not overwrite existing labels in <code>cellpose_segmentation</code> task (#308).</li> </ul>"},{"location":"changelog/#072","title":"0.7.2","text":"<ul> <li>Remove pyqt5-related dependencies (#288).</li> </ul>"},{"location":"changelog/#071","title":"0.7.1","text":"<p>Missing</p>"},{"location":"changelog/#070","title":"0.7.0","text":"<ul> <li>Replace <code>dask.array.core.get_mapper()</code> with <code>zarr.storage.FSStore()</code> (#282).</li> <li>Pin dask version to &gt;=2023.1.0, &lt;2023.2.</li> <li>Pin zarr version to &gt;=2.13.6, &lt;2.14.</li> <li>Pin numpy version to &gt;=1.23.5,&lt;1.24.</li> <li>Pin cellpose version to &gt;=2.2,&lt;2.3.</li> </ul>"},{"location":"changelog/#065","title":"0.6.5","text":"<ul> <li>Remove FOV overlaps with more flexibility (#265).</li> </ul>"},{"location":"changelog/#064","title":"0.6.4","text":"<ul> <li>Created <code>tools</code> submodule and installation extra (#262).</li> </ul>"},{"location":"changelog/#063","title":"0.6.3","text":"<ul> <li>Added napari dependency, pinned to 0.4.16 version.</li> <li>Fixed type-hinting bug in task to create multiplexing OME-Zarr structure (#258).</li> </ul>"},{"location":"changelog/#062","title":"0.6.2","text":"<ul> <li>Support passing a pre-made metadata table to tasks creating the OME-Zarr structure (#252).</li> </ul>"},{"location":"changelog/#061","title":"0.6.1","text":"<ul> <li>Add option for padding an array with zeros in <code>upscale_array</code> (#251).</li> <li>Simplified <code>imagecodecs</code> and <code>PyQt5</code> dependencies (#248).</li> </ul>"},{"location":"changelog/#060","title":"0.6.0","text":"<ul> <li>(major) Refactor of how to address channels (#239).</li> <li>Fix bug in well ROI table (#245).</li> </ul>"},{"location":"changelog/#051","title":"0.5.1","text":"<ul> <li>Fix sorting of image files when number of Z planes passes 100 (#237).</li> </ul>"},{"location":"changelog/#050","title":"0.5.0","text":"<ul> <li>(major) Deprecate <code>measurement</code> task (#235).</li> <li>(major) Use more uniform names for tasks, both in python modules and manifest (#235).</li> <li>Remove deprecated manifest from <code>__init__.py</code> (#233).</li> </ul>"},{"location":"changelog/#046","title":"0.4.6","text":"<ul> <li>Skip image files if filename is not parsable (#219).</li> <li>Preserve order of <code>input_paths</code> for multiplexing subfolders (#222).</li> <li>Major refactor of <code>replicate_zarr_structure</code>, also enabling support for zarr files with multiple images (#223).</li> </ul>"},{"location":"changelog/#045","title":"0.4.5","text":"<ul> <li>Replace <code>Cellpose</code> wrapper with <code>CellposeModel</code>, to support <code>pretrained_model</code> argument (#218).</li> <li>Update cellpose version (it was pinned to 2.0, in previous versions) (#218).</li> <li>Pin <code>torch</code> dependency to version 1.12.1, to support CUDA version 10.2 (#218).</li> </ul>"},{"location":"changelog/#044","title":"0.4.4","text":"<p>Missing due to releasing error.</p>"},{"location":"changelog/#043","title":"0.4.3","text":"<ul> <li>In <code>create_zarr_structure_multiplex</code>, always use/require strings for <code>acquisition</code> field (#217).</li> </ul>"},{"location":"changelog/#042","title":"0.4.2","text":"<ul> <li>Bugfixes</li> </ul>"},{"location":"changelog/#041","title":"0.4.1","text":"<ul> <li>Only use strings as keys of <code>channel_parameters</code> (in <code>create_zarr_structure_multiplex</code>).</li> </ul>"},{"location":"changelog/#040","title":"0.4.0","text":"<ul> <li>(major) Rename <code>well</code> to <code>image</code> (both in metadata list and in manifest) and add an actual <code>well</code> field (#210).</li> <li>Add <code>create_ome_zarr_multiplexing</code>, and adapt <code>yokogawa_to_zarr</code> (#210).</li> <li>Relax constraint about outputs in <code>napari_worfklows_wrapper</code> (#209).</li> </ul>"},{"location":"changelog/#034","title":"0.3.4","text":"<ul> <li>Always log START/END times for each task (#204).</li> <li>Add <code>label_name</code> argument to <code>cellpose_segmentation</code> (#207).</li> <li>Add <code>pretrained_model</code> argument to <code>cellpose_segmentation</code> (#207).</li> </ul>"},{"location":"changelog/#033","title":"0.3.3","text":"<ul> <li>Added <code>napari_worfklows_wrapper</code> to manifest.</li> </ul>"},{"location":"changelog/#032","title":"0.3.2","text":"<ul> <li>Compute bounding boxes of labels, in <code>cellpose_segmentation</code> (#192).</li> <li>Parse image filenames in a more robust way (#191).</li> <li>Update manifest, moving <code>parallelization_level</code> and <code>executor</code> to <code>meta</code> attribute.</li> </ul>"},{"location":"changelog/#031","title":"0.3.1","text":"<ul> <li>Fix <code>executable</code> fields in manifest.</li> <li>Remove <code>graphviz</code> dependency.</li> </ul>"},{"location":"changelog/#030","title":"0.3.0","text":"<ul> <li>Conform to Fractal v1, through new task manifest (#162) and standard input/output interface (#155, #157).</li> <li>Add several type hints (#148) and validate them in the standard task interface (#175).</li> <li>Update <code>napari_worfklows_wrapper</code>: pyramid level for labeling worfklows (#148), label-only inputs (#163, #171), relabeling (#167), 2D/3D handling (#166).</li> <li>Deprecate <code>dummy</code> and <code>dummy_fail</code> tasks.</li> </ul>"},{"location":"changelog/#026","title":"0.2.6","text":"<ul> <li>Setup sphinx docs, to be built and hosted on https://fractal-tasks-core.readthedocs.io; include some preliminary updates of docstrings (#143).</li> <li>Dependency cleanup via deptry (#144).</li> </ul>"},{"location":"changelog/#025","title":"0.2.5","text":"<ul> <li>Add <code>napari_workflows_wrapper</code> task (#141).</li> <li>Add <code>lib_upscale_array.py</code> module (#141).</li> </ul>"},{"location":"changelog/#024","title":"0.2.4","text":"<ul> <li>Major updates to <code>metadata_parsing.py</code> (#136).</li> </ul>"},{"location":"custom_task/","title":"How to write a Fractal-compatible custom task","text":"<p>The <code>fractal-tasks-core</code> repository is the reference implementation for Fractal tasks and for Fractal task packages, but the Fractal platform can also be used to execute custom tasks.</p> <p>For the most recent versions of Fractal (namely <code>fractal-server</code> v2 and <code>fractal-tasks-core</code> v1), the instructions for building your own tasks are available at https://fractal-analytics-platform.github.io/build_your_own_fractal_task.</p> <p>As a reference, here is a copy of the legacy instructions for older Fractal versions, which are currently obsolete.</p>"},{"location":"custom_tasks_old/","title":"\u26a0\ufe0f OBSOLETE: How to write a Fractal-compatible custom task","text":"<p>\u26a0\ufe0f\u26a0\ufe0f These instructions are here just as a reference, but they refer to legacy versions of <code>fractal-server</code>. While the overall structure of the instructions is still valid, several details are now obsolete and won't work. \u26a0\ufe0f\u26a0\ufe0f</p> <p>The <code>fractal-tasks-core</code> repository is the reference implementation for Fractal tasks and for Fractal task packages, but the Fractal platform can also be used to execute custom tasks.</p> <p>This page lists the Fractal-compatibility requirements, for a single custom task or for a task package.</p> <p>Note that these specifications evolve frequently, see e.g. discussion at https://github.com/fractal-analytics-platform/fractal-tasks-core/issues/151.</p> <p>Note: While the contents of this page remain valid, the recommended procedure to get up to speed and build a Python package of Fractal-compatible tasks is to use the template available at https://github.com/fractal-analytics-platform/fractal-tasks-template.</p> <p>A Fractal task is mainly formed by two components:</p> <ol> <li>A set of metadata, which are stored in the <code>task</code> table of the database of a    <code>fractal-server</code> instance, see Task metadata.</li> <li>An executable command, which can take some specific command-line arguments    (see Command-line interface); the standard    example is a Python script.</li> </ol> <p>In the following we explain what are the Fractal-compatibility requirements for a single task, and then for a task package.</p>"},{"location":"custom_tasks_old/#single-custom-task","title":"Single custom task","text":"<p>We describe how to define the multiple aspects of a task, and provide a Full task example.</p>"},{"location":"custom_tasks_old/#task-metadata","title":"Task metadata","text":"<p>Each task must be associated to some metadata, so that it can be used in Fractal. The full specification is here, and the required attributes are:</p> <ul> <li><code>name</code>: the task name, e.g. <code>\"Create OME-Zarr structure\"</code>;</li> <li><code>command</code>: a command that can be executed from the command line;</li> <li><code>input_type</code>: this can be any string (typical examples: <code>\"image\"</code> or <code>\"zarr\"</code>);   the special value <code>\"Any\"</code> means that Fractal won't perform any check of the   <code>input_type</code> when applying the task to a dataset.</li> <li><code>output_type</code>: same logic as <code>input_type</code>.</li> <li><code>source</code>: this is meant to be as close as possible to unique task identifier;   for custom tasks, it can be anything (e.g. <code>\"my_task\"</code>), but for task that   are collected automatically from a package (see Task package this    attribute will have a very specific form (e.g.    <code>\"pip_remote:fractal_tasks_core:0.10.0:fractal-tasks::convert_yokogawa_to_ome-zarr\"</code>).</li> <li><code>meta</code>: a JSON object (similar to a Python dictionary) with some additional   information, see Task meta-parameters.</li> </ul> <p>There are multiple ways to get the appropriate metadata into the database, including a POST request to the <code>fractal-server</code> API (see <code>Tasks</code> section in the <code>fractal-server</code> API documentation) or the automated addition of a whole set of tasks through specific API endpoints (see Task package).</p>"},{"location":"custom_tasks_old/#command-line-interface","title":"Command-line interface","text":"<p>Some examples of task commands may look like</p> <ul> <li><code>python3 /some/path/my_task.py</code>,</li> <li><code>/some/absolute/path/python3.11 /some/other/absolute/path/my_task.py</code>,</li> <li><code>/some/path/my_executable_task.py</code>,</li> <li>any other executable command (not necessarily based on Python).</li> </ul> <p>Given a task command, Fractal will add two additional command-line arguments to it:</p> <ul> <li><code>-j /some/path/input-arguments.json</code></li> <li><code>--metadata-out /some/path/output-metadata-update.json</code></li> </ul> <p>Therefore the task command must accept these additional command-line arguments. If the task is a Python script, this can be achieved easily by using the <code>run_fractal_task</code> function - which is available as part of <code>fractal_tasks_core.tasks._utils</code>.</p>"},{"location":"custom_tasks_old/#task-meta-parameters","title":"Task meta-parameters","text":"<p>The <code>meta</code> attribute of tasks (see the corresponding item in Task metadata) is where we specify some requirements on how the task should be run. This notably includes:</p> <ul> <li>If the task has to be run in parallel (e.g. over multiple wells of an   OME-Zarr dataset), then <code>meta</code> should include a key-value pair like   <code>{\"parallelization_level\": \"well\"}</code>. If the <code>parallelization_level</code> key is   missing, the task is considered as non-parallel.</li> <li>If Fractal is configured to run on a SLURM cluster, <code>meta</code> may include   additional information on the SLRUM requirements (more info on the Fractal   SLURM backend   here).</li> </ul>"},{"location":"custom_tasks_old/#task-input-parameters","title":"Task input parameters","text":"<p>When a task is run via Fractal, its input parameters (i.e. the ones in the file specified via the <code>-j</code> command-line otion) will always include a set of keyword arguments with specific names:</p> <ul> <li><code>input_paths</code></li> <li><code>output_path</code></li> <li><code>metadata</code></li> <li><code>component</code> (only for parallel tasks)</li> </ul>"},{"location":"custom_tasks_old/#task-output","title":"Task output","text":"<p>The only task output which will be visible to Fractal is what goes in the output metadata-update file (i.e. the one specified through the <code>--metadata-out</code> command-line option). Note that this only holds for non-parallel tasks, while (for the moment) Fractal fully ignores the output of parallel tasks.</p> <p>IMPORTANT: This means that each task must always write any output to disk, before ending.</p>"},{"location":"custom_tasks_old/#advanced-features","title":"Advanced features","text":"<p>The description of other advanced features is not yet available in this page.</p> <ol> <li>Also other attributes of the Task metadata exist, and they    would be recognized by other Fractal components (e.g.  <code>fractal-server</code> or    <code>fractal-web</code>). These include JSON Schemas for input parameters and additional    documentation-related attributes.</li> <li>In <code>fractal-tasks-core</code>, we use <code>pydantic    v1</code> to fully coerce and validate the input    parameters into a set of given types.</li> </ol>"},{"location":"custom_tasks_old/#full-task-example","title":"Full task example","text":"<p>Here we describe a simplified example of a Fractal-compatible Python task (for more realistic examples see the <code>fractal-task-core</code> tasks folder).</p> <p>The script <code>/some/path/my_task.py</code> may look like <pre><code># Import a helper function from fractal_tasks_core\nfrom fractal_tasks_core.tasks._utils import run_fractal_task\n\ndef my_task_function(\n    # Reserved Fractal arguments\n    input_paths,\n    output_path,\n    metadata,\n    # Task-specific arguments\n    argument_A,\n    argument_B = \"default_B_value\",\n):\n    # Do something, based on the task parameters\n    print(\"Here we go, we are in `my_task_function`\")\n    with open(f\"{output_path}/output.txt\", \"w\") as f:\n        f.write(f\"argument_A={argument_A}\\n\")\n        f.write(f\"argument_B={argument_B}\\n\")\n    # Compile the output metadata update and return\n    output_metadata_update = {\"nothing\": \"to add\"}\n    return output_metadata_update\n\n# Thi block is executed when running the Python script directly\nif __name__ == \"__main__\":\n    run_fractal_task(task_function=my_task_function)\n</code></pre> where we use <code>run_fractal_task</code> so that we don't have to take care of the command-line arguments.</p> <p>Some valid metadata attributes for this task would be: <pre><code>name=\"My Task\"\ncommand=\"python3 /some/path/my_task.py\"\ninput_type=\"Any\"\noutput_type=\"Any\"\nsource=\"my_custom_task\"\nmeta={}\n</code></pre></p> <p>Note that this was an example of a non-parallel tasks; to have a parallel one, we would also need to:</p> <ol> <li>Set <code>meta={\"parallelization_level\": \"something\"}</code>;</li> <li>Include <code>component</code> in the input arguments of <code>my_task_function</code>.</li> </ol>"},{"location":"custom_tasks_old/#task-package","title":"Task package","text":"<p>Given a set of Python scripts corresponding to Fractal tasks, it is useful to combine them into a single Python package, using the standard tools or other options (e.g. for <code>fractal-tasks-core</code> we use poetry).</p>"},{"location":"custom_tasks_old/#reasons","title":"Reasons","text":"<p>Creating a package is often a good practice, for reasons unrelated to Fractal:</p> <ol> <li>It makes it simple to assign a global version to the package, and to host it    on a public index like PyPI;</li> <li>It may reduce code duplication:<ul> <li>The scripts may have a shared set of external dependencies, which are   defined in a single place for a package.</li> <li>The scripts may import functions from a shared set of auxiliary Python   modules, which can be included in the package.</li> </ul> </li> </ol> <p>Moreover, having a single package also streamlines some Fractal-related operations. Given the package <code>MyTasks</code> (available on PyPI, or locally), the Fractal platform offers a feature that automatically:</p> <ol> <li>Downloads the wheel file of package <code>MyTasks</code> (if it's on a public index,    rather than a local file);</li> <li>Creates a Python virtual environment (venv) which is specific for a given    version of the <code>MyTasks</code> package, and installs the <code>MyTasks</code> package in that    venv;</li> <li>Populates all the corresponding entries in the <code>task</code> database table with    the appropriate Task metadata, which are extracted from    the package manifest.</li> </ol> <p>This feature is currently exposed in the <code>/api/v1/task/collect/pip/</code> endpoint of <code>fractal-server</code> (see API documentation).</p>"},{"location":"custom_tasks_old/#requirements","title":"Requirements","text":"<p>To be compatible with Fractal, a task package must satisfy some additional requirements:</p> <ul> <li>The package is built as a a wheel file, and can be installed via <code>pip</code>.</li> <li>The <code>__FRACTAL_MANIFEST__.json</code> file is bundled in the package, in its root   folder. If you are using <code>poetry</code>, no special operation is needed. If you   are using a <code>setup.cfg</code> file, see   this   comment.</li> <li>Include JSON Schemas. The tools in <code>fractal_tasks_core.dev</code> are used to   generate JSON Schema's for the input parameters of each task in   <code>fractal-tasks-core</code>. They are meant to be flexible and re-usable to perform   the same operation on an independent package, but they are not thoroughly   documented/tested for more general use; feel free to open an issue if something   is not clear.</li> <li>Include additional task metadata like <code>docs_info</code> or <code>docs_link</code>, which will   be displayed in the Fractal web-client. Note: this feature is not yet   implemented.</li> </ul> <p>The ones in the list are the main requirements; if you hit unexpected behaviors, also have a look at https://github.com/fractal-analytics-platform/fractal-tasks-core/issues/151 or open a new issue.</p>"},{"location":"development/","title":"Development","text":""},{"location":"development/#setting-up-environment","title":"Setting up environment","text":"<p>We use poetry to manage both development environments and package building. A simple way to install it is <code>pipx install poetry==1.8.5</code>, or you can look at the installation section here.</p> <p>From the repository root folder, running any of <pre><code># Install the core library only\npoetry install\n\n# Install the core library and the tasks\npoetry install -E fractal-tasks\n\n# Install the core library and the development/documentation dependencies\npoetry install --with dev --with docs\n</code></pre> will take care of installing all the dependencies in a separate environment (handled by <code>poetry</code> itself), optionally installing also the dependencies for developement and to build the documentation.</p>"},{"location":"development/#testing","title":"Testing","text":"<p>We use pytest for unit and integration testing of Fractal. If you installed the development dependencies, you may run the test suite by invoking commands like: <pre><code># Run all tests\npoetry run pytest\n\n# Run all tests with a verbose mode, and stop at the first failure\npoetry run pytest -x -v\n\n# Run all tests and also print their output\npoetry run pytest -s\n\n# Ignore some tests folders\npoetry run pytest --ignore tests/tasks\n</code></pre></p> <p>The tests files are in the <code>tests</code> folder of the repository. Its structure reflects the <code>fractal_tasks_core</code> structure, with tests for the core library in the main folder and tests for <code>tasks</code> and <code>dev</code> subpckages in their own subfolders.</p> <p>Tests are also run through GitHub Actions, with Python 3.11 and 3.12. Note that within GitHub actions we run tests for both the <code>poetry</code>-installed and <code>pip</code>-installed versions of the code, which may e.g. have different versions of some dependencies (since <code>pip install</code> does not rely on the <code>poetry.lock</code> lockfile).</p>"},{"location":"development/#documentation","title":"Documentation","text":"<p>The documentations is built with mkdocs. To build the documentation locally, setup a development python environment (e.g. with <code>poetry install --with docs</code>) and then run one of these commands: <pre><code>poetry run mkdocs serve --config-file mkdocs.yml  # serves the docs at http://127.0.0.1:8000\npoetry run mkdocs build --config-file mkdocs.yml  # creates a build in the `site` folder\n</code></pre></p> <p>A dedicated GitHub action takes care of building the documentation and pushing it to https://fractal-analytics-platform.github.io/fractal-tasks-core, when commits are pushed to the <code>main</code> branch.</p>"},{"location":"development/#release-to-pypi","title":"Release to PyPI","text":""},{"location":"development/#preliminary-check-list","title":"Preliminary check-list","text":"<ol> <li>The <code>main</code> branch is checked out.</li> <li>All tests are passing, for the <code>main</code> branch.</li> <li><code>CHANGELOG.md</code> is up to date.</li> <li>If appropriate (e.g. if you added some new task arguments, or if you modified some of their descriptions), update the JSON Schemas in the manifest via: <pre><code>poetry run python fractal_tasks_core/dev/create_manifest.py\n</code></pre> (note that the CI will fail if you forgot to update the manifest,, but it is good to be aware of it)</li> </ol>"},{"location":"development/#actual-release","title":"Actual release","text":"<ol> <li>From within the <code>main</code> branch, use a command like: <pre><code># Automatic bump of release number\npoetry run bumpver update --[tag-num|patch|minor] --dry\n\n# Set a specific version\npoetry run bumpver update --set-version 1.2.3 --dry\n</code></pre> to test updating the version bump</li> <li>If the previous step looks good, remove the <code>--dry</code> and re-run the same command. This will commit both the edited files and the new tag, and push.</li> <li>Approve the new version deployment at Publish package to PyPI (or have it approved); the corresponding GitHub action will take care of running <code>poetry build</code> and <code>poetry publish</code> with the appropriate credentials.</li> </ol>"},{"location":"development/#static-type-checker","title":"Static type checker","text":"<p>We do not enforce strict <code>mypy</code> compliance, but we do run it as part of a specific GitHub Action. You can run <code>mypy</code> locally for instance as: <pre><code>poetry run mypy --package fractal_tasks_core --ignore-missing-imports --warn-redundant-casts --warn-unused-ignores --warn-unreachable --pretty\n</code></pre></p>"},{"location":"install/","title":"How to install","text":"<p>The <code>fractal_tasks_core</code> Python package is hosted on PyPI (https://pypi.org/project/fractal-tasks-core), and can be installed via <code>pip</code>. It includes three (sub)packages:</p> <ol> <li>The main <code>fractal_tasks_core</code> package: a set of helper functions to be used in the Fractal tasks (and possibly in other independent packages).</li> <li>The <code>fractal_tasks_core.tasks</code> subpackage: a set of standard Fractal tasks.</li> <li>The <code>fractal_tasks_core.dev</code> subpackage: a set of developement tools (mostly related to creation of JSON Schemas for task arguments).</li> </ol>"},{"location":"install/#minimal-installation","title":"Minimal installation","text":"<p>The minimal installation command is <pre><code>pip install fractal-tasks-core\n</code></pre> which only installs the dependencies necessary for the main package and for the <code>dev</code> subpackage.</p>"},{"location":"install/#full-installation","title":"Full installation","text":"<p>In order to also use the <code>tasks</code> subpackage, the additional extra <code>fractal-tasks</code> must be included, as in <pre><code>pip install fractal-tasks-core[fractal-tasks]\n</code></pre> Warning: This command installs heavier dependencies (e.g. <code>torch</code>).</p>"},{"location":"tables/","title":"Table specifcations","text":"<p>Within <code>fractal-tasks-core</code>, we make use of tables which are <code>AnnData</code> objects stored within OME-Zarr image groups. This page describes the different kinds of tables we use, and it includes:</p> <ul> <li>A core table specification, valid for all tables;</li> <li>The definition of tables for regions of interests (ROIs);</li> <li>The definition of masking ROI tables, namely ROI tables that are linked e.g. to labels;</li> <li>A feature-table specification, to store measurements.</li> </ul> <p>Note: The specifications below are largely inspired by a proposed update to OME-NGFF specs. This update is currently on hold, and <code>fractal-tasks-core</code> will evolve as soon as an official NGFF table specs is adopted - see also the Outlook section.</p>"},{"location":"tables/#specifications-v1","title":"Specifications (V1)","text":"<p>In this section we describe version 1 (V1) of the Fractal table specifications; for the moment, only V1 exists. Note that V1 specifications are only implemented as os of version 0.14.0 of <code>fractal-tasks-core</code>.</p>"},{"location":"tables/#core-tables","title":"Core tables","text":"<p>The core-table specification consists in the definition of the required Zarr structure and attributes, and of the <code>AnnData</code> table format.</p> <p><code>AnnData</code> table format</p> <p>We store tabular data into Zarr groups as <code>AnnData</code> (\"Annotated Data\") objects; the <code>anndata</code> Python library provides the definition of this format and the relevant tools. Quoting from the <code>anndata</code> documentation:</p> <p><code>AnnData</code> is specifically designed for matrix-like data. By this we mean that we have \\(n\\) observations, each of which can be represented as \\(d\\)-dimensional vectors, where each dimension corresponds to a variable or feature. Both the rows and columns of this \\(n \\times d\\) matrix are special in the sense that they are indexed.</p> <p>(https://anndata.readthedocs.io/en/latest/tutorials/notebooks/getting-started.html)</p> <p>Note that <code>AnnData</code> tables are easily transformed from/into <code>pandas.DataFrame</code> objects - see e.g. the <code>AnnData.to_df</code> method.</p> <p>Zarr structure and attributes</p> <p>The structure of Zarr groups is based on the <code>image</code> specification in NGFF 0.4, with an additional <code>tables</code> group and the corresponding subgroups (similar to <code>labels</code>): <pre><code>image.zarr        # Zarr group for a NGFF image\n|\n\u251c\u2500\u2500 0             # Zarr array for multiscale level 0\n\u251c\u2500\u2500 ...\n\u251c\u2500\u2500 N             # Zarr array for multiscale level N\n|\n\u251c\u2500\u2500 labels        # Zarr subgroup with a list of labels associated to this image\n|   \u251c\u2500\u2500 label_A   # Zarr subgroup for a given label\n|   \u251c\u2500\u2500 label_B   # Zarr subgroup for a given label\n|   \u2514\u2500\u2500 ...\n|\n\u2514\u2500\u2500 tables        # Zarr subgroup with a list of tables associated to this image\n    \u251c\u2500\u2500 table_1   # Zarr subgroup for a given table\n    \u251c\u2500\u2500 table_2   # Zarr subgroup for a given table\n    \u2514\u2500\u2500 ...\n</code></pre></p> <p>The Zarr attributes of the <code>tables</code> group must include the key <code>tables</code>, pointing to the list of all tables (this simplifies discovery of tables associated to the current NGFF image), as in image.zarr/tables/.zattrs<pre><code>{\n\"tables\": [\"table_1\", \"table_2\"]\n}\n</code></pre></p> <p>The Zarr attributes of each specific-table group must include the version of the table specification (currently version 1), through the <code>fractal_table_version</code> attribute. Also note that the <code>anndata</code> function to write an <code>AnnData</code> object into a Zarr group automatically sets additional attributes. Here is an example of the resulting Zarr attributes: image.zarr/tables/table_1/.zattrs<pre><code>{\n\"fractal_table_version\": \"1\",\n\"encoding-type\": \"anndata\",    // Automatically added by anndata 0.11\n\"encoding-version\": \"0.1.0\",   // Automatically added by anndata 0.11\n}\n</code></pre></p>"},{"location":"tables/#roi-tables","title":"ROI tables","text":"<p>In <code>fractal-tasks-core</code>, a ROI table defines regions of space which are three-dimensional (see also the Outlook section about dimensionality flexibility) and box-shaped. Typical use cases are described here.</p> <p>Zarr attributes</p> <p>The specification of a ROI table is a subset of the core table one. Moreover, the table-group Zarr attributes must include the <code>type</code> attribute with value <code>roi_table</code>, as in image.zarr/tables/table_1/.zattrs<pre><code>{\n\"fractal_table_version\": \"1\",\n\"type\": \"roi_table\",\n\"encoding-type\": \"anndata\",\n\"encoding-version\": \"0.1.0\",\n}\n</code></pre></p> <p>Table columns</p> <p>The <code>var</code> attribute of a given <code>AnnData</code> object indexes the columns of the table. A <code>fractal-tasks-core</code> ROI table must include the following six columns:</p> <ul> <li><code>x_micrometer</code>, <code>y_micrometer</code>, <code>z_micrometer</code>:   the lower bounds of the XYZ intervals defining the ROI, in micrometers;</li> <li><code>len_x_micrometer</code>, <code>len_y_micrometer</code>, <code>len_z_micrometer</code>:   the XYZ edge lengths, in micrometers.</li> </ul> <p>Notes:</p> <ol> <li>The axes origin for the ROI positions (e.g. for <code>x_micrometer</code>)    corresponds to the top-left corner of the image (for the YX axes) and to    the lowest Z plane.</li> <li>ROIs are defined in physical coordinates, and they do not store    information on the number or size of pixels.</li> </ol> <p>ROI tables may also include other columns, beyond the required ones. Here are the ones that are typically used in <code>fractal-tasks-core</code> (see also the Use cases section):</p> <ul> <li><code>x_micrometer_original</code> and <code>y_micrometer_original</code>, which are a copy of   <code>x_micrometer</code> and <code>y_micrometer</code> taken before applying some transformation;</li> <li><code>translation_x</code>, <code>translation_y</code> and <code>translation_z</code>, which are used during   registration of multiplexing acquisitions;</li> <li><code>label</code>, which is used to link a ROI to a label (either for   masking ROI tables or for   feature tables).</li> </ul>"},{"location":"tables/#masking-roi-tables","title":"Masking ROI tables","text":"<p>Masking ROI tables are a specific instance of the basic ROI tables described above, where each ROI must also be associated to a specific label of a label image.</p> <p>Motivation</p> <p>The motivation for this association is based on the following use case:</p> <ul> <li>By performing segmentation of a NGFF image, we identify N objects and we   store them as a label image (where the value at each pixel correspond to the   label index);</li> <li>We also compute the three-dimensional bounding box of each segmented object,   and store these bounding boxes into a <code>masking</code> ROI table;</li> <li>For each one of these ROIs, we also include information that link it to both   the label image and a specific label index;</li> <li>During further processing we can load/modify specific sub-regions of the ROI,   based on information contained in the label image. This kind of operations   are <code>masked</code>, as they only act on the array elements that match a certain   condition on the label value.</li> </ul> <p>Zarr attributes</p> <p>For this kind of tables, <code>fractal-tasks-core</code> closely follows the proposed NGFF update mentioned above. The requirements on the Zarr attributes of a given table are:</p> <ul> <li>Attributes must contain a <code>type</code> key, with value <code>masking_roi_table</code>2.</li> <li>Attributes must contain a <code>region</code> key; the corresponding value must be an   object with a <code>path</code> key and a string value (i.e. the path to the data the   table is annotating).</li> <li>Attributes must include a key <code>instance_key</code>, which is the key in <code>obs</code> that   denotes which instance in <code>region</code> the row corresponds to.</li> </ul> <p>Here is an example of valid Zarr attributes image.zarr/tables/table_1/.zattrs<pre><code>{\n\"fractal_table_version\": \"1\",\n\"type\": \"masking_roi_table\",\n\"region\": { \"path\": \"../labels/label_DAPI\" },\n\"instance_key\": \"label\",\n\"encoding-type\": \"anndata\",\n\"encoding-version\": \"0.1.0\",\n}\n</code></pre></p> <p><code>AnnData</code> table attributes</p> <p>On top of the required ROI-table colums, the masking-ROI-table <code>AnnData</code> object must have an attribute <code>obs</code> with a key matching to the <code>instance_key</code> zarr attribute. For instance if <code>instance_key=\"label\"</code> then <code>table.obs[\"label\"]</code> must exist, with its items matching the labels in the image in <code>\"../labels/label_DAPI\"</code>.</p>"},{"location":"tables/#feature-tables","title":"Feature tables","text":"<p>Motivation</p> <p>The typical use case for feature tables is to store measurements related to segmented objects, while mantaining a link to the original instances (e.g. labels). Note that the current specification is aligned to the one of masking ROI tables, since they both need to relate a table to a label image, but the two may diverge in the future.</p> <p>As part of the current <code>fractal-tasks-core</code> tasks, measurements can be performed e.g. via <code>regionprops</code> from <code>scikit-image</code>, as wrapped in napari-skimage-regionprops).</p> <p>Zarr attributes</p> <p>For this kind of tables, <code>fractal-tasks-core</code> closely follows the proposed NGFF update mentioned above. The requirements on the Zarr attributes of a given table are:</p> <ul> <li>Attributes must contain a <code>type</code> key, with value <code>feature_table</code>2.</li> <li>Attributes must contain a <code>region</code> key; the corresponding value must be an   object with a <code>path</code> key and a string value (i.e. the path to the data the   table is annotating).</li> <li>Attributes must include a key <code>instance_key</code>, which is the key in <code>obs</code> that   denotes which instance in <code>region</code> the row corresponds to.</li> </ul> <p>Here is an example of valid Zarr attributes image.zarr/tables/table_1/.zattrs<pre><code>{\n\"fractal_table_version\": \"1\",\n\"type\": \"feature_table\",\n\"region\": { \"path\": \"../labels/label_DAPI\" },\n\"instance_key\": \"label\",\n\"encoding-type\": \"anndata\",\n\"encoding-version\": \"0.1.0\",\n}\n</code></pre></p> <p><code>AnnData</code> table attributes</p> <p>The feature-table <code>AnnData</code> object must have an attribute <code>obs</code> with a key matching to the <code>instance_key</code> zarr attribute. For instance if <code>instance_key=\"label\"</code> then <code>table.obs[\"label\"]</code> must exist, with its items matching the labels in the image in <code>\"../labels/label_DAPI\"</code>.</p>"},{"location":"tables/#examples","title":"Examples","text":""},{"location":"tables/#use-cases-for-roi-tables","title":"Use cases for ROI tables","text":""},{"location":"tables/#ome-zarr-creation","title":"OME-Zarr creation","text":"<p>OME-Zarrs created via <code>fractal-tasks-core</code> (e.g. by parsing Yokogawa images via the <code>create_ome_zarr</code> or <code>create_ome_zarr_multiplex</code> tasks) always include two specific ROI tables:</p> <ul> <li>The table named <code>well_ROI_table</code>, which covers the NGFF image corresponding to the whole well1;</li> <li>The table named <code>FOV_ROI_table</code>, which lists all original fields of view (FOVs).</li> </ul> <p>Each one of these two tables includes ROIs that span the whole image size along the Z axis. Note that this differs, e.g., from ROIs which are the bounding boxes of three-dimensional segmented objects, and which may cover only a part of the image Z size.</p>"},{"location":"tables/#ome-zarr-import","title":"OME-Zarr import","text":"<p>When working with an externally-generated OME-Zarr, one may use the <code>import_ome_zarr</code> task to make it compatible with <code>fractal-tasks-core</code>. This task optionally adds two ROI tables to the NGFF images:</p> <ul> <li>The table named <code>image_ROI_table</code>, which covers the whole image;</li> <li>A table named <code>grid_ROI_table</code>, which splits the whole-image ROI into a YX   rectangular grid of smaller ROIs. This may correspond to original FOVs (in   case the image is a tiled well1), or it may simply be useful for applying   downstream processing to smaller arrays and avoid large memory requirements.</li> </ul> <p>As for the case of <code>well_ROI_table</code> and <code>FOV_ROI_table</code> described above, also these two tables include ROIs spanning the whole image extension along the Z axis.</p>"},{"location":"tables/#ome-zarr-processing","title":"OME-Zarr processing","text":"<p>ROI tables are also used and updated during image processing, e.g as in:</p> <ul> <li>The FOV ROI table may undergo transformations during processing, e.g. FOV   ROIs may be shifted to avoid overlaps; in this case, we use the optional   columns <code>x_micrometer_original</code> and <code>y_micrometer_original</code> to store the values   before the transformation.</li> <li>The FOV ROI table is also used to store information on the registration of   multiplexing acquisitions, via the <code>translation_x</code>, <code>translation_y</code> and   <code>translation_z</code> optional columns.</li> <li>Several tasks in <code>fractal-tasks-core</code> take an existing ROI table as an input   and then loop over the ROIs defined in the table. This makes the task more   flexible, as it can be used to process e.g. a whole well, a set of FOVs, or a   set of custom regions of the array.</li> </ul>"},{"location":"tables/#readingwriting-tables","title":"Reading/writing tables","text":"<p>The <code>anndata</code> library offers a set of functions for input/output of AnnData tables, including functions specifically targeting the Zarr format.</p>"},{"location":"tables/#reading-a-table","title":"Reading a table","text":"<p>To read an <code>AnnData</code> table from a Zarr group, one may use the <code>read_zarr</code> function. In the following example a NGFF image was created by stitching together two field of views, where each one is made of a stack of five Z planes with 1 um spacing between the planes. The <code>FOV_ROI_table</code> has information on the XY position and size of the two original FOVs (named <code>FOV_1</code> and <code>FOV_2</code>): <pre><code>import anndata as ad\n\ntable = ad.read_zarr(\"/somewhere/image.zarr/tables/FOV_ROI_table\")\n\nprint(table)\n# `AnnData` object with n_obs \u00d7 n_vars = 2 \u00d7 8\n\nprint(table.obs_names)\n# Index(['FOV_1', 'FOV_2'], dtype='object', name='FieldIndex')\n\nprint(table.var_names)\n# Index([\n#        'x_micrometer',\n#        'y_micrometer',\n#        'z_micrometer',\n#        'len_x_micrometer',\n#        'len_y_micrometer',\n#        'len_z_micrometer',\n#        'x_micrometer_original',\n#        'y_micrometer_original'\n#       ],\n#       dtype='object')\n\nprint(table.X)\n# [[    0.      0.      0.    416.    351.      5.  -1448.3 -1517.7]\n#  [  416.      0.      0.    416.    351.      5.  -1032.3 -1517.7]]\n\ndf = table.to_df()  # Convert to pandas DataFrame\nprint(df)\n#             x_micrometer  y_micrometer  z_micrometer  ...  len_z_micrometer  x_micrometer_original  y_micrometer_original\n# FieldIndex                                            ...\n# FOV_1                0.0           0.0           0.0  ...               2.0           -1448.300049           -1517.699951\n# FOV_2              416.0           0.0           0.0  ...               2.0           -1032.300049           -1517.699951\n#\n# [2 rows x 8 columns]\n</code></pre></p> <p>In this case, the second FOV (labeled <code>FOV_2</code>) is defined as the three-dimensional region such that</p> <ul> <li>X is between 416 and 832 micrometers;</li> <li>Y is between 0 and 351 micrometers;</li> <li>Z is between 0 and 5 - which means that all the five available Z planes are included.</li> </ul>"},{"location":"tables/#writing-a-table","title":"Writing a table","text":"<p>The <code>anndata.experimental.write_elem</code> function provides the required functionality to write an <code>AnnData</code> object to a Zarr group. In <code>fractal-tasks-core</code>, the <code>write_table</code> helper function wraps the <code>anndata</code> function and includes additional functionalities -- see its documentation.</p> <p>With respect to the wrapped <code>anndata</code> function, the main additional features of <code>write_table</code> are</p> <ul> <li>The boolean parameter <code>overwrite</code> (defaulting to <code>False</code>), that determines the behavior in case of an already-existing table at the given path.</li> <li>The <code>table_attrs</code> parameter, as a shorthand for updating the Zarr attributes of the table group after its creation.</li> </ul> <p>Here is an example of how to use <code>write_table</code>: <pre><code>import numpy as np\nimport zarr\nimport anndata as ad\nfrom fractal_tasks_core.tables import write_table\n\ntable = ad.AnnData(X=np.ones((10, 10)))  # Generate a dummy `AnnData` object\nimage_group = zarr.open_group(\"/tmp/image.zarr\")\ntable_name = \"MyTable\"\ntable_attrs = {\n    \"type\": \"feature_table\",\n    \"region\": {\"path\": \"../labels/MyLabel\"},\n    \"instance_key\": \"label\",\n}\n\nwrite_table(\n    image_group,\n    table_name,\n    table,\n    overwrite=True,\n    table_attrs=table_attrs,\n)\n</code></pre> After running this Python code snippet, the on-disk output  is as follows: <pre><code>$ tree /tmp/image.zarr/tables/                  # View folder structure\n/tmp/image.zarr/tables/\n\u2514\u2500\u2500 MyTable\n    \u251c\u2500\u2500 layers\n    \u251c\u2500\u2500 obs\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 _index\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 0\n    \u251c\u2500\u2500 obsm\n    \u251c\u2500\u2500 obsp\n    \u251c\u2500\u2500 uns\n    \u251c\u2500\u2500 var\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 _index\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 0\n    \u251c\u2500\u2500 varm\n    \u251c\u2500\u2500 varp\n    \u2514\u2500\u2500 X\n        \u2514\u2500\u2500 0.0\n\n12 directories, 3 files\n\n$ cat /tmp/image.zarr/tables/.zattrs            # View tables atributes\n{\n    \"tables\": [\n        \"MyTable\"\n    ]\n}\n\n$ cat /tmp/image.zarr/tables/MyTable/.zattrs    # View single-table attributes\n{\n    \"encoding-type\": \"anndata\",\n    \"encoding-version\": \"0.1.0\",\n    \"fractal_table_version\": \"1\",\n    \"instance_key\": \"label\",\n    \"region\": {\n        \"path\": \"../labels/MyLabel\"\n    },\n    \"type\": \"feature_table\"\n}\n</code></pre></p>"},{"location":"tables/#outlook","title":"Outlook","text":"<p>These specifications may evolve (especially based on the future NGFF updates), eventually leading to breaking changes in future versions. <code>fractal-tasks-core</code> will aim at mantaining backwards-compatibility with V1 for a reasonable amount of time.</p> <p>Here is an in-progress list of aspects that may be reviewed:</p> <ul> <li>We aim at removing the use of hard-coded units from the column names (e.g.   <code>x_micrometer</code>), in favor of a more general definition of units.</li> <li>The <code>z_micrometer</code> and <code>len_z_micrometer</code> columns are currently required in   all ROI tables, even when the ROIs actually define a two-dimensional XY   region; in that case, we set <code>z_micrometer=0</code> and <code>len_z_micrometer</code> is such   that the whole Z size is covered (that is, <code>len_z_micrometer</code> is the product   of the spacing between Z planes and the number of planes). In a future   version, we may introduce more flexibility and also accept ROI tables which   only include X and Y axes, and adapt the relevant tools so that they   automatically expand these ROIs into three-dimensions when appropriate.</li> <li>Concerning the use of <code>AnnData</code> tables or other formats for tabular data, our   plan is to follow whatever serialised table specification becomes part of the   NGFF standard. For the record, Zarr does not natively support storage of   dataframes (see e.g.   https://github.com/zarr-developers/numcodecs/issues/452), which is one aspect   in favor of sticking with the <code>anndata</code> library.</li> </ul> <ol> <li> <p>Within <code>fractal-tasks-core</code>, NGFF images represent whole wells; this still complies with the NGFF specifications, as of an approved clarification in the specs. This explains the reason for storing the regions corresponding to the original FOVs in a specific ROI table, since one NGFF image includes a collection of FOVs. Note that this approach does not rely on the assumption that the FOVs constitute a regular tiling of the well, but it also covers the case of irregularly placed FOVs.\u00a0\u21a9\u21a9</p> </li> <li> <p>Note that the table types <code>masking_roi_table</code> and <code>feature_table</code> closely resemble the <code>type=\"ngff:region_table\"</code> specification in the previous proposed NGFF table specs.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"/github/workspace/docs/_tasks/_all/","title":"all","text":""},{"location":"/github/workspace/docs/_tasks/_all/#fractal-tasks-core","title":"<code>fractal-tasks-core</code>","text":"<p>Package: <code>fractal-tasks-core</code></p> <p>Home page: https://fractal-analytics-platform.github.io/fractal-tasks-core</p> <p>Description: The Fractal tasks core package is the reference implementation for Fractal tasks. It contains tasks to convert Cellvoyager CV7000 and CV8000 images to OME-Zarr, to make 3D projections, apply flatfield illumination corrections, segment objects using Cellpose, run napari workflows, calculate &amp; apply registration and to import OME-Zarrs into a Fractal workflow.</p> <p>Tasks:</p> <ul> <li>Convert Cellvoyager to OME-Zarr</li> <li>Convert Cellvoyager Multiplexing to OME-Zarr</li> <li>Project Image (HCS Plate)</li> <li>Illumination Correction</li> <li>Cellpose Segmentation</li> <li>Calculate Registration (image-based)</li> <li>Find Registration Consensus</li> <li>Apply Registration to Image</li> <li>Import OME-Zarr</li> <li>Napari Workflows Wrapper</li> </ul>"},{"location":"/github/workspace/docs/_tasks/_all/#scmultiplex","title":"<code>scMultiplex</code>","text":"<p>Package: <code>scMultiplex</code></p> <p>Home page: https://github.com/fmi-basel/gliberal-scMultipleX</p> <p>Description: The scMultipleX package contains tasks to perform object-based registration, multiplexed measurements, mesh generations and more.</p> <p>Tasks:</p> <ul> <li>scMultiplex Calculate Object Linking</li> <li>scMultiplex Calculate Linking Consensus</li> <li>scMultiplex Relabel by Linking Consensus</li> <li>scMultiplex Calculate Platymatch Registration</li> <li>scMultiplex Surface Mesh Multiscale</li> <li>scMultiplex Segment by Intensity Threshold</li> <li>scMultiplex Spherical Harmonics from Label Image</li> <li>scMultiplex Mesh Measurements</li> <li>scMultiplex Feature Measurements</li> <li>scMultiplex Expand Labels</li> <li>scMultiplex Calculate Z-Illumination Correction</li> <li>scMultiplex Apply Z-Illumination Correction</li> <li>scMultiplex Fuse Touching Labels</li> <li>Convert 3D Segmentation to MIP</li> <li>Build Label Image</li> <li>Annotate Mesh by Child Features</li> <li>Cleanup 3D Child Labels</li> <li>scMultiplex Shift by Shift</li> <li>scMultiplex Calculate Warpfield Registration</li> <li>scMultiplex Apply Warpfield Registration</li> <li>scMultiplex Post Registration Cleanup</li> </ul>"},{"location":"/github/workspace/docs/_tasks/_all/#fractal-faim-ipa","title":"<code>fractal-faim-ipa</code>","text":"<p>Package: <code>fractal-faim-ipa</code></p> <p>Home page: https://github.com/fractal-analytics-platform/fractal-faim-ipa</p> <p>Description: Provides Fractal tasks for the conversion of Molecular Devices ImageXpress microscope to OME-Zarr. This package is based on the faim-ipa library developed by FAIM at FMI.</p> <p>Tasks:</p> <ul> <li>Convert MD to OME-Zarr</li> <li>FAIM-IPA Convert Cellvoyager to OME-Zarr</li> </ul>"},{"location":"/github/workspace/docs/_tasks/_all/#fractal-helper-tasks","title":"<code>fractal-helper-tasks</code>","text":"<p>Package: <code>fractal-helper-tasks</code></p> <p>Home page: https://github.com/fractal-analytics-platform/fractal-helper-tasks</p> <p>Description: Collection of Fractal helper tasks.</p> <p>Tasks:</p> <ul> <li>Drop T Dimension</li> <li>Convert 2D segmentation to 3D</li> <li>Rechunk OME-Zarr</li> <li>Add Z Singleton Dimension</li> <li>Assign Label by Overlap</li> </ul>"},{"location":"/github/workspace/docs/_tasks/_all/#apx_fractal_task_collection","title":"<code>APx_fractal_task_collection</code>","text":"<p>Package: <code>APx_fractal_task_collection</code></p> <p>Home page: https://github.com/Apricot-Therapeutics/APx_fractal_task_collection</p> <p>Description: The APx Fractal Task Collection is mainainted by Apricot Therapeutics AG, Switzerland. This is a collection of tasks intended to be used in combination with the Fractal Analytics Platform maintained by the BioVisionCenter Zurich (co-founded by the Friedrich Miescher Institute and the University of Zurich). The tasks in this collection are focused on extending Fractal's capabilities of processing 2D image data, with a special focus on multiplexed 2D image data. Most tasks work with 3D image data, but they have not specifically been developed for this scenario.</p> <p>Tasks:</p> <ul> <li>Measure Features</li> <li>Calculate Pixel Intensity Correlation</li> <li>Segment Secondary Objects</li> <li>Expand Labels</li> <li>Convert IC6000 to OME-Zarr</li> <li>Add Multiplexing Cycle IC6000</li> <li>Label Assignment by Overlap</li> <li>Clip Label Image</li> <li>Mask Label Image</li> <li>Filter Label by Size</li> <li>Calculate BaSiCPy Illumination Models</li> <li>Apply BaSiCPy Illumination Models</li> <li>Aggregate Feature Tables</li> <li>Stitch FOVs with Overlap</li> <li>Multiplexed Pixel Clustering</li> <li>Correct Chromatic Shift</li> <li>Convert Channel to Label</li> <li>Detect Blob Centroids</li> <li>Ashlar Stitching and Registration</li> <li>Merge Plate Metadata</li> <li>Normalize Feature Table</li> <li>Correct 4i Bleaching Artifacts</li> </ul>"},{"location":"/github/workspace/docs/_tasks/_all/#operetta-compose","title":"<code>operetta-compose</code>","text":"<p>Package: <code>operetta-compose</code></p> <p>Home page: https://github.com/leukemia-kispi/operetta-compose</p> <p>Description: Fractal tasks for the Opera/Operetta microscope and drug response profiling.</p> <p>Tasks:</p> <ul> <li>Harmony to OME-Zarr</li> <li>Stardist segmentation</li> <li>Regionprops measurement</li> <li>Feature classification</li> <li>Condition registration</li> </ul>"},{"location":"/github/workspace/docs/_tasks/_all/#fractal-plantseg-tasks","title":"<code>fractal-plantseg-tasks</code>","text":"<p>Package: <code>fractal-plantseg-tasks</code></p> <p>Home page: https://github.com/fractal-analytics-platform/fractal-plantseg-tasks</p> <p>Description: Collection of Fractal task with the PlantSeg segmentation pipeline.</p> <p>Tasks:</p> <ul> <li>H5 Converter Task</li> <li>Tiff Converter Task</li> <li>PlantSeg Workflow Task</li> </ul>"},{"location":"/github/workspace/docs/_tasks/_all/#fractal-ome-zarr-hcs-stitching","title":"<code>fractal-ome-zarr-hcs-stitching</code>","text":"<p>Package: <code>fractal-ome-zarr-hcs-stitching</code></p> <p>Home page: https://github.com/m-albert/fractal-ome-zarr-hcs-stitching</p> <p>Description: Fractal task(s) for registering and fusing OME-Zarr HCS using multiview-stitcher.</p> <p>Tasks:</p> <ul> <li>Stitching Task</li> </ul>"},{"location":"/github/workspace/docs/_tasks/_all/#fractal-lif-converters","title":"<code>fractal-lif-converters</code>","text":"<p>Package: <code>fractal-lif-converters</code></p> <p>Home page: https://github.com/fractal-analytics-platform/fractal-lif-converters</p> <p>Description: OME-Zarr converters for Leica Lif files built using bioio</p> <p>Tasks:</p> <ul> <li>Convert Lif Plate to OME-Zarr</li> <li>Convert Lif Scene to OME-Zarr</li> </ul>"},{"location":"/github/workspace/docs/_tasks/_all/#fractal-ilastik-tasks","title":"<code>fractal-ilastik-tasks</code>","text":"<p>Package: <code>fractal-ilastik-tasks</code></p> <p>Home page: https://github.com/fractal-analytics-platform/fractal-ilastik-tasks</p> <p>Description: Collection of Fractal task to run Headless ilastik workflows. Early prototype version, feedback is welcome.</p> <p>Tasks:</p> <ul> <li>Ilastik Pixel Classification Segmentation</li> </ul>"},{"location":"reference/fractal_tasks_core/","title":"Index","text":""},{"location":"reference/fractal_tasks_core/SUMMARY/","title":"SUMMARY","text":"<ul> <li>tasks<ul> <li>_registration_utils</li> <li>_utils</li> <li>_zarr_utils</li> <li>apply_registration_to_image</li> <li>calculate_registration_image_based</li> <li>cellpose_segmentation</li> <li>cellpose_utils</li> <li>cellvoyager_to_ome_zarr_compute</li> <li>cellvoyager_to_ome_zarr_init</li> <li>cellvoyager_to_ome_zarr_init_multiplex</li> <li>copy_ome_zarr_hcs_plate</li> <li>find_registration_consensus</li> <li>illumination_correction</li> <li>image_based_registration_hcs_init</li> <li>import_ome_zarr</li> <li>init_group_by_well_for_multiplexing</li> <li>io_models</li> <li>napari_workflows_wrapper</li> <li>projection</li> <li>projection_utils</li> </ul> </li> <li>dev<ul> <li>create_manifest</li> <li>deprecation_message</li> <li>lib_args_schemas</li> <li>lib_descriptions</li> <li>lib_pydantic_generatejsonschema</li> <li>lib_signature_constraints</li> <li>lib_task_docs</li> <li>lib_titles</li> <li>task_list</li> <li>task_models</li> </ul> </li> <li>cellvoyager<ul> <li>filenames</li> <li>metadata</li> <li>wells</li> </ul> </li> <li>channels</li> <li>labels</li> <li>masked_loading</li> <li>ngff<ul> <li>specs</li> <li>zarr_utils</li> </ul> </li> <li>pyramids</li> <li>roi<ul> <li>_overlaps_common</li> <li>load_region</li> <li>v1</li> <li>v1_checks</li> <li>v1_overlaps</li> </ul> </li> <li>tables<ul> <li>v1</li> </ul> </li> <li>upscale_array</li> <li>utils</li> <li>zarr_utils</li> </ul>"},{"location":"reference/fractal_tasks_core/channels/","title":"channels","text":"<p>Helper functions to address channels via OME-NGFF/OMERO metadata.</p>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.ChannelInputModel","title":"<code>ChannelInputModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A channel which is specified by either <code>wavelength_id</code> or <code>label</code>.</p> <p>This model is similar to <code>OmeroChannel</code>, but it is used for task-function arguments (and for generating appropriate JSON schemas).</p> ATTRIBUTE DESCRIPTION <code>wavelength_id</code> <p>Unique ID for the channel wavelength, e.g. <code>A01_C01</code>. Can only be specified if label is not set.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>label</code> <p>Name of the channel. Can only be specified if wavelength_id is not set.</p> <p> TYPE: <code>Optional[str]</code> </p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>class ChannelInputModel(BaseModel):\n\"\"\"\n    A channel which is specified by either `wavelength_id` or `label`.\n\n    This model is similar to `OmeroChannel`, but it is used for\n    task-function arguments (and for generating appropriate JSON schemas).\n\n    Attributes:\n        wavelength_id: Unique ID for the channel wavelength, e.g. `A01_C01`.\n            Can only be specified if label is not set.\n        label: Name of the channel. Can only be specified if wavelength_id is\n            not set.\n    \"\"\"\n\n    wavelength_id: Optional[str] = None\n    label: Optional[str] = None\n\n    @model_validator(mode=\"after\")\n    def mutually_exclusive_channel_attributes(self: Self) -&gt; Self:\n\"\"\"\n        Check that either `label` or `wavelength_id` is set.\n        \"\"\"\n        wavelength_id = self.wavelength_id\n        label = self.label\n\n        if wavelength_id and label:\n            raise ValueError(\n                \"`wavelength_id` and `label` cannot be both set \"\n                f\"(given {wavelength_id=} and {label=}).\"\n            )\n        if wavelength_id is None and label is None:\n            raise ValueError(\n                \"`wavelength_id` and `label` cannot be both `None`\"\n            )\n        return self\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.ChannelInputModel.mutually_exclusive_channel_attributes","title":"<code>mutually_exclusive_channel_attributes()</code>","text":"<p>Check that either <code>label</code> or <code>wavelength_id</code> is set.</p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>@model_validator(mode=\"after\")\ndef mutually_exclusive_channel_attributes(self: Self) -&gt; Self:\n\"\"\"\n    Check that either `label` or `wavelength_id` is set.\n    \"\"\"\n    wavelength_id = self.wavelength_id\n    label = self.label\n\n    if wavelength_id and label:\n        raise ValueError(\n            \"`wavelength_id` and `label` cannot be both set \"\n            f\"(given {wavelength_id=} and {label=}).\"\n        )\n    if wavelength_id is None and label is None:\n        raise ValueError(\n            \"`wavelength_id` and `label` cannot be both `None`\"\n        )\n    return self\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.ChannelNotFoundError","title":"<code>ChannelNotFoundError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Custom error for when <code>get_channel_from_list</code> fails, that can be captured and handled upstream if needed.</p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>class ChannelNotFoundError(ValueError):\n\"\"\"\n    Custom error for when `get_channel_from_list` fails,\n    that can be captured and handled upstream if needed.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.OmeroChannel","title":"<code>OmeroChannel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Custom class for Omero channels, based on OME-NGFF v0.4.</p> ATTRIBUTE DESCRIPTION <code>wavelength_id</code> <p>Unique ID for the channel wavelength, e.g. <code>A01_C01</code>.</p> <p> TYPE: <code>str</code> </p> <code>index</code> <p>Do not change. For internal use only.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>label</code> <p>Name of the channel.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>window</code> <p>Optional <code>Window</code> object to set default display settings. If unset, it will be set to the full bit range of the image (e.g. 0-65535 for 16 bit images).</p> <p> TYPE: <code>Optional[Window]</code> </p> <code>color</code> <p>Optional hex colormap to display the channel in napari (it must be of length 6, e.g. <code>00FFFF</code>).</p> <p> TYPE: <code>Optional[str]</code> </p> <code>active</code> <p>Should this channel be shown in the viewer?</p> <p> TYPE: <code>bool</code> </p> <code>coefficient</code> <p>Do not change. Omero-channel attribute.</p> <p> TYPE: <code>int</code> </p> <code>inverted</code> <p>Do not change. Omero-channel attribute.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>class OmeroChannel(BaseModel):\n\"\"\"\n    Custom class for Omero channels, based on OME-NGFF v0.4.\n\n    Attributes:\n        wavelength_id: Unique ID for the channel wavelength, e.g. `A01_C01`.\n        index: Do not change. For internal use only.\n        label: Name of the channel.\n        window: Optional `Window` object to set default display settings. If\n            unset, it will be set to the full bit range of the image\n            (e.g. 0-65535 for 16 bit images).\n        color: Optional hex colormap to display the channel in napari (it\n            must be of length 6, e.g. `00FFFF`).\n        active: Should this channel be shown in the viewer?\n        coefficient: Do not change. Omero-channel attribute.\n        inverted: Do not change. Omero-channel attribute.\n    \"\"\"\n\n    # Custom\n\n    wavelength_id: str\n    index: Optional[int] = None\n\n    # From OME-NGFF v0.4 transitional metadata\n\n    label: Optional[str] = None\n    window: Optional[Window] = None\n    color: Optional[str] = None\n    active: bool = True\n    coefficient: int = 1\n    inverted: bool = False\n\n    @field_validator(\"color\", mode=\"after\")\n    @classmethod\n    def valid_hex_color(cls, v: Optional[str]) -&gt; Optional[str]:\n\"\"\"\n        Check that `color` is made of exactly six elements which are letters\n        (a-f or A-F) or digits (0-9).\n        \"\"\"\n        if v is None:\n            return v\n        if len(v) != 6:\n            raise ValueError(f'color must have length 6 (given: \"{v}\")')\n        allowed_characters = \"abcdefABCDEF0123456789\"\n        for character in v:\n            if character not in allowed_characters:\n                raise ValueError(\n                    \"color must only include characters from \"\n                    f'\"{allowed_characters}\" (given: \"{v}\")'\n                )\n        return v\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.OmeroChannel.valid_hex_color","title":"<code>valid_hex_color(v)</code>  <code>classmethod</code>","text":"<p>Check that <code>color</code> is made of exactly six elements which are letters (a-f or A-F) or digits (0-9).</p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>@field_validator(\"color\", mode=\"after\")\n@classmethod\ndef valid_hex_color(cls, v: Optional[str]) -&gt; Optional[str]:\n\"\"\"\n    Check that `color` is made of exactly six elements which are letters\n    (a-f or A-F) or digits (0-9).\n    \"\"\"\n    if v is None:\n        return v\n    if len(v) != 6:\n        raise ValueError(f'color must have length 6 (given: \"{v}\")')\n    allowed_characters = \"abcdefABCDEF0123456789\"\n    for character in v:\n        if character not in allowed_characters:\n            raise ValueError(\n                \"color must only include characters from \"\n                f'\"{allowed_characters}\" (given: \"{v}\")'\n            )\n    return v\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.Window","title":"<code>Window</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Custom class for Omero-channel window, based on OME-NGFF v0.4.</p> ATTRIBUTE DESCRIPTION <code>min</code> <p>Do not change. It will be set to <code>0</code> by default.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>max</code> <p>Do not change. It will be set according to bit-depth of the images by default (e.g. 65535 for 16 bit images).</p> <p> TYPE: <code>Optional[int]</code> </p> <code>start</code> <p>Lower-bound rescaling value for visualization.</p> <p> TYPE: <code>int</code> </p> <code>end</code> <p>Upper-bound rescaling value for visualization.</p> <p> TYPE: <code>int</code> </p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>class Window(BaseModel):\n\"\"\"\n    Custom class for Omero-channel window, based on OME-NGFF v0.4.\n\n    Attributes:\n        min: Do not change. It will be set to `0` by default.\n        max:\n            Do not change. It will be set according to bit-depth of the images\n            by default (e.g. 65535 for 16 bit images).\n        start: Lower-bound rescaling value for visualization.\n        end: Upper-bound rescaling value for visualization.\n    \"\"\"\n\n    min: Optional[int] = None\n    max: Optional[int] = None\n    start: int\n    end: int\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels._get_new_unique_value","title":"<code>_get_new_unique_value(value, existing_values)</code>","text":"<p>Produce a string value that is not present in a given list</p> <p>Append <code>_1</code>, <code>_2</code>, ... to a given string, if needed, until finding a value which is not already present in <code>existing_values</code>.</p> PARAMETER DESCRIPTION <code>value</code> <p>The first guess for the new value</p> <p> TYPE: <code>str</code> </p> <code>existing_values</code> <p>The list of existing values</p> <p> TYPE: <code>list[str]</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string value which is not present in <code>existing_values</code></p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>def _get_new_unique_value(\n    value: str,\n    existing_values: list[str],\n) -&gt; str:\n\"\"\"\n    Produce a string value that is not present in a given list\n\n    Append `_1`, `_2`, ... to a given string, if needed, until finding a value\n    which is not already present in `existing_values`.\n\n    Args:\n        value: The first guess for the new value\n        existing_values: The list of existing values\n\n    Returns:\n        A string value which is not present in `existing_values`\n    \"\"\"\n    counter = 1\n    new_value = value\n    while new_value in existing_values:\n        new_value = f\"{value}-{counter}\"\n        counter += 1\n    return new_value\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.check_unique_wavelength_ids","title":"<code>check_unique_wavelength_ids(channels)</code>","text":"<p>Check that the <code>wavelength_id</code> attributes of a channel list are unique.</p> PARAMETER DESCRIPTION <code>channels</code> <p>TBD</p> <p> TYPE: <code>list[OmeroChannel]</code> </p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>def check_unique_wavelength_ids(channels: list[OmeroChannel]):\n\"\"\"\n    Check that the `wavelength_id` attributes of a channel list are unique.\n\n    Args:\n        channels: TBD\n    \"\"\"\n    wavelength_ids = [c.wavelength_id for c in channels]\n    if len(set(wavelength_ids)) &lt; len(wavelength_ids):\n        raise ValueError(\n            f\"Non-unique wavelength_id's in {wavelength_ids}\\n\" f\"{channels=}\"\n        )\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.check_well_channel_labels","title":"<code>check_well_channel_labels(*, well_zarr_path)</code>","text":"<p>Check that the channel labels for a well are unique.</p> <p>First identify the channel-labels list for each image in the well, then compare lists and verify their intersection is empty.</p> PARAMETER DESCRIPTION <code>well_zarr_path</code> <p>path to an OME-NGFF well zarr group.</p> <p> TYPE: <code>str</code> </p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>def check_well_channel_labels(*, well_zarr_path: str) -&gt; None:\n\"\"\"\n    Check that the channel labels for a well are unique.\n\n    First identify the channel-labels list for each image in the well, then\n    compare lists and verify their intersection is empty.\n\n    Args:\n        well_zarr_path: path to an OME-NGFF well zarr group.\n    \"\"\"\n\n    # Iterate over all images (multiplexing acquisitions, multi-FOVs, ...)\n    group = zarr.open_group(well_zarr_path, mode=\"r+\")\n    image_paths = [image[\"path\"] for image in group.attrs[\"well\"][\"images\"]]\n    list_of_channel_lists = []\n    for image_path in image_paths:\n        channels = get_omero_channel_list(\n            image_zarr_path=f\"{well_zarr_path}/{image_path}\"\n        )\n        list_of_channel_lists.append(channels[:])\n\n    # For each pair of channel-labels lists, verify they do not overlap\n    for ind_1, channels_1 in enumerate(list_of_channel_lists):\n        labels_1 = set([c.label for c in channels_1])\n        for ind_2 in range(ind_1):\n            channels_2 = list_of_channel_lists[ind_2]\n            labels_2 = set([c.label for c in channels_2])\n            intersection = labels_1 &amp; labels_2\n            if intersection:\n                hint = (\n                    \"Are you parsing fields of view into separate OME-Zarr \"\n                    \"images? This could lead to non-unique channel labels, \"\n                    \"and then could be the reason of the error\"\n                )\n                raise ValueError(\n                    \"Non-unique channel labels\\n\"\n                    f\"{labels_1=}\\n{labels_2=}\\n{hint}\"\n                )\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.define_omero_channels","title":"<code>define_omero_channels(*, channels, bit_depth, label_prefix=None)</code>","text":"<p>Update a channel list to use it in the OMERO/channels metadata.</p> <p>Given a list of channel dictionaries, update each one of them by:     1. Adding a label (if missing);     2. Adding a set of OMERO-specific attributes;     3. Discarding all other attributes.</p> <p>The <code>new_channels</code> output can be used in the <code>attrs[\"omero\"][\"channels\"]</code> attribute of an image group.</p> PARAMETER DESCRIPTION <code>channels</code> <p>A list of channel dictionaries (each one must include the <code>wavelength_id</code> key).</p> <p> TYPE: <code>list[OmeroChannel]</code> </p> <code>bit_depth</code> <p>bit depth.</p> <p> TYPE: <code>int</code> </p> <code>label_prefix</code> <p>Prefix to be added before the default label. Used e.g. to add a prefix for the acquisition round.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[dict[str, Union[str, int, bool, dict[str, int]]]]</code> <p><code>new_channels</code>, a new list of consistent channel dictionaries that can be written to OMERO metadata.</p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>def define_omero_channels(\n    *,\n    channels: list[OmeroChannel],\n    bit_depth: int,\n    label_prefix: Optional[str] = None,\n) -&gt; list[dict[str, Union[str, int, bool, dict[str, int]]]]:\n\"\"\"\n    Update a channel list to use it in the OMERO/channels metadata.\n\n    Given a list of channel dictionaries, update each one of them by:\n        1. Adding a label (if missing);\n        2. Adding a set of OMERO-specific attributes;\n        3. Discarding all other attributes.\n\n    The `new_channels` output can be used in the `attrs[\"omero\"][\"channels\"]`\n    attribute of an image group.\n\n    Args:\n        channels: A list of channel dictionaries (each one must include the\n            `wavelength_id` key).\n        bit_depth: bit depth.\n        label_prefix: Prefix to be added before the default label. Used e.g.\n            to add a prefix for the acquisition round.\n\n    Returns:\n        `new_channels`, a new list of consistent channel dictionaries that\n            can be written to OMERO metadata.\n    \"\"\"\n\n    new_channels = [c.model_copy(deep=True) for c in channels]\n    default_colors = [\"00FFFF\", \"FF00FF\", \"FFFF00\"]\n\n    for channel in new_channels:\n        wavelength_id = channel.wavelength_id\n\n        # If channel.label is None, set it to a default value\n        if channel.label is None:\n            default_label = wavelength_id\n            if label_prefix is not None:\n                default_label = f\"{label_prefix}_{default_label}\"\n            logging.warning(\n                f\"Missing label for {channel=}, using {default_label=}\"\n            )\n            channel.label = default_label\n\n        # If channel.color is None, set it to a default value (use the default\n        # ones for the first three channels, or gray otherwise)\n        if channel.color is None:\n            try:\n                channel.color = default_colors.pop()\n            except IndexError:\n                channel.color = \"808080\"\n\n        # Set channel.window attribute\n        if channel.window:\n            channel.window.min = 0\n            channel.window.max = 2**bit_depth - 1\n        else:\n            # If no channel.window is set, create a new one with full bitrange\n            # min &amp; max\n            channel.window = Window(\n                min=0,\n                max=2**bit_depth - 1,\n                start=0,\n                end=2**bit_depth - 1,\n            )\n\n    # Check that channel labels are unique for this image\n    labels = [c.label for c in new_channels]\n    if len(set(labels)) &lt; len(labels):\n        raise ValueError(f\"Non-unique labels in {new_channels=}\")\n\n    new_channels_dictionaries = [\n        c.model_dump(exclude={\"index\"}, exclude_unset=True)\n        for c in new_channels\n    ]\n\n    return new_channels_dictionaries\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.get_channel_from_image_zarr","title":"<code>get_channel_from_image_zarr(*, image_zarr_path, label=None, wavelength_id=None)</code>","text":"<p>Extract a channel from OME-NGFF zarr attributes.</p> <p>This is a helper function that combines <code>get_omero_channel_list</code> with <code>get_channel_from_list</code>.</p> PARAMETER DESCRIPTION <code>image_zarr_path</code> <p>Path to an OME-NGFF image zarr group.</p> <p> TYPE: <code>str</code> </p> <code>label</code> <p><code>label</code> attribute of the channel to be extracted.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>wavelength_id</code> <p><code>wavelength_id</code> attribute of the channel to be extracted.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>OmeroChannel</code> <p>A single channel dictionary.</p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>def get_channel_from_image_zarr(\n    *,\n    image_zarr_path: str,\n    label: Optional[str] = None,\n    wavelength_id: Optional[str] = None,\n) -&gt; OmeroChannel:\n\"\"\"\n    Extract a channel from OME-NGFF zarr attributes.\n\n    This is a helper function that combines `get_omero_channel_list` with\n    `get_channel_from_list`.\n\n    Args:\n        image_zarr_path: Path to an OME-NGFF image zarr group.\n        label: `label` attribute of the channel to be extracted.\n        wavelength_id: `wavelength_id` attribute of the channel to be\n            extracted.\n\n    Returns:\n        A single channel dictionary.\n    \"\"\"\n    omero_channels = get_omero_channel_list(image_zarr_path=image_zarr_path)\n    channel = get_channel_from_list(\n        channels=omero_channels, label=label, wavelength_id=wavelength_id\n    )\n    return channel\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.get_channel_from_list","title":"<code>get_channel_from_list(*, channels, label=None, wavelength_id=None)</code>","text":"<p>Find matching channel in a list.</p> <p>Find the channel that has the required values of <code>label</code> and/or <code>wavelength_id</code>, and identify its positional index (which also corresponds to its index in the zarr array).</p> PARAMETER DESCRIPTION <code>channels</code> <p>A list of channel dictionary, where each channel includes (at least) the <code>label</code> and <code>wavelength_id</code> keys.</p> <p> TYPE: <code>list[OmeroChannel]</code> </p> <code>label</code> <p>The label to look for in the list of channels.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>wavelength_id</code> <p>The wavelength_id to look for in the list of channels.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>OmeroChannel</code> <p>A single channel dictionary.</p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>def get_channel_from_list(\n    *,\n    channels: list[OmeroChannel],\n    label: Optional[str] = None,\n    wavelength_id: Optional[str] = None,\n) -&gt; OmeroChannel:\n\"\"\"\n    Find matching channel in a list.\n\n    Find the channel that has the required values of `label` and/or\n    `wavelength_id`, and identify its positional index (which also\n    corresponds to its index in the zarr array).\n\n    Args:\n        channels: A list of channel dictionary, where each channel includes (at\n            least) the `label` and `wavelength_id` keys.\n        label: The label to look for in the list of channels.\n        wavelength_id: The wavelength_id to look for in the list of channels.\n\n    Returns:\n        A single channel dictionary.\n    \"\"\"\n\n    # Identify matching channels\n    if label:\n        if wavelength_id:\n            # Both label and wavelength_id are specified\n            matching_channels = [\n                c\n                for c in channels\n                if (c.label == label and c.wavelength_id == wavelength_id)\n            ]\n        else:\n            # Only label is specified\n            matching_channels = [c for c in channels if c.label == label]\n    else:\n        if wavelength_id:\n            # Only wavelength_id is specified\n            matching_channels = [\n                c for c in channels if c.wavelength_id == wavelength_id\n            ]\n        else:\n            # Neither label or wavelength_id are specified\n            raise ValueError(\n                \"get_channel requires at least one in {label,wavelength_id} \"\n                \"arguments\"\n            )\n\n    # Verify that there is one and only one matching channel\n    if len(matching_channels) == 0:\n        required_match = [f\"{label=}\", f\"{wavelength_id=}\"]\n        required_match_string = \" and \".join(\n            [x for x in required_match if \"None\" not in x]\n        )\n        raise ChannelNotFoundError(\n            f\"ChannelNotFoundError: No channel found in {channels}\"\n            f\" for {required_match_string}\"\n        )\n    if len(matching_channels) &gt; 1:\n        raise ValueError(f\"Inconsistent set of channels: {channels}\")\n\n    channel = matching_channels[0]\n    channel.index = channels.index(channel)\n    return channel\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.get_omero_channel_list","title":"<code>get_omero_channel_list(*, image_zarr_path)</code>","text":"<p>Extract the list of channels from OME-NGFF zarr attributes.</p> PARAMETER DESCRIPTION <code>image_zarr_path</code> <p>Path to an OME-NGFF image zarr group.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[OmeroChannel]</code> <p>A list of channel dictionaries.</p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>def get_omero_channel_list(*, image_zarr_path: str) -&gt; list[OmeroChannel]:\n\"\"\"\n    Extract the list of channels from OME-NGFF zarr attributes.\n\n    Args:\n        image_zarr_path: Path to an OME-NGFF image zarr group.\n\n    Returns:\n        A list of channel dictionaries.\n    \"\"\"\n    group = zarr.open_group(image_zarr_path, mode=\"r+\")\n    channels_dicts = group.attrs[\"omero\"][\"channels\"]\n    channels = [OmeroChannel(**c) for c in channels_dicts]\n    return channels\n</code></pre>"},{"location":"reference/fractal_tasks_core/channels/#fractal_tasks_core.channels.update_omero_channels","title":"<code>update_omero_channels(old_channels)</code>","text":"<p>Make an existing list of Omero channels Fractal-compatible</p> <p>The output channels all have keys <code>label</code>, <code>wavelength_id</code> and <code>color</code>; the <code>wavelength_id</code> values are unique across the channel list.</p> <p>See https://ngff.openmicroscopy.org/0.4/index.html#omero-md for the definition of NGFF Omero metadata.</p> PARAMETER DESCRIPTION <code>old_channels</code> <p>Existing list of Omero-channel dictionaries</p> <p> TYPE: <code>list[dict[str, Any]]</code> </p> RETURNS DESCRIPTION <code>list[dict[str, Any]]</code> <p>New list of Fractal-compatible Omero-channel dictionaries</p> Source code in <code>fractal_tasks_core/channels.py</code> <pre><code>def update_omero_channels(\n    old_channels: list[dict[str, Any]],\n) -&gt; list[dict[str, Any]]:\n\"\"\"\n    Make an existing list of Omero channels Fractal-compatible\n\n    The output channels all have keys `label`, `wavelength_id` and `color`;\n    the `wavelength_id` values are unique across the channel list.\n\n    See https://ngff.openmicroscopy.org/0.4/index.html#omero-md for the\n    definition of NGFF Omero metadata.\n\n    Args:\n        old_channels: Existing list of Omero-channel dictionaries\n\n    Returns:\n        New list of Fractal-compatible Omero-channel dictionaries\n    \"\"\"\n    new_channels = deepcopy(old_channels)\n    existing_wavelength_ids: list[str] = []\n    handled_channels = []\n\n    default_colors = [\"00FFFF\", \"FF00FF\", \"FFFF00\"]\n\n    def _get_next_color() -&gt; str:\n        try:\n            return default_colors.pop(0)\n        except IndexError:\n            return \"808080\"\n\n    # Channels that contain the key \"wavelength_id\"\n    for ind, old_channel in enumerate(old_channels):\n        if \"wavelength_id\" in old_channel.keys():\n            handled_channels.append(ind)\n            existing_wavelength_ids.append(old_channel[\"wavelength_id\"])\n            new_channel = old_channel.copy()\n            try:\n                label = old_channel[\"label\"]\n            except KeyError:\n                label = str(ind + 1)\n            new_channel[\"label\"] = label\n            if \"color\" not in old_channel:\n                new_channel[\"color\"] = _get_next_color()\n            new_channels[ind] = new_channel\n\n    # Channels that contain the key \"label\" but do not contain the key\n    # \"wavelength_id\"\n    for ind, old_channel in enumerate(old_channels):\n        if ind in handled_channels:\n            continue\n        if \"label\" not in old_channel.keys():\n            continue\n        handled_channels.append(ind)\n        label = old_channel[\"label\"]\n        wavelength_id = _get_new_unique_value(\n            label,\n            existing_wavelength_ids,\n        )\n        existing_wavelength_ids.append(wavelength_id)\n        new_channel = old_channel.copy()\n        new_channel[\"wavelength_id\"] = wavelength_id\n        if \"color\" not in old_channel:\n            new_channel[\"color\"] = _get_next_color()\n        new_channels[ind] = new_channel\n\n    # Channels that do not contain the key \"label\" nor the key \"wavelength_id\"\n    # NOTE: these channels must be treated last, as they have lower priority\n    # w.r.t. existing \"wavelength_id\" or \"label\" values\n    for ind, old_channel in enumerate(old_channels):\n        if ind in handled_channels:\n            continue\n        label = str(ind + 1)\n        wavelength_id = _get_new_unique_value(\n            label,\n            existing_wavelength_ids,\n        )\n        existing_wavelength_ids.append(wavelength_id)\n        new_channel = old_channel.copy()\n        new_channel[\"label\"] = label\n        new_channel[\"wavelength_id\"] = wavelength_id\n        if \"color\" not in old_channel:\n            new_channel[\"color\"] = _get_next_color()\n        new_channels[ind] = new_channel\n\n    # Log old/new values of label, wavelength_id and color\n    for ind, old_channel in enumerate(old_channels):\n        label = old_channel.get(\"label\")\n        color = old_channel.get(\"color\")\n        wavelength_id = old_channel.get(\"wavelength_id\")\n        old_attributes = (\n            f\"Old attributes: {label=}, {wavelength_id=}, {color=}\"\n        )\n        label = new_channels[ind][\"label\"]\n        wavelength_id = new_channels[ind][\"wavelength_id\"]\n        color = new_channels[ind][\"color\"]\n        new_attributes = (\n            f\"New attributes: {label=}, {wavelength_id=}, {color=}\"\n        )\n        logging.info(\n            \"Omero channel update:\\n\"\n            f\"    {old_attributes}\\n\"\n            f\"    {new_attributes}\"\n        )\n\n    return new_channels\n</code></pre>"},{"location":"reference/fractal_tasks_core/labels/","title":"labels","text":"<p>Module which currently only hosts <code>prepare_label_group</code>.</p>"},{"location":"reference/fractal_tasks_core/labels/#fractal_tasks_core.labels.prepare_label_group","title":"<code>prepare_label_group(image_group, label_name, label_attrs, overwrite=False, logger=None)</code>","text":"<p>Set the stage for writing labels to a zarr group</p> <p>This helper function is similar to <code>write_table</code>, in that it prepares the appropriate zarr groups (<code>labels</code> and the new-label one) and performs <code>overwrite</code>-dependent checks. At a difference with <code>write_table</code>, this function does not actually write the label array to the new zarr group; such writing operation must take place in the actual task function, since in fractal-tasks-core it is done sequentially on different <code>region</code>s of the zarr array.</p> <p>What this function does is:</p> <ol> <li>Create the <code>labels</code> group, if needed.</li> <li>If <code>overwrite=False</code>, check that the new label does not exist (either in    zarr attributes or as a zarr sub-group).</li> <li>Update the <code>labels</code> attribute of the image group.</li> <li>If <code>label_attrs</code> is set, include this set of attributes in the    new-label zarr group.</li> </ol> PARAMETER DESCRIPTION <code>image_group</code> <p>The group to write to.</p> <p> TYPE: <code>Group</code> </p> <code>label_name</code> <p>The name of the new label; this name also overrides the multiscale name in NGFF-image Zarr attributes, if needed.</p> <p> TYPE: <code>str</code> </p> <code>overwrite</code> <p>If <code>False</code>, check that the new label does not exist (either in zarr attributes or as a zarr sub-group); if <code>True</code> propagate parameter to <code>create_group</code> method, making it overwrite any existing sub-group with the given name.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>label_attrs</code> <p>Zarr attributes of the label-image group.</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>logger</code> <p>The logger to use (if unset, use <code>logging.getLogger(None)</code>).</p> <p> TYPE: <code>Optional[Logger]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>group</code> <p>Zarr group of the new label.</p> Source code in <code>fractal_tasks_core/labels.py</code> <pre><code>def prepare_label_group(\n    image_group: zarr.hierarchy.Group,\n    label_name: str,\n    label_attrs: dict[str, Any],\n    overwrite: bool = False,\n    logger: Optional[logging.Logger] = None,\n) -&gt; zarr.group:\n\"\"\"\n    Set the stage for writing labels to a zarr group\n\n    This helper function is similar to `write_table`, in that it prepares the\n    appropriate zarr groups (`labels` and the new-label one) and performs\n    `overwrite`-dependent checks. At a difference with `write_table`, this\n    function does not actually write the label array to the new zarr group;\n    such writing operation must take place in the actual task function, since\n    in fractal-tasks-core it is done sequentially on different `region`s of the\n    zarr array.\n\n    What this function does is:\n\n    1. Create the `labels` group, if needed.\n    2. If `overwrite=False`, check that the new label does not exist (either in\n       zarr attributes or as a zarr sub-group).\n    3. Update the `labels` attribute of the image group.\n    4. If `label_attrs` is set, include this set of attributes in the\n       new-label zarr group.\n\n    Args:\n        image_group:\n            The group to write to.\n        label_name:\n            The name of the new label; this name also overrides the multiscale\n            name in NGFF-image Zarr attributes, if needed.\n        overwrite:\n            If `False`, check that the new label does not exist (either in zarr\n            attributes or as a zarr sub-group); if `True` propagate parameter\n            to `create_group` method, making it overwrite any existing\n            sub-group with the given name.\n        label_attrs:\n            Zarr attributes of the label-image group.\n        logger:\n            The logger to use (if unset, use `logging.getLogger(None)`).\n\n    Returns:\n        Zarr group of the new label.\n    \"\"\"\n\n    # Set logger\n    if logger is None:\n        logger = logging.getLogger(None)\n\n    # Create labels group (if needed) and extract current_labels\n    if \"labels\" not in set(image_group.group_keys()):\n        labels_group = image_group.create_group(\"labels\", overwrite=False)\n    else:\n        labels_group = image_group[\"labels\"]\n    current_labels = labels_group.attrs.asdict().get(\"labels\", [])\n\n    # If overwrite=False, check that the new label does not exist (either as a\n    # zarr sub-group or as part of the zarr-group attributes)\n    if not overwrite:\n        if label_name in set(labels_group.group_keys()):\n            error_msg = (\n                f\"Sub-group '{label_name}' of group {image_group.store.path} \"\n                f\"already exists, but `{overwrite=}`.\\n\"\n                \"Hint: try setting `overwrite=True`.\"\n            )\n            logger.error(error_msg)\n            raise OverwriteNotAllowedError(error_msg)\n        if label_name in current_labels:\n            error_msg = (\n                f\"Item '{label_name}' already exists in `labels` attribute of \"\n                f\"group {image_group.store.path}, but `{overwrite=}`.\\n\"\n                \"Hint: try setting `overwrite=True`.\"\n            )\n            logger.error(error_msg)\n            raise OverwriteNotAllowedError(error_msg)\n\n    # Update the `labels` metadata of the image group, if needed\n    if label_name not in current_labels:\n        new_labels = current_labels + [label_name]\n        labels_group.attrs[\"labels\"] = new_labels\n\n    # Define new-label group\n    label_group = labels_group.create_group(label_name, overwrite=overwrite)\n\n    # Validate attrs against NGFF specs 0.4\n    try:\n        meta = NgffImageMeta(**label_attrs)\n    except ValidationError as e:\n        error_msg = (\n            \"Label attributes do not comply with NGFF image \"\n            \"specifications, as encoded in fractal-tasks-core.\\n\"\n            f\"Original error:\\nValidationError: {str(e)}\"\n        )\n        logger.error(error_msg)\n        raise ValueError(error_msg)\n    # Replace multiscale name with label_name, if needed\n    current_multiscale_name = meta.multiscale.name\n    if current_multiscale_name != label_name:\n        logger.warning(\n            f\"Setting multiscale name to '{label_name}' (old value: \"\n            f\"'{current_multiscale_name}') in label-image NGFF \"\n            \"attributes.\"\n        )\n        label_attrs[\"multiscales\"][0][\"name\"] = label_name\n    # Overwrite label_group attributes with label_attrs key/value pairs\n    label_group.attrs.put(label_attrs)\n\n    return label_group\n</code></pre>"},{"location":"reference/fractal_tasks_core/masked_loading/","title":"masked_loading","text":"<p>Functions to use masked loading of ROIs before/after processing.</p>"},{"location":"reference/fractal_tasks_core/masked_loading/#fractal_tasks_core.masked_loading._postprocess_output","title":"<code>_postprocess_output(*, modified_array, original_array, background)</code>","text":"<p>Postprocess cellpose output, mainly to restore its original background.</p> <p>NOTE: The pre/post-processing functions and the masked_loading_wrapper are currently meant to work as part of the cellpose_segmentation task, with the plan of then making them more flexible; see https://github.com/fractal-analytics-platform/fractal-tasks-core/issues/340.</p> PARAMETER DESCRIPTION <code>modified_array</code> <p>The 3D (ZYX) array with the correct object data and wrong background data.</p> <p> TYPE: <code>ndarray</code> </p> <code>original_array</code> <p>The 3D (ZYX) array with the wrong object data and correct background data.</p> <p> TYPE: <code>ndarray</code> </p> <code>background</code> <p>The 3D (ZYX) boolean array that defines the background.</p> <p> TYPE: <code>ndarray</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>The postprocessed array.</p> Source code in <code>fractal_tasks_core/masked_loading.py</code> <pre><code>def _postprocess_output(\n    *,\n    modified_array: np.ndarray,\n    original_array: np.ndarray,\n    background: np.ndarray,\n) -&gt; np.ndarray:\n\"\"\"\n    Postprocess cellpose output, mainly to restore its original background.\n\n    **NOTE**: The pre/post-processing functions and the\n    masked_loading_wrapper are currently meant to work as part of the\n    cellpose_segmentation task, with the plan of then making them more\n    flexible; see\n    https://github.com/fractal-analytics-platform/fractal-tasks-core/issues/340.\n\n    Args:\n        modified_array: The 3D (ZYX) array with the correct object data and\n            wrong background data.\n        original_array: The 3D (ZYX) array with the wrong object data and\n            correct background data.\n        background: The 3D (ZYX) boolean array that defines the background.\n\n    Returns:\n        The postprocessed array.\n    \"\"\"\n    # Restore background\n    modified_array[background] = original_array[background]\n    return modified_array\n</code></pre>"},{"location":"reference/fractal_tasks_core/masked_loading/#fractal_tasks_core.masked_loading._preprocess_input","title":"<code>_preprocess_input(image_array, *, region, current_label_path, ROI_table_path, ROI_positional_index)</code>","text":"<p>Preprocess a four-dimensional cellpose input.</p> <p>This involves :</p> <ul> <li>Loading the masking label array for the appropriate ROI;</li> <li>Extracting the appropriate label value from the <code>ROI_table.obs</code>   dataframe;</li> <li>Constructing the background mask, where the masking label matches with a   specific label value;</li> <li>Setting the background of <code>image_array</code> to <code>0</code>;</li> <li>Loading the array which will be needed in postprocessing to restore   background.</li> </ul> <p>NOTE 1: This function relies on V1 of the Fractal table specifications, see https://fractal-analytics-platform.github.io/fractal-tasks-core/tables/.</p> <p>NOTE 2: The pre/post-processing functions and the masked_loading_wrapper are currently meant to work as part of the cellpose_segmentation task, with the plan of then making them more flexible; see https://github.com/fractal-analytics-platform/fractal-tasks-core/issues/340.</p> <p>Naming of variables refers to a two-steps labeling, as in \"first identify organoids, then look for nuclei inside each organoid\") :</p> <ul> <li><code>\"masking\"</code> refers to the labels that are used to identify the object   vs background (e.g. the organoid labels); these labels already exist.</li> <li><code>\"current\"</code> refers to the labels that are currently being computed in   the <code>cellpose_segmentation</code> task, e.g. the nuclear labels.</li> </ul> PARAMETER DESCRIPTION <code>image_array</code> <p>The 4D CZYX array with image data for a specific ROI.</p> <p> TYPE: <code>ndarray</code> </p> <code>region</code> <p>The ZYX indices of the ROI, in a form like <code>(slice(0, 1), slice(1000, 2000), slice(1000, 2000))</code>.</p> <p> TYPE: <code>tuple[slice, ...]</code> </p> <code>current_label_path</code> <p>Path to the image used as current label, in a form like <code>/somewhere/plate.zarr/A/01/0/labels/nuclei_in_organoids/0</code>.</p> <p> TYPE: <code>str</code> </p> <code>ROI_table_path</code> <p>Path of the AnnData table for the masking-label ROIs; this is used (together with <code>ROI_positional_index</code>) to extract <code>label_value</code>.</p> <p> TYPE: <code>str</code> </p> <code>ROI_positional_index</code> <p>Index of the current ROI, which is used to extract <code>label_value</code> from <code>ROI_table_obs</code>.</p> <p> TYPE: <code>int</code> </p> <p>Returns:     A tuple with three arrays: the preprocessed image array, the background         mask, the current label.</p> Source code in <code>fractal_tasks_core/masked_loading.py</code> <pre><code>def _preprocess_input(\n    image_array: np.ndarray,\n    *,\n    region: tuple[slice, ...],\n    current_label_path: str,\n    ROI_table_path: str,\n    ROI_positional_index: int,\n) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray]:\n\"\"\"\n    Preprocess a four-dimensional cellpose input.\n\n    This involves :\n\n    - Loading the masking label array for the appropriate ROI;\n    - Extracting the appropriate label value from the `ROI_table.obs`\n      dataframe;\n    - Constructing the background mask, where the masking label matches with a\n      specific label value;\n    - Setting the background of `image_array` to `0`;\n    - Loading the array which will be needed in postprocessing to restore\n      background.\n\n    **NOTE 1**: This function relies on V1 of the Fractal table specifications,\n    see\n    https://fractal-analytics-platform.github.io/fractal-tasks-core/tables/.\n\n    **NOTE 2**: The pre/post-processing functions and the\n    masked_loading_wrapper are currently meant to work as part of the\n    cellpose_segmentation task, with the plan of then making them more\n    flexible; see\n    https://github.com/fractal-analytics-platform/fractal-tasks-core/issues/340.\n\n    Naming of variables refers to a two-steps labeling, as in \"first identify\n    organoids, then look for nuclei inside each organoid\") :\n\n    - `\"masking\"` refers to the labels that are used to identify the object\n      vs background (e.g. the organoid labels); these labels already exist.\n    - `\"current\"` refers to the labels that are currently being computed in\n      the `cellpose_segmentation` task, e.g. the nuclear labels.\n\n    Args:\n        image_array: The 4D CZYX array with image data for a specific ROI.\n        region: The ZYX indices of the ROI, in a form like\n            `(slice(0, 1), slice(1000, 2000), slice(1000, 2000))`.\n        current_label_path: Path to the image used as current label, in a form\n            like `/somewhere/plate.zarr/A/01/0/labels/nuclei_in_organoids/0`.\n        ROI_table_path: Path of the AnnData table for the masking-label ROIs;\n            this is used (together with `ROI_positional_index`) to extract\n            `label_value`.\n        ROI_positional_index: Index of the current ROI, which is used to\n            extract `label_value` from `ROI_table_obs`.\n    Returns:\n        A tuple with three arrays: the preprocessed image array, the background\n            mask, the current label.\n    \"\"\"\n\n    logger.info(f\"[_preprocess_input] {image_array.shape=}\")\n    logger.info(f\"[_preprocess_input] {region=}\")\n\n    # Check that image data are 4D (CZYX) - FIXME issue 340\n    if not image_array.ndim == 4:\n        raise ValueError(\n            \"_preprocess_input requires a 4D \"\n            f\"image_array argument, but {image_array.shape=}\"\n        )\n\n    # Load the ROI table and its metadata attributes\n    ROI_table = ad.read_zarr(ROI_table_path)\n    attrs = zarr.group(ROI_table_path).attrs\n    logger.info(f\"[_preprocess_input] {ROI_table_path=}\")\n    logger.info(f\"[_preprocess_input] {attrs.asdict()=}\")\n    MaskingROITableAttrs(**attrs.asdict())\n    label_relative_path = attrs[\"region\"][\"path\"]\n    column_name = attrs[\"instance_key\"]\n\n    # Check that ROI_table.obs has the right column and extract label_value\n    if column_name not in ROI_table.obs.columns:\n        if ROI_table.obs.index.name == column_name:\n            # Workaround for new ngio table\n            ROI_table.obs[column_name] = ROI_table.obs.index\n        else:\n            raise ValueError(\n                f\"In _preprocess_input, {column_name=} \"\n                f\" missing in {ROI_table.obs.columns=}\"\n            )\n    label_value = int(\n        float(ROI_table.obs[column_name].iloc[ROI_positional_index])\n    )\n\n    # Load masking-label array (lazily)\n    masking_label_path = str(\n        Path(ROI_table_path).parent / label_relative_path / \"0\"\n    )\n    logger.info(f\"{masking_label_path=}\")\n    masking_label_array = da.from_zarr(masking_label_path)\n    logger.info(\n        f\"[_preprocess_input] {masking_label_path=}, \"\n        f\"{masking_label_array.shape=}\"\n    )\n\n    # Load current-label array (lazily)\n    current_label_array = da.from_zarr(current_label_path)\n    logger.info(\n        f\"[_preprocess_input] {current_label_path=}, \"\n        f\"{current_label_array.shape=}\"\n    )\n\n    # Load ROI data for current label array\n    current_label_region = current_label_array[region].compute()\n\n    # Load ROI data for masking label array, with or without upscaling\n    if masking_label_array.shape != current_label_array.shape:\n        logger.info(\"Upscaling of masking label is needed\")\n        lowres_region = convert_region_to_low_res(\n            highres_region=region,\n            highres_shape=current_label_array.shape,\n            lowres_shape=masking_label_array.shape,\n        )\n        masking_label_region = masking_label_array[lowres_region].compute()\n        masking_label_region = upscale_array(\n            array=masking_label_region,\n            target_shape=current_label_region.shape,\n        )\n    else:\n        masking_label_region = masking_label_array[region].compute()\n\n    # Check that all shapes match\n    shapes = (\n        masking_label_region.shape,\n        current_label_region.shape,\n        image_array.shape[1:],\n    )\n    if len(set(shapes)) &gt; 1:\n        raise ValueError(\n            \"Shape mismatch:\\n\"\n            f\"{current_label_region.shape=}\\n\"\n            f\"{masking_label_region.shape=}\\n\"\n            f\"{image_array.shape=}\"\n        )\n\n    # Compute background mask\n    background_3D = masking_label_region != label_value\n    if (masking_label_region == label_value).sum() == 0:\n        raise ValueError(\n            f\"Label {label_value} is not present in the extracted ROI\"\n        )\n\n    # Set image background to zero\n    n_channels = image_array.shape[0]\n    for i in range(n_channels):\n        image_array[i, background_3D] = 0\n\n    return (image_array, background_3D, current_label_region)\n</code></pre>"},{"location":"reference/fractal_tasks_core/masked_loading/#fractal_tasks_core.masked_loading.masked_loading_wrapper","title":"<code>masked_loading_wrapper(*, function, image_array, kwargs=None, use_masks, preprocessing_kwargs=None)</code>","text":"<p>Wrap a function with some pre/post-processing functions</p> PARAMETER DESCRIPTION <code>function</code> <p>The callable function to be wrapped.</p> <p> TYPE: <code>Callable</code> </p> <code>image_array</code> <p>The image array to be preprocessed and then used as positional argument for <code>function</code>.</p> <p> TYPE: <code>ndarray</code> </p> <code>kwargs</code> <p>Keyword arguments for <code>function</code>.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>use_masks</code> <p>If <code>False</code>, the wrapper only calls <code>function(*args, **kwargs)</code>.</p> <p> TYPE: <code>bool</code> </p> <code>preprocessing_kwargs</code> <p>Keyword arguments for the preprocessing function (see call signature of <code>_preprocess_input()</code>).</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> Source code in <code>fractal_tasks_core/masked_loading.py</code> <pre><code>def masked_loading_wrapper(\n    *,\n    function: Callable,\n    image_array: np.ndarray,\n    kwargs: Optional[dict] = None,\n    use_masks: bool,\n    preprocessing_kwargs: Optional[dict] = None,\n):\n\"\"\"\n    Wrap a function with some pre/post-processing functions\n\n    Args:\n        function: The callable function to be wrapped.\n        image_array: The image array to be preprocessed and then used as\n            positional argument for `function`.\n        kwargs: Keyword arguments for `function`.\n        use_masks: If `False`, the wrapper only calls\n            `function(*args, **kwargs)`.\n        preprocessing_kwargs: Keyword arguments for the preprocessing function\n            (see call signature of `_preprocess_input()`).\n    \"\"\"\n    # Optional preprocessing\n    if use_masks:\n        preprocessing_kwargs = preprocessing_kwargs or {}\n        (\n            image_array,\n            background_3D,\n            current_label_region,\n        ) = _preprocess_input(image_array, **preprocessing_kwargs)\n    # Run function\n    kwargs = kwargs or {}\n    new_label_img = function(image_array, **kwargs)\n    # Optional postprocessing\n    if use_masks:\n        new_label_img = _postprocess_output(\n            modified_array=new_label_img,\n            original_array=current_label_region,\n            background=background_3D,\n        )\n    return new_label_img\n</code></pre>"},{"location":"reference/fractal_tasks_core/pyramids/","title":"pyramids","text":"<p>Construct and write pyramid of lower-resolution levels.</p>"},{"location":"reference/fractal_tasks_core/pyramids/#fractal_tasks_core.pyramids.build_pyramid","title":"<code>build_pyramid(*, zarrurl, overwrite=False, num_levels=2, coarsening_xy=2, chunksize=None, aggregation_function=None, open_array_kwargs=None)</code>","text":"<p>Starting from on-disk highest-resolution data, build and write to disk a pyramid with <code>(num_levels - 1)</code> coarsened levels. This function works for 2D, 3D or 4D arrays.</p> PARAMETER DESCRIPTION <code>zarrurl</code> <p>Path of the image zarr group, not including the multiscale-level path (e.g. <code>\"some/path/plate.zarr/B/03/0\"</code>).</p> <p> TYPE: <code>Union[str, Path]</code> </p> <code>overwrite</code> <p>Whether to overwrite existing pyramid levels.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>num_levels</code> <p>Total number of pyramid levels (including 0).</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>coarsening_xy</code> <p>Linear coarsening factor between subsequent levels.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>chunksize</code> <p>Shape of a single chunk.</p> <p> TYPE: <code>Optional[Sequence[int]]</code> DEFAULT: <code>None</code> </p> <code>aggregation_function</code> <p>Function to be used when downsampling.</p> <p> TYPE: <code>Optional[Callable]</code> DEFAULT: <code>None</code> </p> <code>open_array_kwargs</code> <p>Additional arguments for zarr.open.</p> <p> TYPE: <code>Optional[Mapping]</code> DEFAULT: <code>None</code> </p> Source code in <code>fractal_tasks_core/pyramids.py</code> <pre><code>def build_pyramid(\n    *,\n    zarrurl: Union[str, pathlib.Path],\n    overwrite: bool = False,\n    num_levels: int = 2,\n    coarsening_xy: int = 2,\n    chunksize: Optional[Sequence[int]] = None,\n    aggregation_function: Optional[Callable] = None,\n    open_array_kwargs: Optional[Mapping] = None,\n) -&gt; None:\n\"\"\"\n    Starting from on-disk highest-resolution data, build and write to disk a\n    pyramid with `(num_levels - 1)` coarsened levels.\n    This function works for 2D, 3D or 4D arrays.\n\n    Args:\n        zarrurl: Path of the image zarr group, not including the\n            multiscale-level path (e.g. `\"some/path/plate.zarr/B/03/0\"`).\n        overwrite: Whether to overwrite existing pyramid levels.\n        num_levels: Total number of pyramid levels (including 0).\n        coarsening_xy: Linear coarsening factor between subsequent levels.\n        chunksize: Shape of a single chunk.\n        aggregation_function: Function to be used when downsampling.\n        open_array_kwargs: Additional arguments for zarr.open.\n    \"\"\"\n\n    # Clean up zarrurl\n    zarrurl = str(pathlib.Path(zarrurl))  # FIXME\n\n    # Select full-resolution multiscale level\n    zarrurl_highres = f\"{zarrurl}/0\"\n    logger.info(f\"[build_pyramid] High-resolution path: {zarrurl_highres}\")\n\n    # Lazily load highest-resolution data\n    data_highres = da.from_zarr(zarrurl_highres)\n    logger.info(f\"[build_pyramid] High-resolution data: {str(data_highres)}\")\n\n    # Check the number of axes and identify YX dimensions\n    ndims = len(data_highres.shape)\n    if ndims not in [2, 3, 4]:\n        raise ValueError(f\"{data_highres.shape=}, ndims not in [2,3,4]\")\n    y_axis = ndims - 2\n    x_axis = ndims - 1\n\n    # Set aggregation_function\n    if aggregation_function is None:\n        aggregation_function = np.mean\n\n    # Compute and write lower-resolution levels\n    previous_level = data_highres\n    for ind_level in range(1, num_levels):\n        # Verify that coarsening is doable\n        if min(previous_level.shape[-2:]) &lt; coarsening_xy:\n            raise ValueError(\n                f\"ERROR: at {ind_level}-th level, \"\n                f\"coarsening_xy={coarsening_xy} \"\n                f\"but previous level has shape {previous_level.shape}\"\n            )\n        # Apply coarsening\n        newlevel = da.coarsen(\n            aggregation_function,\n            previous_level,\n            {y_axis: coarsening_xy, x_axis: coarsening_xy},\n            trim_excess=True,\n        ).astype(data_highres.dtype)\n\n        # Apply rechunking\n        if chunksize is None:\n            newlevel_rechunked = newlevel\n        else:\n            newlevel_rechunked = newlevel.rechunk(chunksize)\n        logger.info(\n            f\"[build_pyramid] Level {ind_level} data: \"\n            f\"{str(newlevel_rechunked)}\"\n        )\n\n        if open_array_kwargs is None:\n            open_array_kwargs = {}\n\n        # If overwrite is false, check that the array doesn't exist yet\n        if not overwrite:\n            try:\n                zarr.open(f\"{zarrurl}/{ind_level}\", mode=\"r\")\n                raise ValueError(\n                    f\"While building the pyramids, pyramid level {ind_level} \"\n                    \"already existed, but `build_pyramid` was called with \"\n                    f\"{overwrite=}.\"\n                )\n            except zarr.errors.PathNotFoundError:\n                pass\n\n        zarrarr = zarr.open(\n            f\"{zarrurl}/{ind_level}\",\n            shape=newlevel_rechunked.shape,\n            chunks=newlevel_rechunked.chunksize,\n            dtype=newlevel_rechunked.dtype,\n            mode=\"w\",\n            dimension_separator=open_array_kwargs.get(\n                \"dimension_separator\", \"/\"\n            ),\n            **open_array_kwargs,\n        )\n\n        # Write zarr and store output (useful to construct next level)\n        previous_level = newlevel_rechunked.to_zarr(\n            zarrarr,\n            overwrite=overwrite,\n            compute=True,\n            return_stored=True,\n            write_empty_chunks=False,\n            dimension_separator=open_array_kwargs.get(\n                \"dimension_separator\", \"/\"\n            ),\n        )\n</code></pre>"},{"location":"reference/fractal_tasks_core/upscale_array/","title":"upscale_array","text":"<p>Function to increase the shape of an array by replicating it.</p>"},{"location":"reference/fractal_tasks_core/upscale_array/#fractal_tasks_core.upscale_array.convert_region_to_low_res","title":"<code>convert_region_to_low_res(*, highres_region, lowres_shape, highres_shape)</code>","text":"<p>Convert a region defined for a high-resolution array to the corresponding region for a low-resolution array.</p> PARAMETER DESCRIPTION <code>highres_region</code> <p>A region of the high-resolution array, defined in a form like <code>(slice(0, 2), slice(1000, 2000), slice(1000, 2000))</code>.</p> <p> TYPE: <code>tuple[slice, ...]</code> </p> <code>highres_shape</code> <p>The shape of the high-resolution array.</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>lowres_shape</code> <p>The shape of the low-resolution array.</p> <p> TYPE: <code>tuple[int, ...]</code> </p> RETURNS DESCRIPTION <code>tuple[slice, ...]</code> <p>Region for low-resolution array.</p> Source code in <code>fractal_tasks_core/upscale_array.py</code> <pre><code>def convert_region_to_low_res(\n    *,\n    highres_region: tuple[slice, ...],\n    lowres_shape: tuple[int, ...],\n    highres_shape: tuple[int, ...],\n) -&gt; tuple[slice, ...]:\n\"\"\"\n    Convert a region defined for a high-resolution array to the corresponding\n    region for a low-resolution array.\n\n    Args:\n        highres_region: A region of the high-resolution array, defined in a\n            form like `(slice(0, 2), slice(1000, 2000), slice(1000, 2000))`.\n        highres_shape: The shape of the high-resolution array.\n        lowres_shape: The shape of the low-resolution array.\n\n    Returns:\n        Region for low-resolution array.\n    \"\"\"\n\n    error_msg = (\n        f\"Cannot convert {highres_region=}, \"\n        f\"given {lowres_shape=} and {highres_shape=}.\"\n    )\n\n    ndim = len(lowres_shape)\n    if len(highres_shape) != ndim:\n        raise ValueError(f\"{error_msg} Dimension mismatch.\")\n\n    # Loop over dimensions to construct lowres_region, after some relevant\n    # checks\n    lowres_region = []\n    for ind, lowres_size in enumerate(lowres_shape):\n        # Check that the high-resolution size is not smaller than the\n        # low-resolution size\n        highres_size = highres_shape[ind]\n        if highres_size &lt; lowres_size:\n            raise ValueError(\n                f\"{error_msg} High-res size smaller than low-res size.\"\n            )\n        # Check that sizes are commensurate\n        if highres_size % lowres_size &gt; 0:\n            raise ValueError(\n                f\"{error_msg} Incommensurable sizes \"\n                f\"{highres_size=} and {lowres_size=}.\"\n            )\n        factor = highres_size // lowres_size\n        # Convert old_slice's start/stop attributes\n        old_slice = highres_region[ind]\n        if old_slice.start % factor &gt; 0 or old_slice.stop % factor &gt; 0:\n            raise ValueError(\n                f\"{error_msg} Cannot transform {old_slice=} \"\n                f\"with {factor=}.\"\n            )\n        new_slice_start = old_slice.start // factor\n        new_slice_stop = old_slice.stop // factor\n        new_slice_step = None\n        # Covert old_slice's step attribute\n        if old_slice.step:\n            if old_slice.step % factor &gt; 0:\n                raise ValueError(\n                    f\"{error_msg} Cannot transform {old_slice=} \"\n                    f\"with {factor=}.\"\n                )\n            new_slice_step = old_slice.step // factor\n        # Append new slice\n        lowres_region.append(\n            slice(new_slice_start, new_slice_stop, new_slice_step)\n        )\n\n    return tuple(lowres_region)\n</code></pre>"},{"location":"reference/fractal_tasks_core/upscale_array/#fractal_tasks_core.upscale_array.upscale_array","title":"<code>upscale_array(*, array, target_shape, axis=None, pad_with_zeros=False, warn_if_inhomogeneous=False)</code>","text":"<p>Upscale an array along a given list of axis (through repeated application of <code>np.repeat</code>), to match a target shape.</p> PARAMETER DESCRIPTION <code>array</code> <p>The array to be upscaled.</p> <p> TYPE: <code>ndarray</code> </p> <code>target_shape</code> <p>The shape of the rescaled array.</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>axis</code> <p>The axis along which to upscale the array (if <code>None</code>, then all axis are used).</p> <p> TYPE: <code>Optional[Sequence[int]]</code> DEFAULT: <code>None</code> </p> <code>pad_with_zeros</code> <p>If <code>True</code>, pad the upscaled array with zeros to match <code>target_shape</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>warn_if_inhomogeneous</code> <p>If <code>True</code>, raise a warning when the conversion factors are not identical across all dimensions.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>The upscaled array, with shape <code>target_shape</code>.</p> Source code in <code>fractal_tasks_core/upscale_array.py</code> <pre><code>def upscale_array(\n    *,\n    array: np.ndarray,\n    target_shape: tuple[int, ...],\n    axis: Optional[Sequence[int]] = None,\n    pad_with_zeros: bool = False,\n    warn_if_inhomogeneous: bool = False,\n) -&gt; np.ndarray:\n\"\"\"\n    Upscale an array along a given list of axis (through repeated application\n    of `np.repeat`), to match a target shape.\n\n    Args:\n        array: The array to be upscaled.\n        target_shape: The shape of the rescaled array.\n        axis: The axis along which to upscale the array (if `None`, then all\n            axis are used).\n        pad_with_zeros: If `True`, pad the upscaled array with zeros to match\n            `target_shape`.\n        warn_if_inhomogeneous: If `True`, raise a warning when the conversion\n            factors are not identical across all dimensions.\n\n    Returns:\n        The upscaled array, with shape `target_shape`.\n    \"\"\"\n\n    # Default behavior: use all axis\n    if axis is None:\n        axis = list(range(len(target_shape)))\n\n    array_shape = array.shape\n    info = (\n        f\"Trying to upscale from {array_shape=} to {target_shape=}, \"\n        f\"acting on {axis=}.\"\n    )\n\n    if len(array_shape) != len(target_shape):\n        raise ValueError(f\"{info} Dimensions-number mismatch.\")\n    if axis == []:\n        raise ValueError(f\"{info} Empty axis list\")\n    if min(axis) &lt; 0:\n        raise ValueError(f\"{info} Negative axis specification not allowed.\")\n\n    # Check that upscale is doable\n    for ind, dim in enumerate(array_shape):\n        # Check that array is not larger than target (downscaling)\n        if dim &gt; target_shape[ind]:\n            raise ValueError(\n                f\"{info} {ind}-th array dimension is larger than target.\"\n            )\n        # Check that all relevant axis are included in axis\n        if dim != target_shape[ind] and ind not in axis:\n            raise ValueError(\n                f\"{info} {ind}-th array dimension differs from \"\n                f\"target, but {ind} is not included in \"\n                f\"{axis=}.\"\n            )\n\n    # Compute upscaling factors\n    upscale_factors = {}\n    for ax in axis:\n        if (target_shape[ax] % array_shape[ax]) &gt; 0 and not pad_with_zeros:\n            raise ValueError(\n                \"Incommensurable upscale attempt, \"\n                f\"from {array_shape=} to {target_shape=}.\"\n            )\n        upscale_factors[ax] = target_shape[ax] // array_shape[ax]\n        # Check that this is not downscaling\n        if upscale_factors[ax] &lt; 1:\n            raise ValueError(info)\n    info = f\"{info} Upscale factors: {upscale_factors}\"\n\n    # Raise a warning if upscaling is non-homogeneous across all axis\n    if warn_if_inhomogeneous:\n        if len(set(upscale_factors.values())) &gt; 1:\n            warnings.warn(f\"{info} (inhomogeneous)\")\n\n    # Upscale array, via np.repeat\n    upscaled_array = array\n    for ax in axis:\n        upscaled_array = np.repeat(\n            upscaled_array, upscale_factors[ax], axis=ax\n        )\n\n    # Check that final shape is correct\n    if not upscaled_array.shape == target_shape:\n        if pad_with_zeros:\n            pad_width = []\n            for ax in list(range(len(target_shape))):\n                missing = target_shape[ax] - upscaled_array.shape[ax]\n                if missing &lt; 0 or (missing &gt; 0 and ax not in axis):\n                    raise ValueError(\n                        f\"{info} \" \"Something wrong during zero-padding\"\n                    )\n                pad_width.append([0, missing])\n            upscaled_array = np.pad(\n                upscaled_array,\n                pad_width=pad_width,\n                mode=\"constant\",\n                constant_values=0,\n            )\n            logging.warning(f\"{info} {upscaled_array.shape=}.\")\n            logging.warning(\n                f\"Padding upscaled_array with zeros with {pad_width=}\"\n            )\n        else:\n            raise ValueError(f\"{info} {upscaled_array.shape=}.\")\n\n    return upscaled_array\n</code></pre>"},{"location":"reference/fractal_tasks_core/utils/","title":"utils","text":"<p>Helper functions for operations on Zarr attributes and OME-NGFF metadata.</p>"},{"location":"reference/fractal_tasks_core/utils/#fractal_tasks_core.utils._find_omengff_acquisition","title":"<code>_find_omengff_acquisition(image_zarr_path)</code>","text":"<p>Discover the acquisition index based on OME-NGFF metadata.</p> <p>Given the path to a zarr image folder (e.g. <code>/path/plate.zarr/B/03/0</code>), extract the acquisition index from the <code>.zattrs</code> file of the parent folder (i.e. at the well level), or return <code>None</code> if acquisition is not specified.</p> <p>Notes:</p> <ol> <li>For non-multiplexing datasets, acquisition is not a required    information in the metadata. If it is not there, this function    returns <code>None</code>.</li> <li>This function fails if we use an image that does not belong to    an OME-NGFF well.</li> </ol> PARAMETER DESCRIPTION <code>image_zarr_path</code> <p>Full path to an OME-NGFF image folder.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>fractal_tasks_core/utils.py</code> <pre><code>def _find_omengff_acquisition(image_zarr_path: Path) -&gt; Union[int, None]:\n\"\"\"\n    Discover the acquisition index based on OME-NGFF metadata.\n\n    Given the path to a zarr image folder (e.g. `/path/plate.zarr/B/03/0`),\n    extract the acquisition index from the `.zattrs` file of the parent\n    folder (i.e. at the well level), or return `None` if acquisition is not\n    specified.\n\n    Notes:\n\n    1. For non-multiplexing datasets, acquisition is not a required\n       information in the metadata. If it is not there, this function\n       returns `None`.\n    2. This function fails if we use an image that does not belong to\n       an OME-NGFF well.\n\n    Args:\n        image_zarr_path: Full path to an OME-NGFF image folder.\n    \"\"\"\n\n    # Identify well path and attrs\n    well_zarr_path = image_zarr_path.parent\n    if not (well_zarr_path / \".zattrs\").exists():\n        raise ValueError(\n            f\"{str(well_zarr_path)} must be an OME-NGFF well \"\n            \"folder, but it does not include a .zattrs file.\"\n        )\n    well_group = zarr.open_group(str(well_zarr_path))\n    attrs_images = well_group.attrs[\"well\"][\"images\"]\n\n    # Loook for the acquisition of the current image (if any)\n    acquisition = None\n    for img_dict in attrs_images:\n        if (\n            img_dict[\"path\"] == image_zarr_path.name\n            and \"acquisition\" in img_dict.keys()\n        ):\n            acquisition = img_dict[\"acquisition\"]\n            break\n\n    return acquisition\n</code></pre>"},{"location":"reference/fractal_tasks_core/utils/#fractal_tasks_core.utils._get_table_path_dict","title":"<code>_get_table_path_dict(zarr_url)</code>","text":"<p>Compile dictionary of (table name, table path) key/value pairs.</p> PARAMETER DESCRIPTION <code>zarr_url</code> <p>Path or url to the individual OME-Zarr image to be processed.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict[str, str]</code> <p>Dictionary with table names as keys and table paths as values. If <code>tables</code> Zarr group is missing, or if it does not have a <code>tables</code> key, then return an empty dictionary.</p> Source code in <code>fractal_tasks_core/utils.py</code> <pre><code>def _get_table_path_dict(zarr_url: str) -&gt; dict[str, str]:\n\"\"\"\n    Compile dictionary of (table name, table path) key/value pairs.\n\n\n    Args:\n        zarr_url:\n            Path or url to the individual OME-Zarr image to be processed.\n\n    Returns:\n        Dictionary with table names as keys and table paths as values. If\n            `tables` Zarr group is missing, or if it does not have a `tables`\n            key, then return an empty dictionary.\n    \"\"\"\n\n    try:\n        tables_group = zarr.open_group(f\"{zarr_url}/tables\", \"r\")\n        table_list = tables_group.attrs[\"tables\"]\n    except (zarr.errors.GroupNotFoundError, KeyError):\n        table_list = []\n\n    table_path_dict = {}\n    for table in table_list:\n        table_path_dict[table] = f\"{zarr_url}/tables/{table}\"\n\n    return table_path_dict\n</code></pre>"},{"location":"reference/fractal_tasks_core/utils/#fractal_tasks_core.utils._split_well_path_image_path","title":"<code>_split_well_path_image_path(zarr_url)</code>","text":"<p>Returns path to well folder for HCS OME-Zarr <code>zarr_url</code>.</p> Source code in <code>fractal_tasks_core/utils.py</code> <pre><code>def _split_well_path_image_path(zarr_url: str) -&gt; tuple[str, str]:\n\"\"\"\n    Returns path to well folder for HCS OME-Zarr `zarr_url`.\n    \"\"\"\n    zarr_url = zarr_url.rstrip(\"/\")\n    well_path = \"/\".join(zarr_url.split(\"/\")[:-1])\n    img_path = zarr_url.split(\"/\")[-1]\n    return well_path, img_path\n</code></pre>"},{"location":"reference/fractal_tasks_core/utils/#fractal_tasks_core.utils.create_well_acquisition_dict","title":"<code>create_well_acquisition_dict(zarr_urls)</code>","text":"<p>Parses zarr_urls &amp; groups them by HCS wells &amp; acquisition</p> <p>Generates a dict with keys a unique description of the acquisition (e.g. plate + well for HCS plates). The values are dictionaries. The keys of the secondary dictionary are the acqusitions, its values the <code>zarr_url</code> for a given acquisition.</p> PARAMETER DESCRIPTION <code>zarr_urls</code> <p>List of zarr_urls</p> <p> TYPE: <code>list[str]</code> </p> RETURNS DESCRIPTION <code>dict[str, dict[int, str]]</code> <p>image_groups</p> Source code in <code>fractal_tasks_core/utils.py</code> <pre><code>def create_well_acquisition_dict(\n    zarr_urls: list[str],\n) -&gt; dict[str, dict[int, str]]:\n\"\"\"\n    Parses zarr_urls &amp; groups them by HCS wells &amp; acquisition\n\n    Generates a dict with keys a unique description of the acquisition\n    (e.g. plate + well for HCS plates). The values are dictionaries. The keys\n    of the secondary dictionary are the acqusitions, its values the `zarr_url`\n    for a given acquisition.\n\n    Args:\n        zarr_urls: List of zarr_urls\n\n    Returns:\n        image_groups\n    \"\"\"\n    image_groups = dict()\n\n    # Dict to cache well-level metadata\n    well_metadata = dict()\n    for zarr_url in zarr_urls:\n        well_path, img_sub_path = _split_well_path_image_path(zarr_url)\n        # For the first zarr_url of a well, load the well metadata and\n        # initialize the image_groups dict\n        if well_path not in image_groups:\n            well_meta = load_NgffWellMeta(well_path)\n            well_metadata[well_path] = well_meta.well\n            image_groups[well_path] = {}\n\n        # For every zarr_url, add it under the well_path &amp; acquisition keys to\n        # the image_groups dict\n        for image in well_metadata[well_path].images:\n            if image.path == img_sub_path:\n                if image.acquisition in image_groups[well_path]:\n                    raise ValueError(\n                        \"This task has not been built for OME-Zarr HCS plates\"\n                        \"with multiple images of the same acquisition per well\"\n                        f\". {image.acquisition} is the acquisition for \"\n                        f\"multiple images in {well_path=}.\"\n                    )\n\n                image_groups[well_path][image.acquisition] = zarr_url\n    return image_groups\n</code></pre>"},{"location":"reference/fractal_tasks_core/utils/#fractal_tasks_core.utils.get_parameters_from_metadata","title":"<code>get_parameters_from_metadata(*, keys, metadata, image_zarr_path)</code>","text":"<p>Flexibly extract parameters from metadata dictionary</p> <p>This covers both parameters which are acquisition-specific (if the image belongs to an OME-NGFF array and its acquisition is specified) or simply available in the dictionary. The two cases are handled as: <pre><code>metadata[acquisition][\"some_parameter\"]  # acquisition available\nmetadata[\"some_parameter\"]               # acquisition not available\n</code></pre></p> PARAMETER DESCRIPTION <code>keys</code> <p>list of required parameters.</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>metadata</code> <p>metadata dictionary.</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>image_zarr_path</code> <p>full path to image, e.g. <code>/path/plate.zarr/B/03/0</code>.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>fractal_tasks_core/utils.py</code> <pre><code>def get_parameters_from_metadata(\n    *,\n    keys: Sequence[str],\n    metadata: dict[str, Any],\n    image_zarr_path: Path,\n) -&gt; dict[str, Any]:\n\"\"\"\n    Flexibly extract parameters from metadata dictionary\n\n    This covers both parameters which are acquisition-specific (if the image\n    belongs to an OME-NGFF array and its acquisition is specified) or simply\n    available in the dictionary.\n    The two cases are handled as:\n    ```\n    metadata[acquisition][\"some_parameter\"]  # acquisition available\n    metadata[\"some_parameter\"]               # acquisition not available\n    ```\n\n    Args:\n        keys: list of required parameters.\n        metadata: metadata dictionary.\n        image_zarr_path: full path to image, e.g. `/path/plate.zarr/B/03/0`.\n    \"\"\"\n\n    parameters = {}\n    acquisition = _find_omengff_acquisition(image_zarr_path)\n    if acquisition is not None:\n        parameters[\"acquisition\"] = acquisition\n\n    for key in keys:\n        if acquisition is None:\n            parameter = metadata[key]\n        else:\n            try:\n                parameter = metadata[key][str(acquisition)]\n            except TypeError:\n                parameter = metadata[key]\n            except KeyError:\n                parameter = metadata[key]\n        parameters[key] = parameter\n    return parameters\n</code></pre>"},{"location":"reference/fractal_tasks_core/utils/#fractal_tasks_core.utils.rescale_datasets","title":"<code>rescale_datasets(*, datasets, coarsening_xy, reference_level, remove_channel_axis=False)</code>","text":"<p>Given a set of datasets (as per OME-NGFF specs), update their \"scale\" transformations in the YX directions by including a prefactor (coarsening_xy**reference_level).</p> PARAMETER DESCRIPTION <code>datasets</code> <p>list of datasets (as per OME-NGFF specs).</p> <p> TYPE: <code>list[dict]</code> </p> <code>coarsening_xy</code> <p>linear coarsening factor between subsequent levels.</p> <p> TYPE: <code>int</code> </p> <code>reference_level</code> <p>TBD</p> <p> TYPE: <code>int</code> </p> <code>remove_channel_axis</code> <p>If <code>True</code>, remove the first item of all <code>scale</code> transformations.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>fractal_tasks_core/utils.py</code> <pre><code>def rescale_datasets(\n    *,\n    datasets: list[dict],\n    coarsening_xy: int,\n    reference_level: int,\n    remove_channel_axis: bool = False,\n) -&gt; list[dict]:\n\"\"\"\n    Given a set of datasets (as per OME-NGFF specs), update their \"scale\"\n    transformations in the YX directions by including a prefactor\n    (coarsening_xy**reference_level).\n\n    Args:\n        datasets: list of datasets (as per OME-NGFF specs).\n        coarsening_xy: linear coarsening factor between subsequent levels.\n        reference_level: TBD\n        remove_channel_axis: If `True`, remove the first item of all `scale`\n            transformations.\n    \"\"\"\n\n    # Construct rescaled datasets\n    new_datasets = []\n    for ds in datasets:\n        new_ds = {}\n\n        # Copy all keys that are not coordinateTransformations (e.g. path)\n        for key in ds.keys():\n            if key != \"coordinateTransformations\":\n                new_ds[key] = ds[key]\n\n        # Update coordinateTransformations\n        old_transformations = ds[\"coordinateTransformations\"]\n        new_transformations = []\n        for t in old_transformations:\n            if t[\"type\"] == \"scale\":\n                new_t: dict[str, Any] = t.copy()\n                # Rescale last two dimensions (that is, Y and X)\n                prefactor = coarsening_xy**reference_level\n                new_t[\"scale\"][-2] = new_t[\"scale\"][-2] * prefactor\n                new_t[\"scale\"][-1] = new_t[\"scale\"][-1] * prefactor\n                if remove_channel_axis:\n                    new_t[\"scale\"].pop(0)\n                new_transformations.append(new_t)\n            else:\n                new_transformations.append(t)\n        new_ds[\"coordinateTransformations\"] = new_transformations\n        new_datasets.append(new_ds)\n\n    return new_datasets\n</code></pre>"},{"location":"reference/fractal_tasks_core/zarr_utils/","title":"zarr_utils","text":"<p>Module with custom wrappers of the Zarr API.</p>"},{"location":"reference/fractal_tasks_core/zarr_utils/#fractal_tasks_core.zarr_utils.open_zarr_group_with_overwrite","title":"<code>open_zarr_group_with_overwrite(path, *, overwrite, logger=None, **open_group_kwargs)</code>","text":"<p>Wrap <code>zarr.open_group</code> and add <code>overwrite</code> argument.</p> <p>This wrapper sets <code>mode=\"w\"</code> for <code>overwrite=True</code> and <code>mode=\"w-\"</code> for <code>overwrite=False</code>.</p> <p>The expected behavior is</p> <ul> <li>if the group does not exist, create it (independently on <code>overwrite</code>);</li> <li>if the group already exists and <code>overwrite=True</code>, replace the group with   an empty one;</li> <li>if the group already exists and <code>overwrite=False</code>, fail.</li> </ul> <p>From the <code>zarr.open_group</code> docs:</p> <ul> <li><code>mode=\"r\"</code> means read only (must exist);</li> <li><code>mode=\"r+\"</code> means read/write (must exist);</li> <li><code>mode=\"a\"</code> means read/write (create if doesn\u2019t exist);</li> <li><code>mode=\"w\"</code> means create (overwrite if exists);</li> <li><code>mode=\"w-\"</code> means create (fail if exists).</li> </ul> PARAMETER DESCRIPTION <code>path</code> <p>Store or path to directory in file system or name of zip file (<code>zarr.open_group</code> parameter).</p> <p> TYPE: <code>Union[str, MutableMapping]</code> </p> <code>overwrite</code> <p>Determines the <code>mode</code> parameter of <code>zarr.open_group</code>, which is <code>\"w\"</code> (if <code>overwrite=True</code>) or <code>\"w-\"</code> (if <code>overwrite=False</code>).</p> <p> TYPE: <code>bool</code> </p> <code>logger</code> <p>The logger to use (if unset, use <code>logging.getLogger(None)</code>)</p> <p> TYPE: <code>Optional[Logger]</code> DEFAULT: <code>None</code> </p> <code>open_group_kwargs</code> <p>Keyword arguments of <code>zarr.open_group</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Group</code> <p>The zarr group.</p> RAISES DESCRIPTION <code>OverwriteNotAllowedError</code> <p>If <code>overwrite=False</code> and the group already exists.</p> Source code in <code>fractal_tasks_core/zarr_utils.py</code> <pre><code>def open_zarr_group_with_overwrite(\n    path: Union[str, MutableMapping],\n    *,\n    overwrite: bool,\n    logger: Optional[logging.Logger] = None,\n    **open_group_kwargs: Any,\n) -&gt; zarr.hierarchy.Group:\n\"\"\"\n    Wrap `zarr.open_group` and add `overwrite` argument.\n\n    This wrapper sets `mode=\"w\"` for `overwrite=True` and `mode=\"w-\"` for\n    `overwrite=False`.\n\n    The expected behavior is\n\n\n    * if the group does not exist, create it (independently on `overwrite`);\n    * if the group already exists and `overwrite=True`, replace the group with\n      an empty one;\n    * if the group already exists and `overwrite=False`, fail.\n\n    From the [`zarr.open_group`\n    docs](https://zarr.readthedocs.io/en/stable/api/hierarchy.html#zarr.hierarchy.open_group):\n\n    * `mode=\"r\"` means read only (must exist);\n    * `mode=\"r+\"` means read/write (must exist);\n    * `mode=\"a\"` means read/write (create if doesn\u2019t exist);\n    * `mode=\"w\"` means create (overwrite if exists);\n    * `mode=\"w-\"` means create (fail if exists).\n\n\n    Args:\n        path:\n            Store or path to directory in file system or name of zip file\n            (`zarr.open_group` parameter).\n        overwrite:\n            Determines the `mode` parameter of `zarr.open_group`, which is\n            `\"w\"` (if `overwrite=True`) or `\"w-\"` (if `overwrite=False`).\n        logger:\n            The logger to use (if unset, use `logging.getLogger(None)`)\n        open_group_kwargs:\n            Keyword arguments of `zarr.open_group`.\n\n    Returns:\n        The zarr group.\n\n    Raises:\n        OverwriteNotAllowedError:\n            If `overwrite=False` and the group already exists.\n    \"\"\"\n\n    # Set logger\n    if logger is None:\n        logger = logging.getLogger(None)\n\n    # Set mode for zarr.open_group\n    if overwrite:\n        new_mode = \"w\"\n    else:\n        new_mode = \"w-\"\n\n    # Write log about current status\n    logger.info(f\"Start open_zarr_group_with_overwrite ({overwrite=}).\")\n    try:\n        # Call `zarr.open_group` with `mode=\"r\"`, which fails for missing group\n        current_group = zarr.open_group(path, mode=\"r\")\n        keys = list(current_group.group_keys())\n        logger.info(f\"Zarr group {path} already exists, with {keys=}\")\n    except GroupNotFoundError:\n        logger.info(f\"Zarr group {path} does not exist yet.\")\n\n    # Raise warning if we are overriding an existing value of `mode`\n    if \"mode\" in open_group_kwargs.keys():\n        mode = open_group_kwargs.pop(\"mode\")\n        logger.warning(\n            f\"Overriding {mode=} with {new_mode=}, \"\n            \"in open_zarr_group_with_overwrite\"\n        )\n\n    # Call zarr.open_group\n    try:\n        return zarr.open_group(path, mode=new_mode, **open_group_kwargs)\n    except ContainsGroupError:\n        # Re-raise error with custom message and type\n        error_msg = (\n            f\"Cannot create zarr group at {path=} with `{overwrite=}` \"\n            \"(original error: `zarr.errors.ContainsGroupError`).\\n\"\n            \"Hint: try setting `overwrite=True`.\"\n        )\n        logger.error(error_msg)\n        raise OverwriteNotAllowedError(error_msg)\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/","title":"cellvoyager","text":"<p>Subpackage with utilities for tasks converting CellVoyager images to OME-Zarr.</p>"},{"location":"reference/fractal_tasks_core/cellvoyager/filenames/","title":"filenames","text":"<p>Auxiliary functions related to filenames of Yokogawa-microscope images.</p>"},{"location":"reference/fractal_tasks_core/cellvoyager/filenames/#fractal_tasks_core.cellvoyager.filenames._get_plate_name","title":"<code>_get_plate_name(plate_prefix)</code>","text":"<p>Two kinds of plate_prefix values are handled in a special way:</p> <ol> <li>Filenames from FMI, with successful barcode reading:    <code>210305NAR005AAN_210416_164828</code> with plate name <code>210305NAR005AAN</code>;</li> <li>Filenames from FMI, with failed barcode reading:    <code>yymmdd_hhmmss_210416_164828</code> with plate name <code>RS{yymmddhhmmss}</code>.</li> </ol> <p>For all non-matching filenames, plate name is <code>plate_prefix</code>.</p> PARAMETER DESCRIPTION <code>plate_prefix</code> <p>TBD</p> <p> TYPE: <code>str</code> </p> Source code in <code>fractal_tasks_core/cellvoyager/filenames.py</code> <pre><code>def _get_plate_name(plate_prefix: str) -&gt; str:\n\"\"\"\n    Two kinds of plate_prefix values are handled in a special way:\n\n    1. Filenames from FMI, with successful barcode reading:\n       `210305NAR005AAN_210416_164828` with plate name `210305NAR005AAN`;\n    2. Filenames from FMI, with failed barcode reading:\n       `yymmdd_hhmmss_210416_164828` with plate name `RS{yymmddhhmmss}`.\n\n    For all non-matching filenames, plate name is `plate_prefix`.\n\n    Args:\n        plate_prefix: TBD\n    \"\"\"\n\n    fields = plate_prefix.split(\"_\")\n\n    # FMI (successful barcode reading)\n    if (\n        len(fields) == 3\n        and len(fields[1]) == 6\n        and len(fields[2]) == 6\n        and fields[1].isdigit()\n        and fields[2].isdigit()\n    ):\n        barcode, img_date, img_time = fields[:]\n        plate = barcode\n    # FMI (failed barcode reading)\n    elif (\n        len(fields) == 4\n        and len(fields[0]) == 6\n        and len(fields[1]) == 6\n        and len(fields[2]) == 6\n        and len(fields[3]) == 6\n        and fields[0].isdigit()\n        and fields[1].isdigit()\n        and fields[2].isdigit()\n        and fields[3].isdigit()\n    ):\n        scan_date, scan_time, img_date, img_time = fields[:]\n        plate = f\"RS{scan_date + scan_time}\"\n    # All non-matching cases\n    else:\n        plate = plate_prefix\n\n    return plate\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/filenames/#fractal_tasks_core.cellvoyager.filenames.glob_with_multiple_patterns","title":"<code>glob_with_multiple_patterns(*, folder, include_patterns=None, exclude_patterns=None)</code>","text":"<p>List all the items (files and folders) in a given folder that simultaneously match a series of glob include_patterns and do not match any of the exclude_patterns.</p> PARAMETER DESCRIPTION <code>folder</code> <p>Base folder where items will be searched.</p> <p> TYPE: <code>str</code> </p> <code>include_patterns</code> <p>If specified, the list of patterns (defined as in https://docs.python.org/3/library/fnmatch.html) that item names will match with.</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>fractal_tasks_core/cellvoyager/filenames.py</code> <pre><code>def glob_with_multiple_patterns(\n    *,\n    folder: str,\n    include_patterns: Sequence[str] = None,\n    exclude_patterns: Sequence[str] = None,\n) -&gt; set[str]:\n\"\"\"\n    List all the items (files and folders) in a given folder that\n    simultaneously match a series of glob include_patterns and do not match\n    any of the exclude_patterns.\n\n    Args:\n        folder: Base folder where items will be searched.\n        include_patterns: If specified, the list of patterns (defined as in\n            https://docs.python.org/3/library/fnmatch.html) that item\n            names will match with.\n    \"\"\"\n    # Sanitize base-folder path\n    if folder.endswith(\"/\"):\n        actual_folder = folder[:-1]\n    else:\n        actual_folder = folder[:]\n\n    # If not pattern is specified, look for *all* items in the base folder\n    if not include_patterns:\n        include_patterns = [\"*\"]\n    if not exclude_patterns:\n        exclude_patterns = []\n\n    # Combine multiple glob searches (via set intersection)\n    logging.info(f\"[glob_with_multiple_patterns] {include_patterns=}\")\n    items = None\n    for pattern in include_patterns:\n        new_matches = glob(f\"{actual_folder}/{pattern}\")\n        if items is None:\n            items = set(new_matches)\n        else:\n            items = items.intersection(new_matches)\n    items = items or set()\n\n    # Combine all exclude patterns\n    exclude_items = set()\n    for pattern in exclude_patterns:\n        new_matches = glob(f\"{actual_folder}/{pattern}\")\n        if len(exclude_items) == 0:\n            exclude_items = set(new_matches)\n        else:\n            exclude_items.update(new_matches)\n    exclude_items = exclude_items or set()\n\n    # Remove exclude_items from included list\n    consensus_items = items - exclude_items\n\n    logging.info(\n        f\"[glob_with_multiple_patterns] Found {len(consensus_items)} items\"\n    )\n\n    return consensus_items\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/filenames/#fractal_tasks_core.cellvoyager.filenames.parse_filename","title":"<code>parse_filename(filename)</code>","text":"<p>Parse image metadata from filename.</p> PARAMETER DESCRIPTION <code>filename</code> <p>Name of the image.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict[str, str]</code> <p>Metadata dictionary.</p> Source code in <code>fractal_tasks_core/cellvoyager/filenames.py</code> <pre><code>def parse_filename(filename: str) -&gt; dict[str, str]:\n\"\"\"\n    Parse image metadata from filename.\n\n    Args:\n        filename: Name of the image.\n\n    Returns:\n        Metadata dictionary.\n    \"\"\"\n\n    # Remove extension and folder from filename\n    filename = Path(filename).with_suffix(\"\").name\n\n    output = {}\n\n    # Split filename into plate_prefix + well + TFLAZC\n    filename_fields = filename.split(\"_\")\n    if len(filename_fields) &lt; 3:\n        raise ValueError(f\"{filename} not valid\")\n    output[\"plate_prefix\"] = \"_\".join(filename_fields[:-2])\n    output[\"plate\"] = _get_plate_name(output[\"plate_prefix\"])\n\n    # Assign well\n    output[\"well\"] = filename_fields[-2]\n\n    # Assign TFLAZC\n    TFLAZC = filename_fields[-1]\n    metadata = re.split(r\"([0-9]+)\", TFLAZC)\n    if metadata[-1] != \"\" or len(metadata) != 13:\n        raise ValueError(f\"Something wrong with {filename=}, {TFLAZC=}\")\n    # Remove 13-th (and last) element of the metadata list (an empty string)\n    metadata = metadata[:-1]\n    # Fill output dictionary\n    for ind, key in enumerate(metadata[::2]):\n        value = metadata[2 * ind + 1]\n        if key.isdigit() or not value.isdigit():\n            raise ValueError(\n                f\"Something wrong with {filename=}, for {key=} {value=}\"\n            )\n        output[key] = value\n    return output\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/metadata/","title":"metadata","text":"<p>Functions to create a metadata dataframe from Yokogawa files.</p>"},{"location":"reference/fractal_tasks_core/cellvoyager/metadata/#fractal_tasks_core.cellvoyager.metadata._create_well_ids","title":"<code>_create_well_ids(row_series, col_series, plate_type)</code>","text":"<p>Create well_id list from XML metadata</p> <p>Handles the conversion of Cellvoyager XML metadata into well indentifiers. Returns well identifiers like A01, B02 etc. for 96 &amp; 384 well plates. Returns well identifiers like A01.a1, A01.b2 etc. for 1536 well plates. Defaults to the processing used for 96 &amp; 384 well plates, unless the plate_type is 1536. For 1536 well plates, the first 4x4 wells go into A01.a1 - A01.d4 and so on.</p> PARAMETER DESCRIPTION <code>row_series</code> <p>Series with index being the index of the image and the value the row position (starting at 1 for top left).</p> <p> TYPE: <code>Series</code> </p> <code>col_series</code> <p>Series with index being the index of the image and the value the col position (starting at 1 for top left).</p> <p> TYPE: <code>Series</code> </p> <code>plate_type</code> <p>Number of wells in the plate layout. Used to determine whether it's a 1536 well plate or a different layout.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>list of well_ids</p> Source code in <code>fractal_tasks_core/cellvoyager/metadata.py</code> <pre><code>def _create_well_ids(\n    row_series: pd.Series,\n    col_series: pd.Series,\n    plate_type: int,\n) -&gt; list[str]:\n\"\"\"\n    Create well_id list from XML metadata\n\n    Handles the conversion of Cellvoyager XML metadata into well indentifiers.\n    Returns well identifiers like A01, B02 etc. for 96 &amp; 384 well plates.\n    Returns well identifiers like A01.a1, A01.b2 etc. for 1536 well plates.\n    Defaults to the processing used for 96 &amp; 384 well plates, unless the\n    plate_type is 1536. For 1536 well plates, the first 4x4 wells go into\n    A01.a1 - A01.d4 and so on.\n\n    Args:\n        row_series: Series with index being the index of the image and the\n            value the row position (starting at 1 for top left).\n        col_series: Series with index being the index of the image and the\n            value the col position (starting at 1 for top left).\n        plate_type: Number of wells in the plate layout. Used to determine\n            whether it's a 1536 well plate or a different layout.\n\n    Returns:\n        list of well_ids\n\n    \"\"\"\n    if plate_type == 1536:\n        # Row are built of a base letter (matching to the 96 well plate layout)\n        # and a sub letter (position of the 1536 well within the 4x4 grid,\n        # can be a-d) of that well\n        row_base = [chr(math.floor((x - 1) / 4) + 65) for x in (row_series)]\n        row_sub = [chr((x - 1) % 4 + 97) for x in (row_series)]\n        # Columns are built of a base number (matching to the 96 well plate\n        # layout) and a sub integer (position of the 1536 well within the\n        # 4x4 grid, can be 1-4) of that well\n        col_base = [math.floor((x - 1) / 4) + 1 for x in col_series]\n        col_sub = [(x - 1) % 4 + 1 for x in col_series]\n        well_ids = []\n        for i in range(len(row_base)):\n            well_ids.append(\n                f\"{row_base[i]}{col_base[i]:02}.{row_sub[i]}{col_sub[i]}\"\n            )\n    else:\n        row_str = [chr(x) for x in (row_series + 64)]\n        well_ids = [f\"{a}{b:02}\" for a, b in zip(row_str, col_series)]\n\n    return well_ids\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/metadata/#fractal_tasks_core.cellvoyager.metadata.calculate_steps","title":"<code>calculate_steps(site_series)</code>","text":"<p>TBD</p> PARAMETER DESCRIPTION <code>site_series</code> <p>TBD</p> <p> TYPE: <code>Series</code> </p> Source code in <code>fractal_tasks_core/cellvoyager/metadata.py</code> <pre><code>def calculate_steps(site_series: pd.Series):\n\"\"\"\n    TBD\n\n    Args:\n        site_series: TBD\n    \"\"\"\n\n    # site_series is the z_micrometer series for a given site of a given\n    # channel. This function calculates the step size in Z\n\n    # First diff is always NaN because there is nothing to compare it to\n    steps = site_series.diff().dropna().astype(float)\n    if not np.allclose(steps.iloc[0], np.array(steps)):\n        raise NotImplementedError(\n            \"When parsing the Yokogawa mlf file, some sites \"\n            \"had varying step size in Z. \"\n            \"That is not supported for the OME-Zarr parsing\"\n        )\n    return steps.mean()\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/metadata/#fractal_tasks_core.cellvoyager.metadata.check_group_consistency","title":"<code>check_group_consistency(grouped_df, message='')</code>","text":"<p>TBD</p> PARAMETER DESCRIPTION <code>grouped_df</code> <p>TBD</p> <p> TYPE: <code>DataFrame</code> </p> <code>message</code> <p>TBD</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> Source code in <code>fractal_tasks_core/cellvoyager/metadata.py</code> <pre><code>def check_group_consistency(grouped_df: pd.DataFrame, message: str = \"\"):\n\"\"\"\n    TBD\n\n    Args:\n        grouped_df: TBD\n        message: TBD\n    \"\"\"\n\n    # Check consistency in grouped df for multi-index, multi-column dataframes\n    # raises an exception if there is variability\n    diff_df = grouped_df.max() - grouped_df.min()\n    if not np.isclose(diff_df.to_numpy().sum(), 0.0):\n        raise ValueError(\n            \"During metadata parsing, a consistency check failed: \\n\"\n            f\"{message}\\n\"\n            f\"Difference dataframe: \\n{diff_df}\"\n        )\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/metadata/#fractal_tasks_core.cellvoyager.metadata.get_earliest_time_per_site","title":"<code>get_earliest_time_per_site(mlf_frame)</code>","text":"<p>TBD</p> PARAMETER DESCRIPTION <code>mlf_frame</code> <p>TBD</p> <p> TYPE: <code>DataFrame</code> </p> Source code in <code>fractal_tasks_core/cellvoyager/metadata.py</code> <pre><code>def get_earliest_time_per_site(mlf_frame: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"\n    TBD\n\n    Args:\n        mlf_frame: TBD\n    \"\"\"\n\n    # Get the time information per site\n    # Because a site will contain time information for each plane\n    # of each channel, we just return the earliest time infromation\n    # per site.\n    return pd.to_datetime(\n        mlf_frame.groupby([\"well_id\", \"FieldIndex\"]).min()[\"Time\"], utc=True\n    )\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/metadata/#fractal_tasks_core.cellvoyager.metadata.get_z_steps","title":"<code>get_z_steps(mlf_frame)</code>","text":"<p>TBD</p> PARAMETER DESCRIPTION <code>mlf_frame</code> <p>TBD</p> <p> TYPE: <code>DataFrame</code> </p> Source code in <code>fractal_tasks_core/cellvoyager/metadata.py</code> <pre><code>def get_z_steps(mlf_frame: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"\n    TBD\n\n    Args:\n        mlf_frame: TBD\n    \"\"\"\n\n    # Process mlf_frame to extract Z information (pixel size &amp; steps).\n    # Run checks on consistencies &amp; return site-based z step dataframe\n    # Group by well, field &amp; channel\n    grouped_sites_z = (\n        mlf_frame.loc[\n            :,\n            [\"well_id\", \"FieldIndex\", \"ActionIndex\", \"Ch\", \"Z\"],\n        ]\n        .set_index([\"well_id\", \"FieldIndex\", \"ActionIndex\", \"Ch\"])\n        .groupby(level=[0, 1, 2, 3])\n    )\n\n    # If there is only 1 Z step, set the Z spacing to the count of planes =&gt; 1\n    if grouped_sites_z.count()[\"Z\"].max() == 1:\n        z_data = grouped_sites_z.count().groupby([\"well_id\", \"FieldIndex\"])\n    else:\n        # Group the whole site (combine channels), because Z steps need to be\n        # consistent between channels for OME-Zarr.\n        z_data = grouped_sites_z.apply(calculate_steps).groupby(\n            [\"well_id\", \"FieldIndex\"]\n        )\n\n    check_group_consistency(\n        z_data, message=\"Comparing Z steps between channels\"\n    )\n\n    # Ensure that channels have the same number of z planes and\n    # reduce it to one value.\n    # Only check if there is more than one channel available\n    if any(\n        grouped_sites_z.count().groupby([\"well_id\", \"FieldIndex\"]).count() &gt; 1\n    ):\n        check_group_consistency(\n            grouped_sites_z.count().groupby([\"well_id\", \"FieldIndex\"]),\n            message=\"Checking number of Z steps between channels\",\n        )\n\n    z_steps = (\n        grouped_sites_z.count()\n        .groupby([\"well_id\", \"FieldIndex\"])\n        .mean()\n        .astype(int)\n    )\n\n    # Combine the two dataframes\n    z_frame = pd.concat([z_data.mean(), z_steps], axis=1)\n    z_frame.columns = [\"pixel_size_z\", \"z_pixel\"]\n    return z_frame\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/metadata/#fractal_tasks_core.cellvoyager.metadata.parse_yokogawa_metadata","title":"<code>parse_yokogawa_metadata(mrf_path, mlf_path, *, include_patterns=None, exclude_patterns=None)</code>","text":"<p>Parse Yokogawa CV7000 metadata files and prepare site-level metadata.</p> PARAMETER DESCRIPTION <code>mrf_path</code> <p>Full path to MeasurementDetail.mrf metadata file.</p> <p> TYPE: <code>Union[str, Path]</code> </p> <code>mlf_path</code> <p>Full path to MeasurementData.mlf metadata file.</p> <p> TYPE: <code>Union[str, Path]</code> </p> <code>include_patterns</code> <p>List of patterns to filter the image filenames in the mlf metadata table. Patterns must be defined as in https://docs.python.org/3/library/fnmatch.html</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> <code>exclude_patterns</code> <p>List of exclusion patterns. Any file matching any of those patterns is excluded. Patterns must be defined as in https://docs.python.org/3/library/fnmatch.html</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> Source code in <code>fractal_tasks_core/cellvoyager/metadata.py</code> <pre><code>def parse_yokogawa_metadata(\n    mrf_path: Union[str, Path],\n    mlf_path: Union[str, Path],\n    *,\n    include_patterns: Optional[list[str]] = None,\n    exclude_patterns: Optional[list[str]] = None,\n) -&gt; tuple[pd.DataFrame, dict[str, int]]:\n\"\"\"\n    Parse Yokogawa CV7000 metadata files and prepare site-level metadata.\n\n    Args:\n        mrf_path: Full path to MeasurementDetail.mrf metadata file.\n        mlf_path: Full path to MeasurementData.mlf metadata file.\n        include_patterns: List of patterns to filter the image filenames in\n            the mlf metadata table. Patterns must be defined as in\n            https://docs.python.org/3/library/fnmatch.html\n        exclude_patterns: List of exclusion patterns. Any file matching any\n            of those patterns is excluded. Patterns must be defined as in\n            https://docs.python.org/3/library/fnmatch.html\n    \"\"\"\n\n    # Convert paths to strings\n    mrf_str = Path(mrf_path).as_posix()\n    mlf_str = Path(mlf_path).as_posix()\n\n    # Ensure mrf &amp; mlf files exist\n    if not Path(mrf_str).exists() and not Path(mlf_str).exists():\n        raise FileNotFoundError(\n            \"Could not find the mlf &amp; mrf metadata files. Expected to find \"\n            \"them at: \\n\"\n            f\"{mrf_str=}\\n\"\n            f\"{mlf_str=}\"\n        )\n\n    mrf_frame, mlf_frame, error_count = read_metadata_files(\n        mrf_str,\n        mlf_str,\n        include_patterns=include_patterns,\n        exclude_patterns=exclude_patterns,\n    )\n\n    # Aggregate information from the mlf file\n    per_site_parameters = [\"X\", \"Y\"]\n\n    grouping_params = [\"well_id\", \"FieldIndex\"]\n    grouped_sites = mlf_frame.loc[\n        :, grouping_params + per_site_parameters\n    ].groupby(by=grouping_params)\n\n    check_group_consistency(grouped_sites, message=\"X &amp; Y stage positions\")\n    site_metadata = grouped_sites.mean()\n    site_metadata.columns = [\"x_micrometer\", \"y_micrometer\"]\n    site_metadata[\"z_micrometer\"] = 0\n\n    site_metadata = pd.concat(\n        [\n            site_metadata,\n            get_z_steps(mlf_frame),\n            get_earliest_time_per_site(mlf_frame),\n        ],\n        axis=1,\n    )\n\n    # Aggregate information from the mrf file\n    mrf_columns = [\n        \"HorizontalPixelDimension\",\n        \"VerticalPixelDimension\",\n        \"HorizontalPixels\",\n        \"VerticalPixels\",\n        \"InputBitDepth\",\n    ]\n    check_group_consistency(\n        mrf_frame.loc[:, mrf_columns], message=\"Image dimensions\"\n    )\n    site_metadata[\"pixel_size_x\"] = mrf_frame.loc[\n        :, \"HorizontalPixelDimension\"\n    ].max()\n    site_metadata[\"pixel_size_y\"] = mrf_frame.loc[\n        :, \"VerticalPixelDimension\"\n    ].max()\n    site_metadata[\"x_pixel\"] = int(mrf_frame.loc[:, \"HorizontalPixels\"].max())\n    site_metadata[\"y_pixel\"] = int(mrf_frame.loc[:, \"VerticalPixels\"].max())\n    site_metadata[\"bit_depth\"] = int(mrf_frame.loc[:, \"InputBitDepth\"].max())\n\n    if error_count &gt; 0:\n        logger.info(\n            f\"There were {error_count} ERR entries in the metadatafile. \"\n            f\"Still succesfully parsed {len(site_metadata)} sites. \"\n        )\n\n    # Compute expected number of image files for each well\n    list_of_wells = set(site_metadata.index.get_level_values(\"well_id\"))\n    number_of_files = {}\n    for this_well_id in list_of_wells:\n        num_images = (mlf_frame.well_id == this_well_id).sum()\n        logger.info(\n            f\"Expected number of images for well {this_well_id}: {num_images}\"\n        )\n        number_of_files[this_well_id] = num_images\n    # Check that the sum of per-well file numbers correspond to the total\n    # file number\n    if not sum(number_of_files.values()) == len(mlf_frame):\n        raise ValueError(\n            \"Error while counting the number of image files per well.\\n\"\n            f\"{len(mlf_frame)=}\\n\"\n            f\"{number_of_files=}\"\n        )\n\n    return site_metadata, number_of_files\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/metadata/#fractal_tasks_core.cellvoyager.metadata.read_metadata_files","title":"<code>read_metadata_files(mrf_path, mlf_path, include_patterns=None, exclude_patterns=None)</code>","text":"<p>Create tables for mrf &amp; mlf Yokogawa metadata.</p> PARAMETER DESCRIPTION <code>mrf_path</code> <p>Full path to MeasurementDetail.mrf metadata file.</p> <p> TYPE: <code>str</code> </p> <code>mlf_path</code> <p>Full path to MeasurementData.mlf metadata file.</p> <p> TYPE: <code>str</code> </p> <code>include_patterns</code> <p>List of patterns to filter the image filenames in the mlf metadata table. Patterns must be defined as in https://docs.python.org/3/library/fnmatch.html</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> <code>exclude_patterns</code> <p>List of exclusion patterns. Any file matching any of those patterns is excluded. Patterns must be defined as in https://docs.python.org/3/library/fnmatch.html</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> <p>Returns:</p> Source code in <code>fractal_tasks_core/cellvoyager/metadata.py</code> <pre><code>def read_metadata_files(\n    mrf_path: str,\n    mlf_path: str,\n    include_patterns: Optional[list[str]] = None,\n    exclude_patterns: Optional[list[str]] = None,\n) -&gt; tuple[pd.DataFrame, pd.DataFrame, int]:\n\"\"\"\n    Create tables for mrf &amp; mlf Yokogawa metadata.\n\n    Args:\n        mrf_path: Full path to MeasurementDetail.mrf metadata file.\n        mlf_path: Full path to MeasurementData.mlf metadata file.\n        include_patterns: List of patterns to filter the image filenames in\n            the mlf metadata table. Patterns must be defined as in\n            https://docs.python.org/3/library/fnmatch.html\n        exclude_patterns: List of exclusion patterns. Any file matching any\n            of those patterns is excluded. Patterns must be defined as in\n            https://docs.python.org/3/library/fnmatch.html\n\n    Returns:\n\n    \"\"\"\n\n    # parsing of mrf &amp; mlf files are based on the\n    # yokogawa_image_collection_task v0.5 in drogon, written by Dario Vischi.\n    # https://github.com/fmi-basel/job-system-workflows/blob/00bbf34448972d27f258a2c28245dd96180e8229/src/gliberal_workflows/tasks/yokogawa_image_collection_task/versions/version_0_5.py  # noqa\n    # Now modified for Fractal use\n\n    mrf_frame, plate_type = read_mrf_file(mrf_path)\n\n    # filter_position &amp; filter_wheel_position are parsed, but not\n    # processed further. Figure out how to save them as relevant metadata for\n    # use e.g. during illumination correction\n\n    mlf_frame, error_count = read_mlf_file(\n        mlf_path,\n        plate_type,\n        include_patterns=include_patterns,\n        exclude_patterns=exclude_patterns,\n    )\n\n    # Filter the mrf channel dataframe to only keep channels that were imaged\n    # and are included in the filters (see issue #287)\n    relevant_channels = mlf_frame[\"Ch\"].unique()\n    mrf_frame = mrf_frame[mrf_frame[\"Ch\"].isin(relevant_channels)]\n\n    # Time points are parsed as part of the mlf_frame, but currently not\n    # processed further. Once we tackle time-resolved data, parse from here.\n\n    return mrf_frame, mlf_frame, error_count\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/metadata/#fractal_tasks_core.cellvoyager.metadata.read_mlf_file","title":"<code>read_mlf_file(mlf_path, plate_type, include_patterns=None, exclude_patterns=None)</code>","text":"<p>Process the mlf metadata file of a Cellvoyager CV7K/CV8K.</p> PARAMETER DESCRIPTION <code>mlf_path</code> <p>Full path to MeasurementData.mlf metadata file.</p> <p> TYPE: <code>str</code> </p> <code>plate_type</code> <p>Plate layout, integer for the number of potential wells.</p> <p> TYPE: <code>int</code> </p> <code>include_patterns</code> <p>List of patterns to filter the image filenames in the mlf metadata table. Patterns must be defined as in https://docs.python.org/3/library/fnmatch.html</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> <code>exclude_patterns</code> <p>List of exclusion patterns. Any file matching any of those patterns is excluded. Patterns must be defined as in https://docs.python.org/3/library/fnmatch.html</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>mlf_frame</code> <p>pd.DataFrame with relevant metadata per image</p> <p> TYPE: <code>DataFrame</code> </p> <code>error_count</code> <p>Count of errors found during metadata processing</p> <p> TYPE: <code>int</code> </p> Source code in <code>fractal_tasks_core/cellvoyager/metadata.py</code> <pre><code>def read_mlf_file(\n    mlf_path: str,\n    plate_type: int,\n    include_patterns: Optional[list[str]] = None,\n    exclude_patterns: Optional[list[str]] = None,\n) -&gt; tuple[pd.DataFrame, int]:\n\"\"\"\n    Process the mlf metadata file of a Cellvoyager CV7K/CV8K.\n\n    Args:\n        mlf_path: Full path to MeasurementData.mlf metadata file.\n        plate_type: Plate layout, integer for the number of potential wells.\n        include_patterns: List of patterns to filter the image filenames in\n            the mlf metadata table. Patterns must be defined as in\n            https://docs.python.org/3/library/fnmatch.html\n        exclude_patterns: List of exclusion patterns. Any file matching any\n            of those patterns is excluded. Patterns must be defined as in\n            https://docs.python.org/3/library/fnmatch.html\n\n    Returns:\n        mlf_frame: pd.DataFrame with relevant metadata per image\n        error_count: Count of errors found during metadata processing\n    \"\"\"\n\n    # Load the whole MeasurementData.mlf file\n    mlf_frame_raw = pd.read_xml(mlf_path)\n\n    # Remove all rows that do not match the given patterns\n    logger.info(\n        f\"Read {mlf_path}, apply following include patterns to \"\n        f\"image filenames: {include_patterns} apply the following exlcude \"\n        f\"patterns to image filenames: {exclude_patterns}\"\n    )\n\n    if include_patterns or exclude_patterns:\n        filenames = mlf_frame_raw.MeasurementRecord\n        keep_row = None\n        exclude_row = None\n        # Include patterns\n        if include_patterns:\n            for pattern in include_patterns:\n                actual_pattern = fnmatch.translate(pattern)\n                new_matches = filenames.str.fullmatch(actual_pattern)\n                if new_matches.sum() == 0:\n                    raise ValueError(\n                        f\"In {mlf_path} there is no image filename \"\n                        f'matching \"{actual_pattern}\".'\n                    )\n                if keep_row is None:\n                    keep_row = new_matches.copy()\n                else:\n                    keep_row = keep_row &amp; new_matches\n        else:\n            # If no include pattern is specified, keep all rows\n            keep_row = pd.Series([True] * len(mlf_frame_raw))\n        # Exclude patterns\n        if exclude_patterns:\n            for pattern in exclude_patterns:\n                actual_pattern = fnmatch.translate(pattern)\n                new_matches = filenames.str.fullmatch(actual_pattern)\n                if exclude_row is None:\n                    exclude_row = new_matches.copy()\n                else:\n                    exclude_row = exclude_row | new_matches\n        else:\n            # Create an all False df =&gt; exclude nothing\n            exclude_row = pd.Series([False] * len(mlf_frame_raw))\n\n        # Combine included list with exclusions\n        keep_row = keep_row &amp; ~exclude_row\n\n        if keep_row.sum() == 0:\n            raise ValueError(\n                f\"In {mlf_path} there is no image filename \"\n                f\"matching {include_patterns} but not excluded by the pattern \"\n                f\"{exclude_patterns}.\"\n            )\n        mlf_frame_matching = mlf_frame_raw[keep_row.values].copy()\n    else:\n        mlf_frame_matching = mlf_frame_raw.copy()\n\n    # Create a well ID column\n    # Row &amp; column are provided as int from XML metadata\n    mlf_frame_matching[\"well_id\"] = _create_well_ids(\n        mlf_frame_matching[\"Row\"], mlf_frame_matching[\"Column\"], plate_type\n    )\n\n    # Flip Y axis to align to image coordinate system\n    mlf_frame_matching[\"Y\"] = -mlf_frame_matching[\"Y\"]\n\n    # Compute number or errors\n    error_count = (mlf_frame_matching[\"Type\"] == \"ERR\").sum()\n\n    # We're only interested in the image metadata\n    mlf_frame = mlf_frame_matching[mlf_frame_matching[\"Type\"] == \"IMG\"]\n\n    return mlf_frame, error_count\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/metadata/#fractal_tasks_core.cellvoyager.metadata.read_mrf_file","title":"<code>read_mrf_file(mrf_path)</code>","text":"<p>Parses the mrf metadata file</p> PARAMETER DESCRIPTION <code>mrf_path</code> <p>Full path to MeasurementDetail.mrf metadata file.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>Parsed mrf pandas table with one row per channel imaged</p> <code>int</code> <p>The plate_type: The number of wells</p> Source code in <code>fractal_tasks_core/cellvoyager/metadata.py</code> <pre><code>def read_mrf_file(mrf_path: str) -&gt; tuple[pd.DataFrame, int]:\n\"\"\"\n    Parses the mrf metadata file\n\n    Args:\n        mrf_path: Full path to MeasurementDetail.mrf metadata file.\n\n    Returns:\n        Parsed mrf pandas table with one row per channel imaged\n        The plate_type: The number of wells\n    \"\"\"\n    # Define the namespaces\n    ns = {\"bts\": \"http://www.yokogawa.co.jp/BTS/BTSSchema/1.0\"}\n    channel_df = pd.read_xml(\n        mrf_path, xpath=\".//bts:MeasurementChannel\", namespaces=ns\n    )\n    meas_df = pd.read_xml(\n        mrf_path, xpath=\"//bts:MeasurementDetail\", namespaces=ns\n    )\n    row_count = int(meas_df[\"RowCount\"].iloc[0])\n    column_count = int(meas_df[\"ColumnCount\"].iloc[0])\n    plate_type = row_count * column_count\n    return channel_df, plate_type\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/metadata/#fractal_tasks_core.cellvoyager.metadata.sanitize_string","title":"<code>sanitize_string(value)</code>","text":"<p>Make string safe to be used in file/folder names.</p> <p>Replace any special character with an underscore, where special characters are:</p> <pre><code>&gt;&gt;&gt; string.punctuation\n'!\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~'\n&gt;&gt;&gt; string.whitespace\n' \\t\\n\\r\\x0b\\x0c'\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p>Input string</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Sanitized value</p> Source code in <code>fractal_tasks_core/cellvoyager/metadata.py</code> <pre><code>def sanitize_string(value: str) -&gt; str:\n\"\"\"\n    Make string safe to be used in file/folder names.\n\n    Replace any special character with an\n    underscore, where special characters are:\n\n\n        &gt;&gt;&gt; string.punctuation\n        '!\"#$%&amp;\\'()*+,-./:;&lt;=&gt;?@[\\\\\\\\]^_`{|}~'\n        &gt;&gt;&gt; string.whitespace\n        ' \\\\t\\\\n\\\\r\\\\x0b\\\\x0c'\n\n    Args:\n        value: Input string\n\n    Returns:\n        Sanitized value\n    \"\"\"\n    for character in __SPECIAL_CHARACTERS__:\n        new_value = value.replace(character, \"_\")\n    return new_value\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/wells/","title":"wells","text":"<p>Functions to create a metadata dataframe from Yokogawa files.</p>"},{"location":"reference/fractal_tasks_core/cellvoyager/wells/#fractal_tasks_core.cellvoyager.wells._extract_row_col_from_well_id","title":"<code>_extract_row_col_from_well_id(well_id)</code>","text":"<p>Split well name into row &amp; column</p> <p>This function handles different patterns of well names: Classical wells in their format like B03 (row B, column 03) typically found in 96 &amp; 384 well plates from the cellvoyager microscopes. And 1536 well plates with wells like A01.a1 (row Aa, column 011).</p> PARAMETER DESCRIPTION <code>well_id</code> <p>Well name. Either formatted like <code>A03</code> (for 96 well and 384 well plates), or formatted like `A01.a1 (for 1536 well plates).</p> <p> TYPE: <code>str</code> </p> <p>Returns:     Tuple of row and column names.</p> Source code in <code>fractal_tasks_core/cellvoyager/wells.py</code> <pre><code>def _extract_row_col_from_well_id(well_id: str) -&gt; tuple[str, str]:\n\"\"\"\n    Split well name into row &amp; column\n\n    This function handles different patterns of well names: Classical wells in\n    their format like B03 (row B, column 03) typically found in 96 &amp; 384 well\n    plates from the cellvoyager microscopes. And 1536 well plates with wells\n    like A01.a1 (row Aa, column 011).\n\n    Args:\n        well_id: Well name. Either formatted like `A03` (for 96 well and 384\n            well plates), or formatted like `A01.a1 (for 1536 well plates).\n    Returns:\n        Tuple of row and column names.\n    \"\"\"\n    if len(well_id) == 3 and well_id.count(\".\") == 0:\n        return (well_id[0], well_id[1:3])\n    elif len(well_id) == 6 and well_id.count(\".\") == 1:\n        core, suffix = well_id.split(\".\")\n        row = f\"{core[0]}{suffix[0]}\"\n        col = f\"{core[1:]}{suffix[1]}\"\n        return (row, col)\n    else:\n        raise NotImplementedError(\n            f\"Processing wells like {well_id} has not been implemented. \"\n            \"This converter only handles wells like B03 or B03.a1\"\n        )\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/wells/#fractal_tasks_core.cellvoyager.wells.generate_row_col_split","title":"<code>generate_row_col_split(wells)</code>","text":"<p>Given a list of well names, construct a sorted row&amp;column list</p> <p>This function applies <code>_extract_row_col_from_well_id</code> to each <code>wells</code> element and then sorts the result.</p> PARAMETER DESCRIPTION <code>wells</code> <p>list of well names. Either formatted like [A03, B01, C03] for 96 well and 384 well plates. Or formatted like [A01.a1, A03.b2, B04.c4] for 1536 well plates.</p> <p> TYPE: <code>list[str]</code> </p> <p>Returns:     well_rows_columns: List of tuples of row &amp; col names</p> Source code in <code>fractal_tasks_core/cellvoyager/wells.py</code> <pre><code>def generate_row_col_split(wells: list[str]) -&gt; list[tuple[str, str]]:\n\"\"\"\n    Given a list of well names, construct a sorted row&amp;column list\n\n    This function applies `_extract_row_col_from_well_id` to each `wells`\n    element and then sorts the result.\n\n    Args:\n        wells: list of well names. Either formatted like [A03, B01, C03] for\n            96 well and 384 well plates. Or formatted like [A01.a1, A03.b2,\n            B04.c4] for 1536 well plates.\n    Returns:\n        well_rows_columns: List of tuples of row &amp; col names\n    \"\"\"\n    well_rows_columns = [_extract_row_col_from_well_id(well) for well in wells]\n    return sorted(well_rows_columns)\n</code></pre>"},{"location":"reference/fractal_tasks_core/cellvoyager/wells/#fractal_tasks_core.cellvoyager.wells.get_filename_well_id","title":"<code>get_filename_well_id(row, col)</code>","text":"<p>Generates the well_id as extracted from the filename from row &amp; col.</p> <p>Processes the well identifiers generated by <code>generate_row_col_split</code> for cellvoyager datasets.</p> PARAMETER DESCRIPTION <code>row</code> <p>name of the row. Typically a single letter (A, B, C) for 96 &amp; 384 well plates. And two letters (Aa, Bb, Cc) for 1536 well plates.</p> <p> TYPE: <code>str</code> </p> <code>col</code> <p>name of the column. Typically 2 digits (01, 02, 03) for 96 &amp; 384 well plates. And 3 digits (011, 012, 021) for 1536 well plates.</p> <p> TYPE: <code>str</code> </p> <p>Returns:     well_id: name of the well as it would appear in the original image         file name.</p> Source code in <code>fractal_tasks_core/cellvoyager/wells.py</code> <pre><code>def get_filename_well_id(row: str, col: str) -&gt; str:\n\"\"\"\n    Generates the well_id as extracted from the filename from row &amp; col.\n\n    Processes the well identifiers generated by `generate_row_col_split` for\n    cellvoyager datasets.\n\n    Args:\n        row: name of the row. Typically a single letter (A, B, C) for 96 &amp; 384\n            well plates. And two letters (Aa, Bb, Cc) for 1536 well plates.\n        col: name of the column. Typically 2 digits (01, 02, 03) for 96 &amp; 384\n            well plates. And 3 digits (011, 012, 021) for 1536 well plates.\n    Returns:\n        well_id: name of the well as it would appear in the original image\n            file name.\n    \"\"\"\n    if len(row) == 1 and len(col) == 2:\n        return row + col\n    elif len(row) == 2 and len(col) == 3:\n        return f\"{row[0]}{col[:2]}.{row[1]}{col[2]}\"\n    else:\n        raise NotImplementedError(\n            f\"Processing wells with {row=} &amp; {col=} has not been implemented. \"\n            \"This converter only handles wells like B03 or B03.a1\"\n        )\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/","title":"dev","text":"<p>Development-tools subpackage (e.g. for the creation of JSON Schemas for task parameters).</p>"},{"location":"reference/fractal_tasks_core/dev/create_manifest/","title":"create_manifest","text":"<p>Script to generate JSON schemas for task arguments afresh, and write them to the package manifest.</p>"},{"location":"reference/fractal_tasks_core/dev/create_manifest/#fractal_tasks_core.dev.create_manifest.create_manifest","title":"<code>create_manifest(package='fractal_tasks_core', authors=None, manifest_version='2', has_args_schemas=True, docs_link=None, custom_pydantic_models=None)</code>","text":"<p>This function creates the package manifest based on a <code>task_list.py</code> Python module located in the <code>dev</code> subfolder of the package, see an example of such list at ...</p> <p>The manifest is then written to <code>__FRACTAL_MANIFEST__.json</code>, in the main <code>package</code> directory.</p> <p>Note: a valid example of <code>custom_pydantic_models</code> would be <pre><code>[\n    (\"my_task_package\", \"some_module.py\", \"SomeModel\"),\n]\n</code></pre></p> PARAMETER DESCRIPTION <code>package</code> <p>The name of the package (must be importable).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'fractal_tasks_core'</code> </p> <code>manifest_version</code> <p>Only <code>\"2\"</code> is supported.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'2'</code> </p> <code>has_args_schemas</code> <p>Whether to autogenerate JSON Schemas for task arguments.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>custom_pydantic_models</code> <p>Custom models to be included when building JSON Schemas for task arguments.</p> <p> TYPE: <code>Optional[list[tuple[str, str, str]]]</code> DEFAULT: <code>None</code> </p> Source code in <code>fractal_tasks_core/dev/create_manifest.py</code> <pre><code>@deprecated(DEPRECATION_MSG_FUN)\ndef create_manifest(\n    package: str = \"fractal_tasks_core\",\n    authors: Optional[str] = None,\n    manifest_version: str = \"2\",\n    has_args_schemas: bool = True,\n    docs_link: Optional[str] = None,\n    custom_pydantic_models: Optional[list[tuple[str, str, str]]] = None,\n):\n\"\"\"\n    This function creates the package manifest based on a `task_list.py`\n    Python module located in the `dev` subfolder of the package, see an\n    example of such list at ...\n\n    The manifest is then written to `__FRACTAL_MANIFEST__.json`, in the\n    main `package` directory.\n\n    Note: a valid example of `custom_pydantic_models` would be\n    ```\n    [\n        (\"my_task_package\", \"some_module.py\", \"SomeModel\"),\n    ]\n    ```\n\n    Arguments:\n        package: The name of the package (must be importable).\n        manifest_version: Only `\"2\"` is supported.\n        has_args_schemas:\n            Whether to autogenerate JSON Schemas for task arguments.\n        custom_pydantic_models:\n            Custom models to be included when building JSON Schemas for task\n            arguments.\n    \"\"\"\n\n    # Preliminary check\n    if manifest_version != \"2\":\n        raise NotImplementedError(f\"{manifest_version=} is not supported\")\n\n    logging.info(\"Start generating a new manifest\")\n\n    # Prepare an empty manifest\n    manifest = dict(\n        manifest_version=manifest_version,\n        task_list=[],\n        has_args_schemas=has_args_schemas,\n    )\n    if has_args_schemas:\n        manifest[\"args_schema_version\"] = ARGS_SCHEMA_VERSION\n    if authors is not None:\n        manifest[\"authors\"] = authors\n\n    # Prepare a default value of docs_link\n    if package == \"fractal_tasks_core\" and docs_link is None:\n        docs_link = (\n            \"https://fractal-analytics-platform.github.io/fractal-tasks-core\"\n        )\n\n    # Import the task list from `dev/task_list.py`\n    task_list_module = import_module(f\"{package}.dev.task_list\")\n    TASK_LIST = getattr(task_list_module, \"TASK_LIST\")\n\n    # Loop over TASK_LIST, and append the proper task dictionary\n    # to manifest[\"task_list\"]\n    for task_obj in TASK_LIST:\n        # Convert Pydantic object to dictionary\n        task_dict = task_obj.model_dump(\n            exclude={\"meta_init\", \"executable_init\", \"meta\", \"executable\"},\n            exclude_unset=True,\n        )\n\n        # Copy some properties from `task_obj` to `task_dict`\n        if task_obj.executable_non_parallel is not None:\n            task_dict[\n                \"executable_non_parallel\"\n            ] = task_obj.executable_non_parallel\n        if task_obj.executable_parallel is not None:\n            task_dict[\"executable_parallel\"] = task_obj.executable_parallel\n        if task_obj.meta_non_parallel is not None:\n            task_dict[\"meta_non_parallel\"] = task_obj.meta_non_parallel\n        if task_obj.meta_parallel is not None:\n            task_dict[\"meta_parallel\"] = task_obj.meta_parallel\n\n        # Autogenerate JSON Schemas for non-parallel/parallel task arguments\n        if has_args_schemas:\n            for kind in [\"non_parallel\", \"parallel\"]:\n                executable = task_dict.get(f\"executable_{kind}\")\n                if executable is not None:\n                    logging.info(f\"[{executable}] START\")\n                    schema = create_schema_for_single_task(\n                        executable,\n                        package=package,\n                        custom_pydantic_models=custom_pydantic_models,\n                    )\n                    logging.info(f\"[{executable}] END (new schema)\")\n                    task_dict[f\"args_schema_{kind}\"] = schema\n\n        # Update docs_info, based on task-function description\n        docs_info = task_dict.get(\"docs_info\")\n        if docs_info is None:\n            docs_info = create_docs_info(\n                executable_non_parallel=task_obj.executable_non_parallel,\n                executable_parallel=task_obj.executable_parallel,\n                package=package,\n            )\n        elif docs_info.startswith(\"file:\"):\n            docs_info = read_docs_info_from_file(\n                docs_info=docs_info,\n                task_list_path=task_list_module.__file__,\n            )\n\n        if docs_info is not None:\n            task_dict[\"docs_info\"] = docs_info\n        if docs_link is not None:\n            task_dict[\"docs_link\"] = docs_link\n\n        manifest[\"task_list\"].append(task_dict)\n        print()\n\n    # Write manifest\n    imported_package = import_module(package)\n    manifest_path = (\n        Path(imported_package.__file__).parent / \"__FRACTAL_MANIFEST__.json\"\n    )\n    with manifest_path.open(\"w\") as f:\n        json.dump(manifest, f, indent=2)\n        f.write(\"\\n\")\n    logging.info(f\"Manifest stored in {manifest_path.as_posix()}\")\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/deprecation_message/","title":"deprecation_message","text":""},{"location":"reference/fractal_tasks_core/dev/lib_args_schemas/","title":"lib_args_schemas","text":"<p>Helper functions to handle JSON schemas for task arguments.</p>"},{"location":"reference/fractal_tasks_core/dev/lib_args_schemas/#fractal_tasks_core.dev.lib_args_schemas._remove_attributes_from_descriptions","title":"<code>_remove_attributes_from_descriptions(old_schema)</code>","text":"<p>Keeps only the description part of the docstrings: e.g from <pre><code>'Custom class for Omero-channel window, based on OME-NGFF v0.4.\\n'\n'\\n'\n'Attributes:\\n'\n'min: Do not change. It will be set to `0` by default.\\n'\n'max: Do not change. It will be set according to bitdepth of the images\\n'\n'    by default (e.g. 65535 for 16 bit images).\\n'\n'start: Lower-bound rescaling value for visualization.\\n'\n'end: Upper-bound rescaling value for visualization.'\n</code></pre> to <code>'Custom class for Omero-channel window, based on OME-NGFF v0.4.\\n'</code>.</p> PARAMETER DESCRIPTION <code>old_schema</code> <p>TBD</p> <p> TYPE: <code>_Schema</code> </p> Source code in <code>fractal_tasks_core/dev/lib_args_schemas.py</code> <pre><code>def _remove_attributes_from_descriptions(old_schema: _Schema) -&gt; _Schema:\n\"\"\"\n    Keeps only the description part of the docstrings: e.g from\n    ```\n    'Custom class for Omero-channel window, based on OME-NGFF v0.4.\\\\n'\n    '\\\\n'\n    'Attributes:\\\\n'\n    'min: Do not change. It will be set to `0` by default.\\\\n'\n    'max: Do not change. It will be set according to bitdepth of the images\\\\n'\n    '    by default (e.g. 65535 for 16 bit images).\\\\n'\n    'start: Lower-bound rescaling value for visualization.\\\\n'\n    'end: Upper-bound rescaling value for visualization.'\n    ```\n    to `'Custom class for Omero-channel window, based on OME-NGFF v0.4.\\\\n'`.\n\n    Args:\n        old_schema: TBD\n    \"\"\"\n    new_schema = old_schema.copy()\n    if \"$defs\" in new_schema:\n        for name, definition in new_schema[\"$defs\"].items():\n            if \"description\" in definition.keys():\n                parsed_docstring = docparse(definition[\"description\"])\n                new_schema[\"$defs\"][name][\n                    \"description\"\n                ] = parsed_docstring.short_description\n            elif \"title\" in definition.keys():\n                title = definition[\"title\"]\n                new_schema[\"$defs\"][name][\n                    \"description\"\n                ] = f\"Missing description for {title}.\"\n            else:\n                new_schema[\"$defs\"][name][\n                    \"description\"\n                ] = \"Missing description\"\n    logging.info(\"[_remove_attributes_from_descriptions] END\")\n    return new_schema\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_args_schemas/#fractal_tasks_core.dev.lib_args_schemas.create_schema_for_single_task","title":"<code>create_schema_for_single_task(executable, package='fractal_tasks_core', custom_pydantic_models=None, task_function=None, verbose=False)</code>","text":"<p>Main function to create a JSON Schema of task arguments</p> <p>This function can be used in two ways:</p> <ol> <li><code>task_function</code> argument is <code>None</code>, <code>package</code> is set, and <code>executable</code>     is a path relative to that package.</li> <li><code>task_function</code> argument is provided, <code>executable</code> is an absolute path     to the function module, and <code>package</code> is `None. This is useful for     testing.</li> </ol> Source code in <code>fractal_tasks_core/dev/lib_args_schemas.py</code> <pre><code>@deprecated(DEPRECATION_MSG_FUN)\ndef create_schema_for_single_task(\n    executable: str,\n    package: Optional[str] = \"fractal_tasks_core\",\n    custom_pydantic_models: Optional[list[tuple[str, str, str]]] = None,\n    task_function: Optional[Callable] = None,\n    verbose: bool = False,\n) -&gt; _Schema:\n\"\"\"\n    Main function to create a JSON Schema of task arguments\n\n    This function can be used in two ways:\n\n    1. `task_function` argument is `None`, `package` is set, and `executable`\n        is a path relative to that package.\n    2. `task_function` argument is provided, `executable` is an absolute path\n        to the function module, and `package` is `None. This is useful for\n        testing.\n    \"\"\"\n\n    DEFINITIONS_KEY = \"$defs\"\n\n    logging.info(\"[create_schema_for_single_task] START\")\n    if task_function is None:\n        usage = \"1\"\n        # Usage 1 (standard)\n        if package is None:\n            raise ValueError(\n                \"Cannot call `create_schema_for_single_task with \"\n                f\"{task_function=} and {package=}. Exit.\"\n            )\n        if os.path.isabs(executable):\n            raise ValueError(\n                \"Cannot call `create_schema_for_single_task with \"\n                f\"{task_function=} and absolute {executable=}. Exit.\"\n            )\n    else:\n        usage = \"2\"\n        # Usage 2 (testing)\n        if package is not None:\n            raise ValueError(\n                \"Cannot call `create_schema_for_single_task with \"\n                f\"{task_function=} and non-None {package=}. Exit.\"\n            )\n        if not os.path.isabs(executable):\n            raise ValueError(\n                \"Cannot call `create_schema_for_single_task with \"\n                f\"{task_function=} and non-absolute {executable=}. Exit.\"\n            )\n\n    # Extract function from module\n    if usage == \"1\":\n        # Extract the function name (for the moment we assume the function has\n        # the same name as the module)\n        function_name = Path(executable).with_suffix(\"\").name\n        # Extract the function object\n        task_function = _extract_function(\n            package_name=package,\n            module_relative_path=executable,\n            function_name=function_name,\n            verbose=verbose,\n        )\n    else:\n        # The function object is already available, extract its name\n        function_name = task_function.__name__\n\n    if verbose:\n        logging.info(f\"[create_schema_for_single_task] {function_name=}\")\n        logging.info(f\"[create_schema_for_single_task] {task_function=}\")\n\n    # Validate function signature against some custom constraints\n    _validate_function_signature(task_function)\n\n    # Create and clean up schema\n    schema = _create_schema_for_function(task_function)\n    schema = _remove_attributes_from_descriptions(schema)\n\n    # Include titles for custom-model-typed arguments\n    schema = _include_titles(\n        schema, definitions_key=DEFINITIONS_KEY, verbose=verbose\n    )\n\n    # Include main title\n    if schema.get(\"title\") is None:\n\n        def to_camel_case(snake_str):\n            return \"\".join(\n                x.capitalize() for x in snake_str.lower().split(\"_\")\n            )\n\n        schema[\"title\"] = to_camel_case(task_function.__name__)\n\n    # Include descriptions of function. Note: this function works both\n    # for usages 1 or 2 (see docstring).\n    function_args_descriptions = _get_function_args_descriptions(\n        package_name=package,\n        module_path=executable,\n        function_name=function_name,\n        verbose=verbose,\n    )\n\n    schema = _insert_function_args_descriptions(\n        schema=schema, descriptions=function_args_descriptions\n    )\n\n    # Merge lists of fractal-tasks-core and user-provided Pydantic models\n    user_provided_models = custom_pydantic_models or []\n    pydantic_models = FRACTAL_TASKS_CORE_PYDANTIC_MODELS + user_provided_models\n\n    # Check that model names are unique\n    pydantic_models_names = [item[2] for item in pydantic_models]\n    duplicate_class_names = [\n        name\n        for name, count in Counter(pydantic_models_names).items()\n        if count &gt; 1\n    ]\n    if duplicate_class_names:\n        pydantic_models_str = \"  \" + \"\\n  \".join(map(str, pydantic_models))\n        raise ValueError(\n            \"Cannot parse docstrings for models with non-unique names \"\n            f\"{duplicate_class_names}, in\\n{pydantic_models_str}\"\n        )\n\n    # Extract model-attribute descriptions and insert them into schema\n    for package_name, module_relative_path, class_name in pydantic_models:\n        attrs_descriptions = _get_class_attrs_descriptions(\n            package_name=package_name,\n            module_relative_path=module_relative_path,\n            class_name=class_name,\n        )\n        schema = _insert_class_attrs_descriptions(\n            schema=schema,\n            class_name=class_name,\n            descriptions=attrs_descriptions,\n            definition_key=DEFINITIONS_KEY,\n        )\n\n    logging.info(\"[create_schema_for_single_task] END\")\n    return schema\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_descriptions/","title":"lib_descriptions","text":""},{"location":"reference/fractal_tasks_core/dev/lib_descriptions/#fractal_tasks_core.dev.lib_descriptions._get_class_attrs_descriptions","title":"<code>_get_class_attrs_descriptions(package_name, module_relative_path, class_name)</code>","text":"<p>Extract attribute descriptions from a class.</p> PARAMETER DESCRIPTION <code>package_name</code> <p>Example <code>fractal_tasks_core</code>.</p> <p> TYPE: <code>str</code> </p> <code>module_relative_path</code> <p>Example <code>lib_channels.py</code>.</p> <p> TYPE: <code>str</code> </p> <code>class_name</code> <p>Example <code>OmeroChannel</code>.</p> <p> TYPE: <code>str</code> </p> Source code in <code>fractal_tasks_core/dev/lib_descriptions.py</code> <pre><code>def _get_class_attrs_descriptions(\n    package_name: str, module_relative_path: str, class_name: str\n) -&gt; dict[str, str]:\n\"\"\"\n    Extract attribute descriptions from a class.\n\n    Args:\n        package_name: Example `fractal_tasks_core`.\n        module_relative_path: Example `lib_channels.py`.\n        class_name: Example `OmeroChannel`.\n    \"\"\"\n\n    if not module_relative_path.endswith(\".py\"):\n        raise ValueError(f\"Module {module_relative_path} must end with '.py'\")\n\n    # Get the class ast.ClassDef object\n    package_path = Path(import_module(package_name).__file__).parent\n    module_path = package_path / module_relative_path\n    tree = ast.parse(module_path.read_text())\n    try:\n        _class = next(\n            c\n            for c in ast.walk(tree)\n            if (isinstance(c, ast.ClassDef) and c.name == class_name)\n        )\n    except StopIteration:\n        raise RuntimeError(\n            f\"Cannot find {class_name=} for {package_name=} \"\n            f\"and {module_relative_path=}\"\n        )\n    docstring = ast.get_docstring(_class)\n    parsed_docstring = docparse(docstring)\n    descriptions = {\n        x.arg_name: (\n            _sanitize_description(x.description)\n            if x.description\n            else \"Missing description\"\n        )\n        for x in parsed_docstring.params\n    }\n    logging.info(f\"[_get_class_attrs_descriptions] END ({class_name=})\")\n    return descriptions\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_descriptions/#fractal_tasks_core.dev.lib_descriptions._get_function_args_descriptions","title":"<code>_get_function_args_descriptions(*, package_name, module_path, function_name, verbose=False)</code>","text":"<p>Extract argument descriptions from a function.</p> PARAMETER DESCRIPTION <code>package_name</code> <p>Example <code>fractal_tasks_core</code>.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>module_path</code> <p>This must be an absolute path like <code>/some/module.py</code> (if <code>package_name</code> is <code>None</code>) or a relative path like <code>something.py</code> (if <code>package_name</code> is not <code>None</code>).</p> <p> TYPE: <code>str</code> </p> <code>function_name</code> <p>Example <code>create_ome_zarr</code>.</p> <p> TYPE: <code>str</code> </p> Source code in <code>fractal_tasks_core/dev/lib_descriptions.py</code> <pre><code>def _get_function_args_descriptions(\n    *,\n    package_name: Optional[str],\n    module_path: str,\n    function_name: str,\n    verbose: bool = False,\n) -&gt; dict[str, str]:\n\"\"\"\n    Extract argument descriptions from a function.\n\n    Args:\n        package_name: Example `fractal_tasks_core`.\n        module_path:\n            This must be an absolute path like `/some/module.py` (if\n            `package_name` is `None`) or a relative path like `something.py`\n            (if `package_name` is not `None`).\n        function_name: Example `create_ome_zarr`.\n    \"\"\"\n\n    # Extract docstring from ast.FunctionDef\n    docstring = _get_function_docstring(\n        package_name=package_name,\n        module_path=module_path,\n        function_name=function_name,\n        verbose=verbose,\n    )\n    if verbose:\n        logging.info(f\"[_get_function_args_descriptions] {docstring}\")\n\n    # Parse docstring (via docstring_parser) and prepare output\n    parsed_docstring = docparse(docstring)\n    descriptions = {\n        param.arg_name: _sanitize_description(param.description)\n        for param in parsed_docstring.params\n    }\n    logging.info(f\"[_get_function_args_descriptions] END ({function_name=})\")\n    return descriptions\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_descriptions/#fractal_tasks_core.dev.lib_descriptions._get_function_docstring","title":"<code>_get_function_docstring(*, package_name, module_path, function_name, verbose=False)</code>","text":"<p>Extract docstring from a function.</p> PARAMETER DESCRIPTION <code>package_name</code> <p>Example <code>fractal_tasks_core</code>.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>module_path</code> <p>This must be an absolute path like <code>/some/module.py</code> (if <code>package_name</code> is <code>None</code>) or a relative path like <code>something.py</code> (if <code>package_name</code> is not <code>None</code>).</p> <p> TYPE: <code>str</code> </p> <code>function_name</code> <p>Example <code>create_ome_zarr</code>.</p> <p> TYPE: <code>str</code> </p> Source code in <code>fractal_tasks_core/dev/lib_descriptions.py</code> <pre><code>def _get_function_docstring(\n    *,\n    package_name: Optional[str],\n    module_path: str,\n    function_name: str,\n    verbose: bool = False,\n) -&gt; str:\n\"\"\"\n    Extract docstring from a function.\n\n\n    Args:\n        package_name: Example `fractal_tasks_core`.\n        module_path:\n            This must be an absolute path like `/some/module.py` (if\n            `package_name` is `None`) or a relative path like `something.py`\n            (if `package_name` is not `None`).\n        function_name: Example `create_ome_zarr`.\n    \"\"\"\n\n    if not module_path.endswith(\".py\"):\n        raise ValueError(f\"Module {module_path} must end with '.py'\")\n\n    # Get the function ast.FunctionDef object\n    if package_name is not None:\n        if os.path.isabs(module_path):\n            raise ValueError(\n                \"Error in _get_function_docstring: `package_name` is not \"\n                \"None but `module_path` is absolute.\"\n            )\n        package_path = Path(import_module(package_name).__file__).parent\n        module_path = package_path / module_path\n    else:\n        if not os.path.isabs(module_path):\n            raise ValueError(\n                \"Error in _get_function_docstring: `package_name` is None \"\n                \"but `module_path` is not absolute.\"\n            )\n        module_path = Path(module_path)\n\n    if verbose:\n        logging.info(f\"[_get_function_docstring] {function_name=}\")\n        logging.info(f\"[_get_function_docstring] {module_path=}\")\n\n    tree = ast.parse(module_path.read_text())\n    _function = next(\n        f\n        for f in ast.walk(tree)\n        if (isinstance(f, ast.FunctionDef) and f.name == function_name)\n    )\n\n    # Extract docstring from ast.FunctionDef\n    return ast.get_docstring(_function)\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_descriptions/#fractal_tasks_core.dev.lib_descriptions._insert_class_attrs_descriptions","title":"<code>_insert_class_attrs_descriptions(*, schema, class_name, descriptions, definition_key)</code>","text":"<p>Merge the descriptions obtained via <code>_get_attributes_models_descriptions</code> into the <code>class_name</code> definition, within an existing JSON Schema</p> PARAMETER DESCRIPTION <code>schema</code> <p>TBD</p> <p> TYPE: <code>dict</code> </p> <code>class_name</code> <p>TBD</p> <p> TYPE: <code>str</code> </p> <code>descriptions</code> <p>TBD</p> <p> TYPE: <code>dict</code> </p> <code>definition_key</code> <p>Either <code>\"definitions\"</code> (for Pydantic V1) or <code>\"$defs\"</code> (for Pydantic V2)</p> <p> TYPE: <code>str</code> </p> Source code in <code>fractal_tasks_core/dev/lib_descriptions.py</code> <pre><code>def _insert_class_attrs_descriptions(\n    *,\n    schema: dict,\n    class_name: str,\n    descriptions: dict,\n    definition_key: str,\n):\n\"\"\"\n    Merge the descriptions obtained via `_get_attributes_models_descriptions`\n    into the `class_name` definition, within an existing JSON Schema\n\n    Args:\n        schema: TBD\n        class_name: TBD\n        descriptions: TBD\n        definition_key: Either `\"definitions\"` (for Pydantic V1) or\n            `\"$defs\"` (for Pydantic V2)\n    \"\"\"\n    new_schema = schema.copy()\n    if definition_key not in schema:\n        return new_schema\n    else:\n        new_definitions = schema[definition_key].copy()\n    # Loop over existing definitions\n    for name, definition in schema[definition_key].items():\n        if name == class_name:\n            for prop in definition[\"properties\"]:\n                if \"description\" in new_definitions[name][\"properties\"][prop]:\n                    raise ValueError(\n                        f\"Property {name}.{prop} already has description\"\n                    )\n                else:\n                    new_definitions[name][\"properties\"][prop][\n                        \"description\"\n                    ] = descriptions[prop]\n    new_schema[definition_key] = new_definitions\n    logging.info(\"[_insert_class_attrs_descriptions] END\")\n    return new_schema\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_descriptions/#fractal_tasks_core.dev.lib_descriptions._insert_function_args_descriptions","title":"<code>_insert_function_args_descriptions(*, schema, descriptions, verbose=False)</code>","text":"<p>Merge the descriptions obtained via <code>_get_args_descriptions</code> into the properties of an existing JSON Schema.</p> PARAMETER DESCRIPTION <code>schema</code> <p>TBD</p> <p> TYPE: <code>dict</code> </p> <code>descriptions</code> <p>TBD</p> <p> TYPE: <code>dict</code> </p> Source code in <code>fractal_tasks_core/dev/lib_descriptions.py</code> <pre><code>def _insert_function_args_descriptions(\n    *, schema: dict, descriptions: dict, verbose: bool = False\n):\n\"\"\"\n    Merge the descriptions obtained via `_get_args_descriptions` into the\n    properties of an existing JSON Schema.\n\n    Args:\n        schema: TBD\n        descriptions: TBD\n    \"\"\"\n    new_schema = schema.copy()\n    new_properties = schema[\"properties\"].copy()\n    for key, value in schema[\"properties\"].items():\n        if \"description\" in value:\n            raise ValueError(\"Property already has description\")\n        else:\n            if key in descriptions:\n                value[\"description\"] = descriptions[key]\n            else:\n                value[\"description\"] = \"Missing description\"\n            new_properties[key] = value\n            if verbose:\n                logging.info(\n                    \"[_insert_function_args_descriptions] \"\n                    f\"Add {key=}, {value=}\"\n                )\n    new_schema[\"properties\"] = new_properties\n    logging.info(\"[_insert_function_args_descriptions] END\")\n    return new_schema\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_descriptions/#fractal_tasks_core.dev.lib_descriptions._sanitize_description","title":"<code>_sanitize_description(string)</code>","text":"<p>Sanitize a description string.</p> <p>This is a provisional helper function that replaces newlines with spaces and reduces multiple contiguous whitespace characters to a single one. Future iterations of the docstrings format/parsing may render this function not-needed or obsolete.</p> PARAMETER DESCRIPTION <code>string</code> <p>TBD</p> <p> TYPE: <code>str</code> </p> Source code in <code>fractal_tasks_core/dev/lib_descriptions.py</code> <pre><code>def _sanitize_description(string: str) -&gt; str:\n\"\"\"\n    Sanitize a description string.\n\n    This is a provisional helper function that replaces newlines with spaces\n    and reduces multiple contiguous whitespace characters to a single one.\n    Future iterations of the docstrings format/parsing may render this function\n    not-needed or obsolete.\n\n    Args:\n        string: TBD\n    \"\"\"\n    # Replace newline with space\n    new_string = string.replace(\"\\n\", \" \")\n    # Replace N-whitespace characterss with a single one\n    while \"  \" in new_string:\n        new_string = new_string.replace(\"  \", \" \")\n    return new_string\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_pydantic_generatejsonschema/","title":"lib_pydantic_generatejsonschema","text":"<p>Custom Pydantic v2 JSON Schema generation tools.</p> <p>As of Pydantic V2, the JSON Schema representation of model attributes marked as <code>Optional</code> changed, and the new behavior consists in marking the corresponding properties as an <code>anyOf</code> of either a <code>null</code> or the actual type. This is not always the required behavior, see e.g. * https://github.com/pydantic/pydantic/issues/7161 * https://github.com/pydantic/pydantic/issues/8394</p> <p>Here we list some alternative ways of reverting this change.</p>"},{"location":"reference/fractal_tasks_core/dev/lib_signature_constraints/","title":"lib_signature_constraints","text":""},{"location":"reference/fractal_tasks_core/dev/lib_signature_constraints/#fractal_tasks_core.dev.lib_signature_constraints._extract_function","title":"<code>_extract_function(module_relative_path, function_name, package_name='fractal_tasks_core', verbose=False)</code>","text":"<p>Extract function from a module with the same name.</p> PARAMETER DESCRIPTION <code>package_name</code> <p>Example <code>fractal_tasks_core</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'fractal_tasks_core'</code> </p> <code>module_relative_path</code> <p>Example <code>tasks/create_ome_zarr.py</code>.</p> <p> TYPE: <code>str</code> </p> <code>function_name</code> <p>Example <code>create_ome_zarr</code>.</p> <p> TYPE: <code>str</code> </p> <code>verbose</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>fractal_tasks_core/dev/lib_signature_constraints.py</code> <pre><code>def _extract_function(\n    module_relative_path: str,\n    function_name: str,\n    package_name: str = \"fractal_tasks_core\",\n    verbose: bool = False,\n) -&gt; Callable:\n\"\"\"\n    Extract function from a module with the same name.\n\n    Args:\n        package_name: Example `fractal_tasks_core`.\n        module_relative_path: Example `tasks/create_ome_zarr.py`.\n        function_name: Example `create_ome_zarr`.\n        verbose:\n    \"\"\"\n    if not module_relative_path.endswith(\".py\"):\n        raise ValueError(f\"{module_relative_path=} must end with '.py'\")\n    module_relative_path_no_py = str(\n        Path(module_relative_path).with_suffix(\"\")\n    )\n    module_relative_path_dots = module_relative_path_no_py.replace(\"/\", \".\")\n    if verbose:\n        logging.info(\n            f\"Now calling `import_module` for \"\n            f\"{package_name}.{module_relative_path_dots}\"\n        )\n    imported_module = import_module(\n        f\"{package_name}.{module_relative_path_dots}\"\n    )\n    if verbose:\n        logging.info(\n            f\"Now getting attribute {function_name} from \"\n            f\"imported module {imported_module}.\"\n        )\n    task_function = getattr(imported_module, function_name)\n    return task_function\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_signature_constraints/#fractal_tasks_core.dev.lib_signature_constraints._validate_function_signature","title":"<code>_validate_function_signature(function)</code>","text":"<p>Validate the function signature.</p> <p>Implement a set of checks for type hints that do not play well with the creation of JSON Schema, see https://github.com/fractal-analytics-platform/fractal-tasks-core/issues/399.</p> PARAMETER DESCRIPTION <code>function</code> <p>TBD</p> <p> TYPE: <code>Callable</code> </p> Source code in <code>fractal_tasks_core/dev/lib_signature_constraints.py</code> <pre><code>def _validate_function_signature(function: Callable):\n\"\"\"\n    Validate the function signature.\n\n    Implement a set of checks for type hints that do not play well with the\n    creation of JSON Schema, see\n    https://github.com/fractal-analytics-platform/fractal-tasks-core/issues/399.\n\n    Args:\n        function: TBD\n    \"\"\"\n    sig = signature(function)\n    for param in sig.parameters.values():\n        # CASE 1: Check that name is not forbidden\n        if param.name in FORBIDDEN_PARAM_NAMES:\n            raise ValueError(\n                f\"Function {function} has argument with name {param.name}\"\n            )\n\n        # CASE 2: Raise an error for unions\n        if str(param.annotation).startswith((\"typing.Union[\", \"Union[\")):\n            raise ValueError(\"typing.Union is not supported\")\n\n        # CASE 3: Raise an error for \"|\"\n        if \"|\" in str(param.annotation):\n            raise ValueError('Use of \"|\" in type hints is not supported')\n\n        # CASE 4: Raise an error for optional parameter with given (non-None)\n        # default, e.g. Optional[str] = \"asd\"\n        is_annotation_optional = str(param.annotation).startswith(\n            (\"typing.Optional[\", \"Optional[\")\n        )\n        default_given = (param.default is not None) and (\n            param.default != inspect._empty\n        )\n        if default_given and is_annotation_optional:\n            raise ValueError(\"Optional parameter has non-None default value\")\n\n    logging.info(\"[_validate_function_signature] END\")\n    return sig\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_task_docs/","title":"lib_task_docs","text":""},{"location":"reference/fractal_tasks_core/dev/lib_task_docs/#fractal_tasks_core.dev.lib_task_docs._get_function_description","title":"<code>_get_function_description(package_name, module_path, function_name)</code>","text":"<p>Extract function description from its docstring.</p> PARAMETER DESCRIPTION <code>package_name</code> <p>Example <code>fractal_tasks_core</code>.</p> <p> TYPE: <code>str</code> </p> <code>module_path</code> <p>Example <code>tasks/create_ome_zarr.py</code>.</p> <p> TYPE: <code>str</code> </p> <code>function_name</code> <p>Example <code>create_ome_zarr</code>.</p> <p> TYPE: <code>str</code> </p> Source code in <code>fractal_tasks_core/dev/lib_task_docs.py</code> <pre><code>def _get_function_description(\n    package_name: str, module_path: str, function_name: str\n) -&gt; str:\n\"\"\"\n    Extract function description from its docstring.\n\n    Args:\n        package_name: Example `fractal_tasks_core`.\n        module_path: Example `tasks/create_ome_zarr.py`.\n        function_name: Example `create_ome_zarr`.\n    \"\"\"\n    # Extract docstring from ast.FunctionDef\n    docstring = _get_function_docstring(\n        package_name=package_name,\n        module_path=module_path,\n        function_name=function_name,\n    )\n    # Parse docstring (via docstring_parser)\n    parsed_docstring = docparse(docstring)\n    # Combine short/long descriptions (if present)\n    short_description = parsed_docstring.short_description\n    long_description = parsed_docstring.long_description\n    items = []\n    if short_description:\n        items.append(short_description)\n    if long_description:\n        items.append(long_description)\n    if items:\n        if parsed_docstring.blank_after_short_description:\n            return \"\\n\\n\".join(items)\n        else:\n            return \"\\n\".join(items)\n    else:\n        return \"\"\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_task_docs/#fractal_tasks_core.dev.lib_task_docs.create_docs_info","title":"<code>create_docs_info(executable_non_parallel=None, executable_parallel=None, package='fractal_tasks_core')</code>","text":"<p>Return task description based on function docstring.</p> Source code in <code>fractal_tasks_core/dev/lib_task_docs.py</code> <pre><code>def create_docs_info(\n    executable_non_parallel: Optional[str] = None,\n    executable_parallel: Optional[str] = None,\n    package: str = \"fractal_tasks_core\",\n) -&gt; str:\n\"\"\"\n    Return task description based on function docstring.\n    \"\"\"\n    logging.info(\"[create_docs_info] START\")\n    docs_info = []\n    for executable in [executable_non_parallel, executable_parallel]:\n        if executable is None:\n            continue\n        # Extract the function name.\n        # Note: this could be made more general, but for the moment we assume\n        # that the function has the same name as the module)\n        function_name = Path(executable).with_suffix(\"\").name\n        logging.info(f\"[create_docs_info] {function_name=}\")\n        # Get function description\n        description = _get_function_description(\n            package_name=package,\n            module_path=executable,\n            function_name=function_name,\n        )\n        docs_info.append(f\"## {function_name}\\n{description}\\n\")\n    docs_info = \"\".join(docs_info)\n    logging.info(\"[create_docs_info] END\")\n    return docs_info\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_task_docs/#fractal_tasks_core.dev.lib_task_docs.read_docs_info_from_file","title":"<code>read_docs_info_from_file(*, docs_info, task_list_path)</code>","text":"<p>Return task description based on the content of a file.</p> <p>An example of valid argument is <pre><code>docs_info = \"file:relative/path/info.md\"\n</code></pre> where the path is relative to the folder where <code>task_list.py</code> is.</p> Source code in <code>fractal_tasks_core/dev/lib_task_docs.py</code> <pre><code>def read_docs_info_from_file(\n    *,\n    docs_info: str,\n    task_list_path: str,\n) -&gt; str:\n\"\"\"\n    Return task description based on the content of a file.\n\n    An example of valid argument is\n    ```\n    docs_info = \"file:relative/path/info.md\"\n    ```\n    where the path is relative to the folder where `task_list.py` is.\n    \"\"\"\n    logging.info(\"[read_docs_info_from_file] START\")\n\n    # Preliminary checks\n    if not docs_info.startswith(\"file:\"):\n        raise ValueError(f\"Invalid docs_info='{docs_info}'.\")\n    relative_path = Path(docs_info[5:])\n    if relative_path.is_absolute():\n        raise ValueError(\n            f\"Invalid docs_info='{docs_info}' (path must be relative).\"\n        )\n\n    base_path = Path(task_list_path).parent\n    docs_path = (base_path / relative_path).as_posix()\n    logging.info(f\"[read_docs_info_from_file] Reading docs from {docs_path}\")\n    with open(docs_path, \"r\") as f:\n        docs_info = f.read()\n    logging.info(\"[read_docs_info_from_file] END\")\n\n    return docs_info\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_titles/","title":"lib_titles","text":"<p>Module to include titles in JSON Schema properties.</p>"},{"location":"reference/fractal_tasks_core/dev/lib_titles/#fractal_tasks_core.dev.lib_titles._include_titles","title":"<code>_include_titles(schema, definitions_key, verbose=False)</code>","text":"<p>Include property titles, when missing.</p> <p>This handles both:</p> <ul> <li>first-level JSON Schema properties (corresponding to task     arguments);</li> <li>properties of JSON Schema definitions (corresponding to     task-argument attributes).</li> </ul> PARAMETER DESCRIPTION <code>schema</code> <p>TBD</p> <p> TYPE: <code>_Schema</code> </p> <code>definitions_key</code> <p>Either <code>\"definitions\"</code> (for Pydantic V1) or <code>\"$defs\"</code> (for Pydantic V2)</p> <p> TYPE: <code>str</code> </p> <code>verbose</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>fractal_tasks_core/dev/lib_titles.py</code> <pre><code>def _include_titles(\n    schema: _Schema,\n    definitions_key: str,\n    verbose: bool = False,\n) -&gt; _Schema:\n\"\"\"\n    Include property titles, when missing.\n\n    This handles both:\n\n    - first-level JSON Schema properties (corresponding to task\n        arguments);\n    - properties of JSON Schema definitions (corresponding to\n        task-argument attributes).\n\n    Args:\n        schema: TBD\n        definitions_key: Either `\"definitions\"` (for Pydantic V1) or\n            `\"$defs\"` (for Pydantic V2)\n        verbose:\n    \"\"\"\n    new_schema = schema.copy()\n\n    if verbose:\n        logging.info(\"[_include_titles] START\")\n        logging.info(f\"[_include_titles] Input schema:\\n{schema}\")\n\n    # Update first-level properties (that is, task arguments)\n    new_properties = _include_titles_for_properties(\n        schema[\"properties\"], verbose=verbose\n    )\n    new_schema[\"properties\"] = new_properties\n\n    if verbose:\n        logging.info(\"[_include_titles] Titles for properties now included.\")\n\n    # Update properties of definitions\n    if definitions_key in schema.keys():\n        new_definitions = schema[definitions_key].copy()\n        for def_name, def_schema in new_definitions.items():\n            if \"properties\" not in def_schema.keys():\n                if verbose:\n                    logging.info(\n                        f\"Definition schema {def_name} has no 'properties' \"\n                        \"key. Skip.\"\n                    )\n            else:\n                new_properties = _include_titles_for_properties(\n                    def_schema[\"properties\"], verbose=verbose\n                )\n                new_definitions[def_name][\"properties\"] = new_properties\n        new_schema[definitions_key] = new_definitions\n\n    if verbose:\n        logging.info(\n            \"[_include_titles] Titles for definitions properties now included.\"\n        )\n        logging.info(\"[_include_titles] END\")\n    return new_schema\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/lib_titles/#fractal_tasks_core.dev.lib_titles._include_titles_for_properties","title":"<code>_include_titles_for_properties(properties, verbose=False)</code>","text":"<p>Scan through properties of a JSON Schema, and set their title when it is missing.</p> <p>The title is set to <code>name.title()</code>, where <code>title</code> is a standard string method - see https://docs.python.org/3/library/stdtypes.html#str.title.</p> PARAMETER DESCRIPTION <code>properties</code> <p>TBD</p> <p> TYPE: <code>dict[str, dict]</code> </p> Source code in <code>fractal_tasks_core/dev/lib_titles.py</code> <pre><code>def _include_titles_for_properties(\n    properties: dict[str, dict],\n    verbose: bool = False,\n) -&gt; dict[str, dict]:\n\"\"\"\n    Scan through properties of a JSON Schema, and set their title when it is\n    missing.\n\n    The title is set to `name.title()`, where `title` is a standard string\n    method - see https://docs.python.org/3/library/stdtypes.html#str.title.\n\n    Args:\n        properties: TBD\n    \"\"\"\n    if verbose:\n        logging.info(\n            f\"[_include_titles_for_properties] Original properties:\\n\"\n            f\"{properties}\"\n        )\n\n    new_properties = properties.copy()\n    for prop_name, prop in properties.items():\n        if \"title\" not in prop.keys():\n            new_prop = prop.copy()\n            new_prop[\"title\"] = prop_name.title()\n            new_properties[prop_name] = new_prop\n    if verbose:\n        logging.info(\n            f\"[_include_titles_for_properties] New properties:\\n\"\n            f\"{new_properties}\"\n        )\n    return new_properties\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/task_list/","title":"task_list","text":"<p>Fractal task list.</p>"},{"location":"reference/fractal_tasks_core/dev/task_models/","title":"task_models","text":"<p>Task models for Fractal tasks.</p> <p>These models are used in <code>task_list.py</code>, and they provide a layer that simplifies writing the task list of a package in a way that is compliant with fractal-server v2.</p>"},{"location":"reference/fractal_tasks_core/dev/task_models/#fractal_tasks_core.dev.task_models.CompoundTask","title":"<code>CompoundTask</code>","text":"<p>               Bases: <code>_BaseTask</code></p> <p>A <code>CompoundTask</code> object must include both <code>executable_init</code> and <code>executable</code> attributes, and it may include the <code>meta_init</code> and <code>meta</code> attributes.</p> Source code in <code>fractal_tasks_core/dev/task_models.py</code> <pre><code>@deprecated(DEPRECATION_MSG_CLASS)\nclass CompoundTask(_BaseTask):\n\"\"\"\n    A `CompoundTask` object must include both `executable_init` and\n    `executable` attributes, and it may include the `meta_init` and `meta`\n    attributes.\n    \"\"\"\n\n    executable_init: str\n    meta_init: Optional[dict[str, Any]] = None\n\n    @property\n    def executable_non_parallel(self) -&gt; str:\n        return self.executable_init\n\n    @property\n    def meta_non_parallel(self) -&gt; Optional[dict[str, Any]]:\n        return self.meta_init\n\n    @property\n    def executable_parallel(self) -&gt; str:\n        return self.executable\n\n    @property\n    def meta_parallel(self) -&gt; Optional[dict[str, Any]]:\n        return self.meta\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/task_models/#fractal_tasks_core.dev.task_models.NonParallelTask","title":"<code>NonParallelTask</code>","text":"<p>               Bases: <code>_BaseTask</code></p> <p>A <code>NonParallelTask</code> object must include the <code>executable</code> attribute, and it may include the <code>meta</code> attribute.</p> Source code in <code>fractal_tasks_core/dev/task_models.py</code> <pre><code>@deprecated(DEPRECATION_MSG_CLASS)\nclass NonParallelTask(_BaseTask):\n\"\"\"\n    A `NonParallelTask` object must include the `executable` attribute, and it\n    may include the `meta` attribute.\n    \"\"\"\n\n    @property\n    def executable_non_parallel(self) -&gt; str:\n        return self.executable\n\n    @property\n    def meta_non_parallel(self) -&gt; Optional[dict[str, Any]]:\n        return self.meta\n\n    @property\n    def executable_parallel(self) -&gt; None:\n        return None\n\n    @property\n    def meta_parallel(self) -&gt; None:\n        return None\n</code></pre>"},{"location":"reference/fractal_tasks_core/dev/task_models/#fractal_tasks_core.dev.task_models.ParallelTask","title":"<code>ParallelTask</code>","text":"<p>               Bases: <code>_BaseTask</code></p> <p>A <code>ParallelTask</code> object must include the <code>executable</code> attribute, and it may include the <code>meta</code> attribute.</p> Source code in <code>fractal_tasks_core/dev/task_models.py</code> <pre><code>@deprecated(DEPRECATION_MSG_CLASS)\nclass ParallelTask(_BaseTask):\n\"\"\"\n    A `ParallelTask` object must include the `executable` attribute, and it may\n    include the `meta` attribute.\n    \"\"\"\n\n    @property\n    def executable_non_parallel(self) -&gt; None:\n        return None\n\n    @property\n    def meta_non_parallel(self) -&gt; None:\n        return None\n\n    @property\n    def executable_parallel(self) -&gt; str:\n        return self.executable\n\n    @property\n    def meta_parallel(self) -&gt; Optional[dict[str, Any]]:\n        return self.meta\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/","title":"ngff","text":"<p>Subpackage encoding OME-NGFF specifications 0.4 and providing Zarr-related tools.</p> <p>Note: this <code>__init__.py</code> file only exports the most relevant symbols, that is, the ones that are used outside this subpackage.</p>"},{"location":"reference/fractal_tasks_core/ngff/specs/","title":"specs","text":"<p>Pydantic models related to OME-NGFF 0.4 specs, as implemented in fractal-tasks-core.</p>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.AcquisitionInPlate","title":"<code>AcquisitionInPlate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for an element of <code>Plate.acquisitions</code>.</p> <p>See https://ngff.openmicroscopy.org/0.4/#plate-md.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class AcquisitionInPlate(BaseModel):\n\"\"\"\n    Model for an element of `Plate.acquisitions`.\n\n    See https://ngff.openmicroscopy.org/0.4/#plate-md.\n    \"\"\"\n\n    id: int = Field(\n        description=\"A unique identifier within the context of the plate\"\n    )\n    maximumfieldcount: Optional[int] = Field(\n        None,\n        description=(\n            \"Int indicating the maximum number of fields of view for the \"\n            \"acquisition\"\n        ),\n    )\n    name: Optional[str] = Field(\n        None, description=\"a string identifying the name of the acquisition\"\n    )\n    description: Optional[str] = Field(\n        None,\n        description=\"The description of the acquisition\",\n    )\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.Axis","title":"<code>Axis</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for an element of <code>Multiscale.axes</code>.</p> <p>See https://ngff.openmicroscopy.org/0.4/#axes-md.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class Axis(BaseModel):\n\"\"\"\n    Model for an element of `Multiscale.axes`.\n\n    See https://ngff.openmicroscopy.org/0.4/#axes-md.\n    \"\"\"\n\n    name: str\n    type: Optional[str] = None\n    unit: Optional[str] = None\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.Channel","title":"<code>Channel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for an element of <code>Omero.channels</code>.</p> <p>See https://ngff.openmicroscopy.org/0.4/#omero-md.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class Channel(BaseModel):\n\"\"\"\n    Model for an element of `Omero.channels`.\n\n    See https://ngff.openmicroscopy.org/0.4/#omero-md.\n    \"\"\"\n\n    window: Optional[Window] = None\n    label: Optional[str] = None\n    family: Optional[str] = None\n    color: str\n    active: Optional[bool] = None\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.ColumnInPlate","title":"<code>ColumnInPlate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for an element of <code>Plate.columns</code>.</p> <p>See https://ngff.openmicroscopy.org/0.4/#plate-md.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class ColumnInPlate(BaseModel):\n\"\"\"\n    Model for an element of `Plate.columns`.\n\n    See https://ngff.openmicroscopy.org/0.4/#plate-md.\n    \"\"\"\n\n    name: str\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.Dataset","title":"<code>Dataset</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for an element of <code>Multiscale.datasets</code>.</p> <p>See https://ngff.openmicroscopy.org/0.4/#multiscale-md</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class Dataset(BaseModel):\n\"\"\"\n    Model for an element of `Multiscale.datasets`.\n\n    See https://ngff.openmicroscopy.org/0.4/#multiscale-md\n    \"\"\"\n\n    path: str\n    coordinateTransformations: list[\n        Union[\n            ScaleCoordinateTransformation, TranslationCoordinateTransformation\n        ]\n    ] = Field(..., min_length=1)\n\n    @property\n    def scale_transformation(self) -&gt; ScaleCoordinateTransformation:\n\"\"\"\n        Extract the unique scale transformation, or fail otherwise.\n        \"\"\"\n        _transformations = [\n            t for t in self.coordinateTransformations if t.type == \"scale\"\n        ]\n        if len(_transformations) == 0:\n            raise ValueError(\n                \"Missing scale transformation in dataset.\\n\"\n                \"Current coordinateTransformations:\\n\"\n                f\"{self.coordinateTransformations}\"\n            )\n        elif len(_transformations) &gt; 1:\n            raise ValueError(\n                \"More than one scale transformation in dataset.\\n\"\n                \"Current coordinateTransformations:\\n\"\n                f\"{self.coordinateTransformations}\"\n            )\n        else:\n            return _transformations[0]\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.Dataset.scale_transformation","title":"<code>scale_transformation: ScaleCoordinateTransformation</code>  <code>property</code>","text":"<p>Extract the unique scale transformation, or fail otherwise.</p>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.ImageInWell","title":"<code>ImageInWell</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for an element of <code>Well.images</code>.</p> <p>Note 1: The NGFF image is defined in a different model (<code>NgffImageMeta</code>), while the <code>Image</code> model only refere to an item of <code>Well.images</code>.</p> <p>Note 2: We deviate from NGFF specs, since we allow <code>path</code> to be an arbitrary string. TODO: include a check like <code>constr(regex=r'^[A-Za-z0-9]+$')</code>, through a Pydantic validator.</p> <p>See https://ngff.openmicroscopy.org/0.4/#well-md.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class ImageInWell(BaseModel):\n\"\"\"\n    Model for an element of `Well.images`.\n\n    **Note 1:** The NGFF image is defined in a different model\n    (`NgffImageMeta`), while the `Image` model only refere to an item of\n    `Well.images`.\n\n    **Note 2:** We deviate from NGFF specs, since we allow `path` to be an\n    arbitrary string.\n    TODO: include a check like `constr(regex=r'^[A-Za-z0-9]+$')`, through a\n    Pydantic validator.\n\n    See https://ngff.openmicroscopy.org/0.4/#well-md.\n    \"\"\"\n\n    acquisition: Optional[int] = Field(\n        None, description=\"A unique identifier within the context of the plate\"\n    )\n    path: str = Field(\n        ..., description=\"The path for this field of view subgroup\"\n    )\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.Multiscale","title":"<code>Multiscale</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for an element of <code>NgffImageMeta.multiscales</code>.</p> <p>See https://ngff.openmicroscopy.org/0.4/#multiscale-md.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class Multiscale(BaseModel):\n\"\"\"\n    Model for an element of `NgffImageMeta.multiscales`.\n\n    See https://ngff.openmicroscopy.org/0.4/#multiscale-md.\n    \"\"\"\n\n    name: Optional[str] = None\n    datasets: list[Dataset] = Field(..., min_length=1)\n    version: Optional[str] = None\n    axes: list[Axis] = Field(..., max_length=5, min_length=2)\n    coordinateTransformations: Optional[\n        list[\n            Union[\n                ScaleCoordinateTransformation,\n                TranslationCoordinateTransformation,\n            ]\n        ]\n    ] = None\n    _check_unique = field_validator(\"axes\")(unique_items_validator)\n\n    @field_validator(\"coordinateTransformations\", mode=\"after\")\n    @classmethod\n    def _no_global_coordinateTransformations(\n        cls, v: Optional[list]\n    ) -&gt; Optional[list]:\n\"\"\"\n        Fail if Multiscale has a (global) coordinateTransformations attribute.\n        \"\"\"\n        if v is None:\n            return v\n        else:\n            raise NotImplementedError(\n                \"Global coordinateTransformations at the multiscales \"\n                \"level are not currently supported in the fractal-tasks-core \"\n                \"model for the NGFF multiscale.\"\n            )\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.Multiscale._no_global_coordinateTransformations","title":"<code>_no_global_coordinateTransformations(v)</code>  <code>classmethod</code>","text":"<p>Fail if Multiscale has a (global) coordinateTransformations attribute.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>@field_validator(\"coordinateTransformations\", mode=\"after\")\n@classmethod\ndef _no_global_coordinateTransformations(\n    cls, v: Optional[list]\n) -&gt; Optional[list]:\n\"\"\"\n    Fail if Multiscale has a (global) coordinateTransformations attribute.\n    \"\"\"\n    if v is None:\n        return v\n    else:\n        raise NotImplementedError(\n            \"Global coordinateTransformations at the multiscales \"\n            \"level are not currently supported in the fractal-tasks-core \"\n            \"model for the NGFF multiscale.\"\n        )\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.NgffImageMeta","title":"<code>NgffImageMeta</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for the metadata of a NGFF image.</p> <p>See https://ngff.openmicroscopy.org/0.4/#image-layout.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class NgffImageMeta(BaseModel):\n\"\"\"\n    Model for the metadata of a NGFF image.\n\n    See https://ngff.openmicroscopy.org/0.4/#image-layout.\n    \"\"\"\n\n    multiscales: list[Multiscale] = Field(\n        ...,\n        description=\"The multiscale datasets for this image\",\n        min_length=1,\n    )\n    omero: Optional[Omero] = None\n    _check_unique = field_validator(\"multiscales\")(unique_items_validator)\n\n    @property\n    def multiscale(self) -&gt; Multiscale:\n\"\"\"\n        The single element of `self.multiscales`.\n\n        Raises:\n            NotImplementedError:\n                If there are no multiscales or more than one.\n        \"\"\"\n        if len(self.multiscales) &gt; 1:\n            raise NotImplementedError(\n                \"Only images with one multiscale are supported \"\n                f\"(given: {len(self.multiscales)}\"\n            )\n        return self.multiscales[0]\n\n    @property\n    def datasets(self) -&gt; list[Dataset]:\n\"\"\"\n        The `datasets` attribute of `self.multiscale`.\n        \"\"\"\n        return self.multiscale.datasets\n\n    @property\n    def num_levels(self) -&gt; int:\n        return len(self.datasets)\n\n    @property\n    def axes_names(self) -&gt; list[str]:\n\"\"\"\n        List of axes names.\n        \"\"\"\n        return [ax.name for ax in self.multiscale.axes]\n\n    @property\n    def pixel_sizes_zyx(self) -&gt; list[list[float]]:\n\"\"\"\n        Pixel sizes extracted from scale transformations of datasets.\n\n        Raises:\n            ValueError:\n                If pixel sizes are below a given threshold (1e-9).\n        \"\"\"\n        x_index = self.axes_names.index(\"x\")\n        y_index = self.axes_names.index(\"y\")\n        try:\n            z_index = self.axes_names.index(\"z\")\n        except ValueError:\n            z_index = None\n            logging.warning(\n                f\"Z axis is not present (axes: {self.axes_names}), and Z pixel\"\n                \" size is set to 1. This may work, by accident, but it is \"\n                \"not fully supported.\"\n            )\n        _pixel_sizes_zyx = []\n        for level in range(self.num_levels):\n            scale = self.datasets[level].scale_transformation.scale\n            pixel_size_x = scale[x_index]\n            pixel_size_y = scale[y_index]\n            if z_index is not None:\n                pixel_size_z = scale[z_index]\n            else:\n                pixel_size_z = 1.0\n            _pixel_sizes_zyx.append([pixel_size_z, pixel_size_y, pixel_size_x])\n            if min(_pixel_sizes_zyx[-1]) &lt; 1e-9:\n                raise ValueError(\n                    f\"Pixel sizes at level {level} are too small: \"\n                    f\"{_pixel_sizes_zyx[-1]}\"\n                )\n\n        return _pixel_sizes_zyx\n\n    def get_pixel_sizes_zyx(self, *, level: int = 0) -&gt; list[float]:\n        return self.pixel_sizes_zyx[level]\n\n    @property\n    def coarsening_xy(self) -&gt; int:\n\"\"\"\n        Linear coarsening factor in the YX plane.\n\n        We only support coarsening factors that are homogeneous (both in the\n        X/Y directions and across pyramid levels).\n\n        Raises:\n            NotImplementedError:\n                If coarsening ratios are not homogeneous.\n        \"\"\"\n        current_ratio = None\n        for ind in range(1, self.num_levels):\n            ratio_x = round(\n                self.pixel_sizes_zyx[ind][2] / self.pixel_sizes_zyx[ind - 1][2]\n            )\n            ratio_y = round(\n                self.pixel_sizes_zyx[ind][1] / self.pixel_sizes_zyx[ind - 1][1]\n            )\n            if ratio_x != ratio_y:\n                raise NotImplementedError(\n                    \"Inhomogeneous coarsening in X/Y directions \"\n                    \"is not supported.\\n\"\n                    f\"ZYX pixel sizes:\\n {self.pixel_sizes_zyx}\"\n                )\n            if current_ratio is None:\n                current_ratio = ratio_x\n            else:\n                if current_ratio != ratio_x:\n                    raise NotImplementedError(\n                        \"Inhomogeneous coarsening across levels \"\n                        \"is not supported.\\n\"\n                        f\"ZYX pixel sizes:\\n {self.pixel_sizes_zyx}\"\n                    )\n\n        return current_ratio\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.NgffImageMeta.axes_names","title":"<code>axes_names: list[str]</code>  <code>property</code>","text":"<p>List of axes names.</p>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.NgffImageMeta.coarsening_xy","title":"<code>coarsening_xy: int</code>  <code>property</code>","text":"<p>Linear coarsening factor in the YX plane.</p> <p>We only support coarsening factors that are homogeneous (both in the X/Y directions and across pyramid levels).</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If coarsening ratios are not homogeneous.</p>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.NgffImageMeta.datasets","title":"<code>datasets: list[Dataset]</code>  <code>property</code>","text":"<p>The <code>datasets</code> attribute of <code>self.multiscale</code>.</p>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.NgffImageMeta.multiscale","title":"<code>multiscale: Multiscale</code>  <code>property</code>","text":"<p>The single element of <code>self.multiscales</code>.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If there are no multiscales or more than one.</p>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.NgffImageMeta.pixel_sizes_zyx","title":"<code>pixel_sizes_zyx: list[list[float]]</code>  <code>property</code>","text":"<p>Pixel sizes extracted from scale transformations of datasets.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If pixel sizes are below a given threshold (1e-9).</p>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.NgffPlateMeta","title":"<code>NgffPlateMeta</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for the metadata of a NGFF plate.</p> <p>See https://ngff.openmicroscopy.org/0.4/#plate-md.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class NgffPlateMeta(BaseModel):\n\"\"\"\n    Model for the metadata of a NGFF plate.\n\n    See https://ngff.openmicroscopy.org/0.4/#plate-md.\n    \"\"\"\n\n    plate: Plate\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.NgffWellMeta","title":"<code>NgffWellMeta</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for the metadata of a NGFF well.</p> <p>See https://ngff.openmicroscopy.org/0.4/#well-md.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class NgffWellMeta(BaseModel):\n\"\"\"\n    Model for the metadata of a NGFF well.\n\n    See https://ngff.openmicroscopy.org/0.4/#well-md.\n    \"\"\"\n\n    well: Optional[Well] = None\n\n    def get_acquisition_paths(self) -&gt; dict[int, list[str]]:\n\"\"\"\n        Create mapping from acquisition indices to corresponding paths.\n\n        Runs on the well zarr attributes and loads the relative paths in the\n        well.\n\n        Returns:\n            Dictionary with `(acquisition index: [image_path])` key/value\n            pairs.\n\n        Raises:\n            ValueError:\n                If an element of `self.well.images` has no `acquisition`\n                    attribute.\n        \"\"\"\n        acquisition_dict = {}\n        for image in self.well.images:\n            if image.acquisition is None:\n                raise ValueError(\n                    \"Cannot get acquisition paths for Zarr files without \"\n                    \"'acquisition' metadata at the well level\"\n                )\n            if image.acquisition not in acquisition_dict:\n                acquisition_dict[image.acquisition] = []\n            acquisition_dict[image.acquisition].append(image.path)\n        return acquisition_dict\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.NgffWellMeta.get_acquisition_paths","title":"<code>get_acquisition_paths()</code>","text":"<p>Create mapping from acquisition indices to corresponding paths.</p> <p>Runs on the well zarr attributes and loads the relative paths in the well.</p> RETURNS DESCRIPTION <code>dict[int, list[str]]</code> <p>Dictionary with <code>(acquisition index: [image_path])</code> key/value</p> <code>dict[int, list[str]]</code> <p>pairs.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If an element of <code>self.well.images</code> has no <code>acquisition</code>     attribute.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>def get_acquisition_paths(self) -&gt; dict[int, list[str]]:\n\"\"\"\n    Create mapping from acquisition indices to corresponding paths.\n\n    Runs on the well zarr attributes and loads the relative paths in the\n    well.\n\n    Returns:\n        Dictionary with `(acquisition index: [image_path])` key/value\n        pairs.\n\n    Raises:\n        ValueError:\n            If an element of `self.well.images` has no `acquisition`\n                attribute.\n    \"\"\"\n    acquisition_dict = {}\n    for image in self.well.images:\n        if image.acquisition is None:\n            raise ValueError(\n                \"Cannot get acquisition paths for Zarr files without \"\n                \"'acquisition' metadata at the well level\"\n            )\n        if image.acquisition not in acquisition_dict:\n            acquisition_dict[image.acquisition] = []\n        acquisition_dict[image.acquisition].append(image.path)\n    return acquisition_dict\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.Omero","title":"<code>Omero</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for <code>NgffImageMeta.omero</code>.</p> <p>See https://ngff.openmicroscopy.org/0.4/#omero-md.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class Omero(BaseModel):\n\"\"\"\n    Model for `NgffImageMeta.omero`.\n\n    See https://ngff.openmicroscopy.org/0.4/#omero-md.\n    \"\"\"\n\n    channels: list[Channel]\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.Plate","title":"<code>Plate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for <code>NgffPlateMeta.plate</code>.</p> <p>See https://ngff.openmicroscopy.org/0.4/#plate-md.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class Plate(BaseModel):\n\"\"\"\n    Model for `NgffPlateMeta.plate`.\n\n    See https://ngff.openmicroscopy.org/0.4/#plate-md.\n    \"\"\"\n\n    acquisitions: Optional[list[AcquisitionInPlate]] = None\n    columns: list[ColumnInPlate]\n    field_count: Optional[int] = None\n    name: Optional[str] = None\n    rows: list[RowInPlate]\n    # version will become required in 0.5\n    version: Optional[str] = Field(\n        None, description=\"The version of the specification\"\n    )\n    wells: list[WellInPlate]\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.RowInPlate","title":"<code>RowInPlate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for an element of <code>Plate.rows</code>.</p> <p>See https://ngff.openmicroscopy.org/0.4/#plate-md.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class RowInPlate(BaseModel):\n\"\"\"\n    Model for an element of `Plate.rows`.\n\n    See https://ngff.openmicroscopy.org/0.4/#plate-md.\n    \"\"\"\n\n    name: str\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.ScaleCoordinateTransformation","title":"<code>ScaleCoordinateTransformation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for a scale transformation.</p> <p>This corresponds to scale-type elements of <code>Dataset.coordinateTransformations</code> or <code>Multiscale.coordinateTransformations</code>. See https://ngff.openmicroscopy.org/0.4/#trafo-md</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class ScaleCoordinateTransformation(BaseModel):\n\"\"\"\n    Model for a scale transformation.\n\n    This corresponds to scale-type elements of\n    `Dataset.coordinateTransformations` or\n    `Multiscale.coordinateTransformations`.\n    See https://ngff.openmicroscopy.org/0.4/#trafo-md\n    \"\"\"\n\n    type: Literal[\"scale\"]\n    scale: list[float] = Field(..., min_length=2)\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.TranslationCoordinateTransformation","title":"<code>TranslationCoordinateTransformation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for a translation transformation.</p> <p>This corresponds to translation-type elements of <code>Dataset.coordinateTransformations</code> or <code>Multiscale.coordinateTransformations</code>. See https://ngff.openmicroscopy.org/0.4/#trafo-md</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class TranslationCoordinateTransformation(BaseModel):\n\"\"\"\n    Model for a translation transformation.\n\n    This corresponds to translation-type elements of\n    `Dataset.coordinateTransformations` or\n    `Multiscale.coordinateTransformations`.\n    See https://ngff.openmicroscopy.org/0.4/#trafo-md\n    \"\"\"\n\n    type: Literal[\"translation\"]\n    translation: list[float] = Field(..., min_length=2)\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.Well","title":"<code>Well</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for <code>NgffWellMeta.well</code>.</p> <p>See https://ngff.openmicroscopy.org/0.4/#well-md.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class Well(BaseModel):\n\"\"\"\n    Model for `NgffWellMeta.well`.\n\n    See https://ngff.openmicroscopy.org/0.4/#well-md.\n    \"\"\"\n\n    images: list[ImageInWell] = Field(\n        ..., description=\"The images included in this well\", min_length=1\n    )\n    version: Optional[str] = Field(\n        None, description=\"The version of the specification\"\n    )\n    _check_unique = field_validator(\"images\")(unique_items_validator)\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.WellInPlate","title":"<code>WellInPlate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for an element of <code>Plate.wells</code>.</p> <p>See https://ngff.openmicroscopy.org/0.4/#plate-md.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class WellInPlate(BaseModel):\n\"\"\"\n    Model for an element of `Plate.wells`.\n\n    See https://ngff.openmicroscopy.org/0.4/#plate-md.\n    \"\"\"\n\n    path: str\n    rowIndex: int\n    columnIndex: int\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/specs/#fractal_tasks_core.ngff.specs.Window","title":"<code>Window</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for <code>Channel.window</code>.</p> <p>Note that we deviate by NGFF specs by making <code>start</code> and <code>end</code> optional. See https://ngff.openmicroscopy.org/0.4/#omero-md.</p> Source code in <code>fractal_tasks_core/ngff/specs.py</code> <pre><code>class Window(BaseModel):\n\"\"\"\n    Model for `Channel.window`.\n\n    Note that we deviate by NGFF specs by making `start` and `end` optional.\n    See https://ngff.openmicroscopy.org/0.4/#omero-md.\n    \"\"\"\n\n    max: float\n    min: float\n    start: Optional[float] = None\n    end: Optional[float] = None\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/zarr_utils/","title":"zarr_utils","text":"<p>Utilities to work with the Pydantic models from <code>specs.py</code> for Zarr groups.</p>"},{"location":"reference/fractal_tasks_core/ngff/zarr_utils/#fractal_tasks_core.ngff.zarr_utils.ZarrGroupNotFoundError","title":"<code>ZarrGroupNotFoundError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Wrap zarr.errors.GroupNotFoundError</p> <p>This is used to provide a user-friendly error message.</p> Source code in <code>fractal_tasks_core/ngff/zarr_utils.py</code> <pre><code>class ZarrGroupNotFoundError(ValueError):\n\"\"\"\n    Wrap zarr.errors.GroupNotFoundError\n\n    This is used to provide a user-friendly error message.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/zarr_utils/#fractal_tasks_core.ngff.zarr_utils.detect_ome_ngff_type","title":"<code>detect_ome_ngff_type(group)</code>","text":"<p>Given a Zarr group, find whether it is an OME-NGFF plate, well or image.</p> PARAMETER DESCRIPTION <code>group</code> <p>Zarr group</p> <p> TYPE: <code>Group</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The detected OME-NGFF type (<code>plate</code>, <code>well</code> or <code>image</code>).</p> Source code in <code>fractal_tasks_core/ngff/zarr_utils.py</code> <pre><code>def detect_ome_ngff_type(group: zarr.hierarchy.Group) -&gt; str:\n\"\"\"\n    Given a Zarr group, find whether it is an OME-NGFF plate, well or image.\n\n    Args:\n        group: Zarr group\n\n    Returns:\n        The detected OME-NGFF type (`plate`, `well` or `image`).\n    \"\"\"\n    attrs = group.attrs.asdict()\n    if \"plate\" in attrs.keys():\n        ngff_type = \"plate\"\n    elif \"well\" in attrs.keys():\n        ngff_type = \"well\"\n    elif \"multiscales\" in attrs.keys():\n        ngff_type = \"image\"\n    else:\n        error_msg = (\n            \"Zarr group at cannot be identified as one \"\n            \"of OME-NGFF plate/well/image groups.\"\n        )\n        logger.error(error_msg)\n        raise ValueError(error_msg)\n    logger.info(f\"Zarr group identified as OME-NGFF {ngff_type}.\")\n    return ngff_type\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/zarr_utils/#fractal_tasks_core.ngff.zarr_utils.load_NgffImageMeta","title":"<code>load_NgffImageMeta(zarr_path)</code>","text":"<p>Load the attributes of a zarr group and cast them to <code>NgffImageMeta</code>.</p> PARAMETER DESCRIPTION <code>zarr_path</code> <p>Path to the zarr group.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>NgffImageMeta</code> <p>A new <code>NgffImageMeta</code> object.</p> Source code in <code>fractal_tasks_core/ngff/zarr_utils.py</code> <pre><code>def load_NgffImageMeta(zarr_path: str) -&gt; NgffImageMeta:\n\"\"\"\n    Load the attributes of a zarr group and cast them to `NgffImageMeta`.\n\n    Args:\n        zarr_path: Path to the zarr group.\n\n    Returns:\n        A new `NgffImageMeta` object.\n    \"\"\"\n    try:\n        zarr_group = zarr.open_group(zarr_path, mode=\"r\")\n    except GroupNotFoundError:\n        error_msg = (\n            \"Could not load attributes for the requested image, \"\n            f\"because no Zarr group was found at {zarr_path}\"\n        )\n        logging.error(error_msg)\n        raise ZarrGroupNotFoundError(error_msg)\n    zarr_attrs = zarr_group.attrs.asdict()\n    try:\n        return NgffImageMeta(**zarr_attrs)\n    except Exception as e:\n        logging.error(\n            f\"Contents of {zarr_path} cannot be cast to NgffImageMeta.\\n\"\n            f\"Original error:\\n{str(e)}\"\n        )\n        raise e\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/zarr_utils/#fractal_tasks_core.ngff.zarr_utils.load_NgffPlateMeta","title":"<code>load_NgffPlateMeta(zarr_path)</code>","text":"<p>Load the attributes of a zarr group and cast them to <code>NgffPlateMeta</code>.</p> PARAMETER DESCRIPTION <code>zarr_path</code> <p>Path to the zarr group.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>NgffPlateMeta</code> <p>A new <code>NgffPlateMeta</code> object.</p> Source code in <code>fractal_tasks_core/ngff/zarr_utils.py</code> <pre><code>def load_NgffPlateMeta(zarr_path: str) -&gt; NgffPlateMeta:\n\"\"\"\n    Load the attributes of a zarr group and cast them to `NgffPlateMeta`.\n\n    Args:\n        zarr_path: Path to the zarr group.\n\n    Returns:\n        A new `NgffPlateMeta` object.\n    \"\"\"\n    try:\n        zarr_group = zarr.open_group(zarr_path, mode=\"r\")\n    except GroupNotFoundError:\n        error_msg = (\n            \"Could not load attributes for the requested plate, \"\n            f\"because no Zarr group was found at {zarr_path}\"\n        )\n        logging.error(error_msg)\n        raise ZarrGroupNotFoundError(error_msg)\n    zarr_attrs = zarr_group.attrs.asdict()\n    try:\n        return NgffPlateMeta(**zarr_attrs)\n    except Exception as e:\n        logging.error(\n            f\"Contents of {zarr_path} cannot be cast to NgffPlateMeta.\\n\"\n            f\"Original error:\\n{str(e)}\"\n        )\n        raise e\n</code></pre>"},{"location":"reference/fractal_tasks_core/ngff/zarr_utils/#fractal_tasks_core.ngff.zarr_utils.load_NgffWellMeta","title":"<code>load_NgffWellMeta(zarr_path)</code>","text":"<p>Load the attributes of a zarr group and cast them to <code>NgffWellMeta</code>.</p> PARAMETER DESCRIPTION <code>zarr_path</code> <p>Path to the zarr group.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>NgffWellMeta</code> <p>A new <code>NgffWellMeta</code> object.</p> Source code in <code>fractal_tasks_core/ngff/zarr_utils.py</code> <pre><code>def load_NgffWellMeta(zarr_path: str) -&gt; NgffWellMeta:\n\"\"\"\n    Load the attributes of a zarr group and cast them to `NgffWellMeta`.\n\n    Args:\n        zarr_path: Path to the zarr group.\n\n    Returns:\n        A new `NgffWellMeta` object.\n    \"\"\"\n    try:\n        zarr_group = zarr.open_group(zarr_path, mode=\"r\")\n    except GroupNotFoundError:\n        error_msg = (\n            \"Could not load attributes for the requested well, \"\n            f\"because no Zarr group was found at {zarr_path}\"\n        )\n        logging.error(error_msg)\n        raise ZarrGroupNotFoundError(error_msg)\n    zarr_attrs = zarr_group.attrs.asdict()\n    try:\n        return NgffWellMeta(**zarr_attrs)\n    except Exception as e:\n        logging.error(\n            f\"Contents of {zarr_path} cannot be cast to NgffWellMeta.\\n\"\n            f\"Original error:\\n{str(e)}\"\n        )\n        raise e\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/","title":"roi","text":"<p>Subpackage for ROI-related functions.</p>"},{"location":"reference/fractal_tasks_core/roi/#fractal_tasks_core.roi.apply_shift_in_one_direction","title":"<code>apply_shift_in_one_direction(tmp_df_well, line_1, line_2, mu, tol=1e-10)</code>","text":"<p>TBD</p> PARAMETER DESCRIPTION <code>tmp_df_well</code> <p>TBD</p> <p> TYPE: <code>DataFrame</code> </p> <code>line_1</code> <p>TBD</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>line_2</code> <p>TBD</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>mu</code> <p>TBD</p> <p> TYPE: <code>str</code> </p> <code>tol</code> <p>TBD</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-10</code> </p> Source code in <code>fractal_tasks_core/roi/v1_overlaps.py</code> <pre><code>def apply_shift_in_one_direction(\n    tmp_df_well: pd.DataFrame,\n    line_1: Sequence[float],\n    line_2: Sequence[float],\n    mu: str,\n    tol: float = 1e-10,\n):\n\"\"\"\n    TBD\n\n    Args:\n        tmp_df_well: TBD\n        line_1: TBD\n        line_2: TBD\n        mu: TBD\n        tol: TBD\n    \"\"\"\n    min_1, max_1 = line_1[:]\n    min_2, max_2 = line_2[:]\n    min_max = min(max_1, max_2)\n    max_min = max(min_1, min_2)\n    shift = min_max - max_min\n    logging.debug(f\"{mu}-shifting by {shift=}\")\n    ind = tmp_df_well.loc[:, f\"{mu}min\"] &gt;= max_min - tol\n    if not (shift &gt; 0.0 and ind.to_numpy().max() &gt; 0):\n        raise ValueError(\n            \"Something wrong in apply_shift_in_one_direction\\n\"\n            f\"{mu=}\\n{shift=}\\n{ind.to_numpy()=}\"\n        )\n    tmp_df_well.loc[ind, f\"{mu}min\"] += shift\n    tmp_df_well.loc[ind, f\"{mu}max\"] += shift\n    tmp_df_well.loc[ind, f\"{mu}_micrometer\"] += shift\n    return tmp_df_well\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/#fractal_tasks_core.roi.are_ROI_table_columns_valid","title":"<code>are_ROI_table_columns_valid(*, table)</code>","text":"<p>Verify some validity assumptions on a ROI table.</p> <p>This function reflects our current working assumptions (e.g. the presence of some specific columns); this may change in future versions.</p> PARAMETER DESCRIPTION <code>table</code> <p>AnnData table to be checked</p> <p> TYPE: <code>AnnData</code> </p> Source code in <code>fractal_tasks_core/roi/v1_checks.py</code> <pre><code>def are_ROI_table_columns_valid(*, table: ad.AnnData) -&gt; None:\n\"\"\"\n    Verify some validity assumptions on a ROI table.\n\n    This function reflects our current working assumptions (e.g. the presence\n    of some specific columns); this may change in future versions.\n\n    Args:\n        table: AnnData table to be checked\n    \"\"\"\n\n    # Hard constraint: table columns must include some expected ones\n    columns = [\n        \"x_micrometer\",\n        \"y_micrometer\",\n        \"z_micrometer\",\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n    ]\n    for column in columns:\n        if column not in table.var_names:\n            raise ValueError(f\"Column {column} is not present in ROI table\")\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/#fractal_tasks_core.roi.array_to_bounding_box_table","title":"<code>array_to_bounding_box_table(mask_array, pxl_sizes_zyx, origin_zyx=(0, 0, 0))</code>","text":"<p>Construct bounding-box ROI table for a mask array.</p> PARAMETER DESCRIPTION <code>mask_array</code> <p>Original array to construct bounding boxes.</p> <p> TYPE: <code>ndarray</code> </p> <code>pxl_sizes_zyx</code> <p>Physical-unit pixel ZYX sizes.</p> <p> TYPE: <code>list[float]</code> </p> <code>origin_zyx</code> <p>Shift ROI origin by this amount of ZYX pixels.</p> <p> TYPE: <code>tuple[int, int, int]</code> DEFAULT: <code>(0, 0, 0)</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>DataFrame with each line representing the bounding-box ROI that corresponds to a unique value of <code>mask_array</code>. ROI properties are expressed in physical units (with columns defined as elsewhere this module - see e.g. <code>prepare_well_ROI_table</code>), and positions are optionally shifted (if <code>origin_zyx</code> is set). An additional column <code>label</code> keeps track of the <code>mask_array</code> value corresponding to each ROI.</p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def array_to_bounding_box_table(\n    mask_array: np.ndarray,\n    pxl_sizes_zyx: list[float],\n    origin_zyx: tuple[int, int, int] = (0, 0, 0),\n) -&gt; pd.DataFrame:\n\"\"\"\n    Construct bounding-box ROI table for a mask array.\n\n    Args:\n        mask_array: Original array to construct bounding boxes.\n        pxl_sizes_zyx: Physical-unit pixel ZYX sizes.\n        origin_zyx: Shift ROI origin by this amount of ZYX pixels.\n\n    Returns:\n        DataFrame with each line representing the bounding-box ROI that\n            corresponds to a unique value of `mask_array`. ROI properties are\n            expressed in physical units (with columns defined as elsewhere this\n            module - see e.g. `prepare_well_ROI_table`), and positions are\n            optionally shifted (if `origin_zyx` is set). An additional column\n            `label` keeps track of the `mask_array` value corresponding to each\n            ROI.\n    \"\"\"\n\n    pxl_sizes_zyx_array = np.array(pxl_sizes_zyx)\n    z_origin, y_origin, x_origin = origin_zyx[:]\n\n    labels = np.unique(mask_array)\n    labels = labels[labels &gt; 0]\n    elem_list = []\n    for label in labels:\n        # Compute bounding box\n        label_match = np.where(mask_array == label)\n        zmin, ymin, xmin = np.min(label_match, axis=1) * pxl_sizes_zyx_array\n        zmax, ymax, xmax = (\n            np.max(label_match, axis=1) + 1\n        ) * pxl_sizes_zyx_array\n\n        # Compute bounding-box edges\n        length_x = xmax - xmin\n        length_y = ymax - ymin\n        length_z = zmax - zmin\n\n        # Shift origin\n        zmin += z_origin * pxl_sizes_zyx[0]\n        ymin += y_origin * pxl_sizes_zyx[1]\n        xmin += x_origin * pxl_sizes_zyx[2]\n\n        elem_list.append((xmin, ymin, zmin, length_x, length_y, length_z))\n\n    df_columns = [\n        \"x_micrometer\",\n        \"y_micrometer\",\n        \"z_micrometer\",\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n    ]\n\n    if len(elem_list) == 0:\n        df = pd.DataFrame(columns=[x for x in df_columns] + [\"label\"])\n    else:\n        df = pd.DataFrame(np.array(elem_list), columns=df_columns)\n        df[\"label\"] = labels\n\n    return df\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/#fractal_tasks_core.roi.check_valid_ROI_indices","title":"<code>check_valid_ROI_indices(list_indices, ROI_table_name)</code>","text":"<p>Check that list of indices has zero origin on each axis.</p> <p>See fractal-tasks-core issues #530 and #554.</p> <p>This helper function is meant to provide informative error messages when ROI tables created with fractal-tasks-core up to v0.11 are used in v0.12. This function will be deprecated and removed as soon as the v0.11/v0.12 transition advances.</p> <p>Note that only <code>FOV_ROI_table</code> and <code>well_ROI_table</code> have to fulfill this constraint, while ROI tables obtained through segmentation may have arbitrary (non-negative) indices.</p> PARAMETER DESCRIPTION <code>list_indices</code> <p>Output of <code>convert_ROI_table_to_indices</code>; each item is like <code>[start_z, end_z, start_y, end_y, start_x, end_x]</code>.</p> <p> TYPE: <code>list[list[int]]</code> </p> <code>ROI_table_name</code> <p>Name of the ROI table.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the table name is <code>FOV_ROI_table</code> or <code>well_ROI_table</code> and the     minimum value of <code>start_x</code>, <code>start_y</code> and <code>start_z</code> are not all     zero.</p> Source code in <code>fractal_tasks_core/roi/v1_checks.py</code> <pre><code>def check_valid_ROI_indices(\n    list_indices: list[list[int]],\n    ROI_table_name: str,\n) -&gt; None:\n\"\"\"\n    Check that list of indices has zero origin on each axis.\n\n    See fractal-tasks-core issues #530 and #554.\n\n    This helper function is meant to provide informative error messages when\n    ROI tables created with fractal-tasks-core up to v0.11 are used in v0.12.\n    This function will be deprecated and removed as soon as the v0.11/v0.12\n    transition advances.\n\n    Note that only `FOV_ROI_table` and `well_ROI_table` have to fulfill this\n    constraint, while ROI tables obtained through segmentation may have\n    arbitrary (non-negative) indices.\n\n    Args:\n        list_indices:\n            Output of `convert_ROI_table_to_indices`; each item is like\n            `[start_z, end_z, start_y, end_y, start_x, end_x]`.\n        ROI_table_name: Name of the ROI table.\n\n    Raises:\n        ValueError:\n            If the table name is `FOV_ROI_table` or `well_ROI_table` and the\n                minimum value of `start_x`, `start_y` and `start_z` are not all\n                zero.\n    \"\"\"\n    if ROI_table_name not in [\"FOV_ROI_table\", \"well_ROI_table\"]:\n        # This validation function only applies to the FOV/well ROI tables\n        # generated with fractal-tasks-core\n        return\n\n    # Find minimum index along ZYX\n    min_start_z = min(item[0] for item in list_indices)\n    min_start_y = min(item[2] for item in list_indices)\n    min_start_x = min(item[4] for item in list_indices)\n\n    # Check that minimum indices are all zero\n    for ind, min_index in enumerate((min_start_z, min_start_y, min_start_x)):\n        if min_index != 0:\n            axis = [\"Z\", \"Y\", \"X\"][ind]\n            raise ValueError(\n                f\"{axis} component of ROI indices for table `{ROI_table_name}`\"\n                f\" do not start with 0, but with {min_index}.\\n\"\n                \"Hint: As of fractal-tasks-core v0.12, FOV/well ROI \"\n                \"tables with non-zero origins (e.g. the ones created with \"\n                \"v0.11) are not supported.\"\n            )\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/#fractal_tasks_core.roi.check_well_for_FOV_overlap","title":"<code>check_well_for_FOV_overlap(site_metadata, selected_well, plotting_function, tol=1e-10)</code>","text":"<p>This function is currently only used in tests and examples.</p> <p>The <code>plotting_function</code> parameter is exposed so that other tools (see examples in this repository) may use it to show the FOV ROIs.</p> PARAMETER DESCRIPTION <code>site_metadata</code> <p>TBD</p> <p> TYPE: <code>DataFrame</code> </p> <code>selected_well</code> <p>TBD</p> <p> TYPE: <code>str</code> </p> <code>plotting_function</code> <p>TBD</p> <p> TYPE: <code>Callable</code> </p> <code>tol</code> <p>TBD</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-10</code> </p> Source code in <code>fractal_tasks_core/roi/v1_overlaps.py</code> <pre><code>def check_well_for_FOV_overlap(\n    site_metadata: pd.DataFrame,\n    selected_well: str,\n    plotting_function: Callable,\n    tol: float = 1e-10,\n):\n\"\"\"\n    This function is currently only used in tests and examples.\n\n    The `plotting_function` parameter is exposed so that other tools (see\n    examples in this repository) may use it to show the FOV ROIs.\n\n    Args:\n        site_metadata: TBD\n        selected_well: TBD\n        plotting_function: TBD\n        tol: TBD\n    \"\"\"\n\n    df = site_metadata.loc[selected_well].copy()\n    df[\"xmin\"] = df[\"x_micrometer\"]\n    df[\"ymin\"] = df[\"y_micrometer\"]\n    df[\"xmax\"] = df[\"x_micrometer\"] + df[\"pixel_size_x\"] * df[\"x_pixel\"]\n    df[\"ymax\"] = df[\"y_micrometer\"] + df[\"pixel_size_y\"] * df[\"y_pixel\"]\n\n    xmin = list(df.loc[:, \"xmin\"])\n    ymin = list(df.loc[:, \"ymin\"])\n    xmax = list(df.loc[:, \"xmax\"])\n    ymax = list(df.loc[:, \"ymax\"])\n    num_lines = len(xmin)\n\n    list_overlapping_FOVs = []\n    for line_1 in range(num_lines):\n        min_x_1, max_x_1 = [a[line_1] for a in [xmin, xmax]]\n        min_y_1, max_y_1 = [a[line_1] for a in [ymin, ymax]]\n        for line_2 in range(line_1):\n            min_x_2, max_x_2 = [a[line_2] for a in [xmin, xmax]]\n            min_y_2, max_y_2 = [a[line_2] for a in [ymin, ymax]]\n            overlap = is_overlapping_2D(\n                (min_x_1, min_y_1, max_x_1, max_y_1),\n                (min_x_2, min_y_2, max_x_2, max_y_2),\n                tol=tol,\n            )\n            if overlap:\n                list_overlapping_FOVs.append(line_1)\n                list_overlapping_FOVs.append(line_2)\n\n    # Call plotting_function\n    plotting_function(\n        xmin, xmax, ymin, ymax, list_overlapping_FOVs, selected_well\n    )\n\n    if len(list_overlapping_FOVs) &gt; 0:\n        # Increase values by one to switch from index to the label plotted\n        return {selected_well: [x + 1 for x in list_overlapping_FOVs]}\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/#fractal_tasks_core.roi.convert_ROI_table_to_indices","title":"<code>convert_ROI_table_to_indices(ROI, full_res_pxl_sizes_zyx, level=0, coarsening_xy=2, cols_xyz_pos=['x_micrometer', 'y_micrometer', 'z_micrometer'], cols_xyz_len=['len_x_micrometer', 'len_y_micrometer', 'len_z_micrometer'])</code>","text":"<p>Convert a ROI AnnData table into integer array indices.</p> PARAMETER DESCRIPTION <code>ROI</code> <p>AnnData table with list of ROIs.</p> <p> TYPE: <code>AnnData</code> </p> <code>full_res_pxl_sizes_zyx</code> <p>Physical-unit pixel ZYX sizes at the full-resolution pyramid level.</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>level</code> <p>Pyramid level.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>coarsening_xy</code> <p>Linear coarsening factor in the YX plane.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>cols_xyz_pos</code> <p>Column names for XYZ ROI positions.</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>['x_micrometer', 'y_micrometer', 'z_micrometer']</code> </p> <code>cols_xyz_len</code> <p>Column names for XYZ ROI edges.</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>['len_x_micrometer', 'len_y_micrometer', 'len_z_micrometer']</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If any of the array indices is negative.</p> RETURNS DESCRIPTION <code>list[list[int]]</code> <p>Nested list of indices. The main list has one item per ROI. Each ROI item is a list of six integers as in <code>[start_z, end_z, start_y, end_y, start_x, end_x]</code>. The array-index interval for a given ROI is <code>start_x:end_x</code> along X, and so on for Y and Z.</p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def convert_ROI_table_to_indices(\n    ROI: ad.AnnData,\n    full_res_pxl_sizes_zyx: Sequence[float],\n    level: int = 0,\n    coarsening_xy: int = 2,\n    cols_xyz_pos: Sequence[str] = [\n        \"x_micrometer\",\n        \"y_micrometer\",\n        \"z_micrometer\",\n    ],\n    cols_xyz_len: Sequence[str] = [\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n    ],\n) -&gt; list[list[int]]:\n\"\"\"\n    Convert a ROI AnnData table into integer array indices.\n\n    Args:\n        ROI: AnnData table with list of ROIs.\n        full_res_pxl_sizes_zyx:\n            Physical-unit pixel ZYX sizes at the full-resolution pyramid level.\n        level: Pyramid level.\n        coarsening_xy: Linear coarsening factor in the YX plane.\n        cols_xyz_pos: Column names for XYZ ROI positions.\n        cols_xyz_len: Column names for XYZ ROI edges.\n\n    Raises:\n        ValueError:\n            If any of the array indices is negative.\n\n    Returns:\n        Nested list of indices. The main list has one item per ROI. Each ROI\n            item is a list of six integers as in `[start_z, end_z, start_y,\n            end_y, start_x, end_x]`. The array-index interval for a given ROI\n            is `start_x:end_x` along X, and so on for Y and Z.\n    \"\"\"\n    # Handle empty ROI table\n    if len(ROI) == 0:\n        return []\n\n    # Set pyramid-level pixel sizes\n    pxl_size_z, pxl_size_y, pxl_size_x = full_res_pxl_sizes_zyx\n    prefactor = coarsening_xy**level\n    pxl_size_x *= prefactor\n    pxl_size_y *= prefactor\n\n    x_pos, y_pos, z_pos = cols_xyz_pos[:]\n    x_len, y_len, z_len = cols_xyz_len[:]\n\n    list_indices = []\n    for ROI_name in ROI.obs_names:\n        # Extract data from anndata table\n        x_micrometer = ROI[ROI_name, x_pos].X[0, 0]\n        y_micrometer = ROI[ROI_name, y_pos].X[0, 0]\n        z_micrometer = ROI[ROI_name, z_pos].X[0, 0]\n        len_x_micrometer = ROI[ROI_name, x_len].X[0, 0]\n        len_y_micrometer = ROI[ROI_name, y_len].X[0, 0]\n        len_z_micrometer = ROI[ROI_name, z_len].X[0, 0]\n\n        # Identify indices along the three dimensions\n        start_x = x_micrometer / pxl_size_x\n        end_x = (x_micrometer + len_x_micrometer) / pxl_size_x\n        start_y = y_micrometer / pxl_size_y\n        end_y = (y_micrometer + len_y_micrometer) / pxl_size_y\n        start_z = z_micrometer / pxl_size_z\n        end_z = (z_micrometer + len_z_micrometer) / pxl_size_z\n        indices = [start_z, end_z, start_y, end_y, start_x, end_x]\n\n        # Round indices to lower integer\n        indices = list(map(round, indices))\n\n        # Fail for negative indices\n        if min(indices) &lt; 0:\n            raise ValueError(\n                f\"ROI {ROI_name} converted into negative array indices.\\n\"\n                f\"ZYX position: {z_micrometer}, {y_micrometer}, \"\n                f\"{x_micrometer}\\n\"\n                f\"ZYX pixel sizes: {pxl_size_z}, {pxl_size_y}, \"\n                f\"{pxl_size_x} ({level=})\\n\"\n                \"Hint: As of fractal-tasks-core v0.12, FOV/well ROI \"\n                \"tables with non-zero origins (e.g. the ones created with \"\n                \"v0.11) are not supported.\"\n            )\n\n        # Append ROI indices to to list\n        list_indices.append(indices[:])\n\n    return list_indices\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/#fractal_tasks_core.roi.convert_ROIs_from_3D_to_2D","title":"<code>convert_ROIs_from_3D_to_2D(adata, pixel_size_z)</code>","text":"<p>TBD</p> <p>Note that this function is only relevant when the ROIs in adata span the whole extent of the Z axis. TODO: check this explicitly.</p> PARAMETER DESCRIPTION <code>adata</code> <p>TBD</p> <p> TYPE: <code>AnnData</code> </p> <code>pixel_size_z</code> <p>TBD</p> <p> TYPE: <code>float</code> </p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def convert_ROIs_from_3D_to_2D(\n    adata: ad.AnnData,\n    pixel_size_z: float,\n) -&gt; ad.AnnData:\n\"\"\"\n    TBD\n\n    Note that this function is only relevant when the ROIs in adata span the\n    whole extent of the Z axis.\n    TODO: check this explicitly.\n\n    Args:\n        adata: TBD\n        pixel_size_z: TBD\n    \"\"\"\n\n    # Compress a 3D stack of images to a single Z plane,\n    # with thickness equal to pixel_size_z\n    df = adata.to_df()\n    df[\"len_z_micrometer\"] = pixel_size_z\n\n    # Assign dtype explicitly, to avoid\n    # &gt;&gt; UserWarning: X converted to numpy array with dtype float64\n    # when creating AnnData object\n    df = df.astype(np.float32)\n\n    # Create an AnnData object directly from the DataFrame\n    new_adata = ad.AnnData(X=df)\n\n    # Rename rows and columns\n    new_adata.obs_names = adata.obs_names\n    new_adata.var_names = list(map(str, df.columns))\n\n    return new_adata\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/#fractal_tasks_core.roi.convert_indices_to_regions","title":"<code>convert_indices_to_regions(index)</code>","text":"<p>Converts index tuples to region tuple</p> PARAMETER DESCRIPTION <code>index</code> <p>Tuple containing 6 entries of (z_start, z_end, y_start, y_end, x_start, x_end).</p> <p> TYPE: <code>list[int]</code> </p> RETURNS DESCRIPTION <code>region</code> <p>tuple of three slices (ZYX)</p> <p> TYPE: <code>tuple[slice, slice, slice]</code> </p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def convert_indices_to_regions(\n    index: list[int],\n) -&gt; tuple[slice, slice, slice]:\n\"\"\"\n    Converts index tuples to region tuple\n\n    Args:\n        index: Tuple containing 6 entries of (z_start, z_end, y_start,\n            y_end, x_start, x_end).\n\n    Returns:\n        region: tuple of three slices (ZYX)\n    \"\"\"\n    return (\n        slice(index[0], index[1]),\n        slice(index[2], index[3]),\n        slice(index[4], index[5]),\n    )\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/#fractal_tasks_core.roi.create_roi_table_from_df_list","title":"<code>create_roi_table_from_df_list(bbox_dataframe_list)</code>","text":"<p>Creates an AnnData ROI table from a list of bounding-box tables</p> <p>This function handles empty bbox lists, ensures that it has unique entries per label (and to address #810, it handles duplicate labels by only keeping the first entry for each label) &amp; converts it to an AnnData table with a label column in obs.</p> PARAMETER DESCRIPTION <code>bbox_dataframe_list</code> <p>List of bounding box dataframes. All dataframes are expected to have the same columns and they usually are: x_micrometer, y_micrometer, z_micrometer, len_x_micrometer, len_y_micrometer, len_z_micrometer, label. The label column is required.</p> <p> TYPE: <code>list[DataFrame]</code> </p> RETURNS DESCRIPTION <code>AnnData</code> <p>An <code>AnnData</code> table with all the ROIs.</p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def create_roi_table_from_df_list(\n    bbox_dataframe_list: list[pd.DataFrame],\n) -&gt; ad.AnnData:\n\"\"\"\n    Creates an AnnData ROI table from a list of bounding-box tables\n\n    This function handles empty bbox lists, ensures that it has unique entries\n    per label (and to address #810, it handles duplicate labels by only\n    keeping the first entry for each label) &amp; converts it to an AnnData table\n    with a label column in obs.\n\n    Args:\n        bbox_dataframe_list: List of bounding box dataframes. All dataframes\n            are expected to have the same columns and they usually are:\n            x_micrometer, y_micrometer, z_micrometer, len_x_micrometer,\n            len_y_micrometer, len_z_micrometer, label. The label column is\n            required.\n\n    Returns:\n        An `AnnData` table with all the ROIs.\n    \"\"\"\n    # Handle the case where `bbox_dataframe_list` is empty (typically\n    # because list_indices is also empty)\n    if len(bbox_dataframe_list) == 0:\n        bbox_dataframe_list = [empty_bounding_box_table()]\n    # Concatenate all ROI dataframes\n    df_well = pd.concat(bbox_dataframe_list, axis=0, ignore_index=True)\n\n    # Drop duplicates based on the 'label' column, keeping only the first\n    # occurrence (see #810 for details)\n    df_well = df_well.drop_duplicates(subset=\"label\", keep=\"first\")\n\n    # Extract labels and drop them from df_well\n    labels = pd.DataFrame(df_well[\"label\"].astype(str)).reset_index(drop=True)\n\n    # Check that there are only unique labels. Should be ensured by check above\n    if len(labels[\"label\"]) != len(labels[\"label\"].unique()):\n        raise ValueError(\n            \"The output ROI table contains duplicate entries for labels: \"\n            f\"It contains {len(labels['label'])} entries, but only \"\n            f\"{len(labels['label'].unique())} unique labels\"\n        )\n\n    df_well.index = labels[\"label\"]\n    df_well.drop(labels=[\"label\"], axis=1, inplace=True)\n    # Convert all to float (warning: some would be int, in principle)\n    bbox_dtype = np.float32\n    df_well = df_well.astype(bbox_dtype)\n    # Convert to anndata\n    bbox_table = ad.AnnData(df_well)\n    bbox_table.obs = labels\n    return bbox_table\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/#fractal_tasks_core.roi.empty_bounding_box_table","title":"<code>empty_bounding_box_table()</code>","text":"<p>Construct an empty bounding-box ROI table of given shape.</p> <p>This function mirrors the functionality of <code>array_to_bounding_box_table</code>, for the specific case where the array includes no label. The advantages of this function are that:</p> <ol> <li>It does not require computing a whole array of zeros;</li> <li>We avoid hardcoding column names in the task functions.</li> </ol> RETURNS DESCRIPTION <code>DataFrame</code> <p>DataFrame with no rows, and with columns corresponding to the output of <code>array_to_bounding_box_table</code>.</p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def empty_bounding_box_table() -&gt; pd.DataFrame:\n\"\"\"\n    Construct an empty bounding-box ROI table of given shape.\n\n    This function mirrors the functionality of `array_to_bounding_box_table`,\n    for the specific case where the array includes no label. The advantages of\n    this function are that:\n\n    1. It does not require computing a whole array of zeros;\n    2. We avoid hardcoding column names in the task functions.\n\n    Returns:\n        DataFrame with no rows, and with columns corresponding to the output of\n            `array_to_bounding_box_table`.\n    \"\"\"\n\n    df_columns = [\n        \"x_micrometer\",\n        \"y_micrometer\",\n        \"z_micrometer\",\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n    ]\n    df = pd.DataFrame(columns=[x for x in df_columns] + [\"label\"])\n    return df\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/#fractal_tasks_core.roi.find_overlaps_in_ROI_indices","title":"<code>find_overlaps_in_ROI_indices(list_indices)</code>","text":"<p>Given a list of integer ROI indices, find whether there are overlaps.</p> PARAMETER DESCRIPTION <code>list_indices</code> <p>List of ROI indices, where each element in the list should look like <code>[start_z, end_z, start_y, end_y, start_x, end_x]</code>.</p> <p> TYPE: <code>list[list[int]]</code> </p> RETURNS DESCRIPTION <code>Optional[tuple[int, int]]</code> <p><code>None</code> if no overlap was detected, otherwise a tuple with the positional indices of a pair of overlapping ROIs.</p> Source code in <code>fractal_tasks_core/roi/v1_overlaps.py</code> <pre><code>def find_overlaps_in_ROI_indices(\n    list_indices: list[list[int]],\n) -&gt; Optional[tuple[int, int]]:\n\"\"\"\n    Given a list of integer ROI indices, find whether there are overlaps.\n\n    Args:\n        list_indices: List of ROI indices, where each element in the list\n            should look like\n            `[start_z, end_z, start_y, end_y, start_x, end_x]`.\n\n    Returns:\n        `None` if no overlap was detected, otherwise a tuple with the\n            positional indices of a pair of overlapping ROIs.\n    \"\"\"\n\n    for ind_1, ROI_1 in enumerate(list_indices):\n        s_z, e_z, s_y, e_y, s_x, e_x = ROI_1[:]\n        box_1 = [s_x, s_y, s_z, e_x, e_y, e_z]\n        for ind_2 in range(ind_1):\n            ROI_2 = list_indices[ind_2]\n            s_z, e_z, s_y, e_y, s_x, e_x = ROI_2[:]\n            box_2 = [s_x, s_y, s_z, e_x, e_y, e_z]\n            if _is_overlapping_3D_int(box_1, box_2):\n                return (ind_1, ind_2)\n    return None\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/#fractal_tasks_core.roi.get_image_grid_ROIs","title":"<code>get_image_grid_ROIs(array_shape, pixels_ZYX, grid_YX_shape)</code>","text":"<p>Produce a table with ROIS placed on a rectangular grid.</p> <p>The main goal of this ROI grid is to allow processing of smaller subset of the whole array.</p> <p>In a specific case (that is, if the image array was obtained by stitching together a set of FOVs placed on a regular grid), the ROIs correspond to the original FOVs.</p> <p>TODO: make this flexible with respect to the presence/absence of Z.</p> PARAMETER DESCRIPTION <code>array_shape</code> <p>ZYX shape of the image array.</p> <p> TYPE: <code>tuple[int, int, int]</code> </p> <code>pixels_ZYX</code> <p>ZYX pixel sizes in micrometers.</p> <p> TYPE: <code>list[float]</code> </p> <code>grid_YX_shape</code> <p> TYPE: <code>tuple[int, int]</code> </p> RETURNS DESCRIPTION <code>AnnData</code> <p>An <code>AnnData</code> table with a single ROI.</p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def get_image_grid_ROIs(\n    array_shape: tuple[int, int, int],\n    pixels_ZYX: list[float],\n    grid_YX_shape: tuple[int, int],\n) -&gt; ad.AnnData:\n\"\"\"\n    Produce a table with ROIS placed on a rectangular grid.\n\n    The main goal of this ROI grid is to allow processing of smaller subset of\n    the whole array.\n\n    In a specific case (that is, if the image array was obtained by stitching\n    together a set of FOVs placed on a regular grid), the ROIs correspond to\n    the original FOVs.\n\n    TODO: make this flexible with respect to the presence/absence of Z.\n\n    Args:\n        array_shape: ZYX shape of the image array.\n        pixels_ZYX: ZYX pixel sizes in micrometers.\n        grid_YX_shape:\n\n    Returns:\n        An `AnnData` table with a single ROI.\n    \"\"\"\n    shape_z, shape_y, shape_x = array_shape[-3:]\n    grid_size_y, grid_size_x = grid_YX_shape[:]\n    X = []\n    obs_names = []\n    counter = 0\n    start_z = 0\n    len_z = shape_z\n\n    # Find minimal len_y that covers [0,shape_y] with grid_size_y intervals\n    len_y = math.ceil(shape_y / grid_size_y)\n    len_x = math.ceil(shape_x / grid_size_x)\n    for ind_y in range(grid_size_y):\n        start_y = ind_y * len_y\n        tmp_len_y = min(shape_y, start_y + len_y) - start_y\n        for ind_x in range(grid_size_x):\n            start_x = ind_x * len_x\n            tmp_len_x = min(shape_x, start_x + len_x) - start_x\n            X.append(\n                [\n                    start_x * pixels_ZYX[2],\n                    start_y * pixels_ZYX[1],\n                    start_z * pixels_ZYX[0],\n                    tmp_len_x * pixels_ZYX[2],\n                    tmp_len_y * pixels_ZYX[1],\n                    len_z * pixels_ZYX[0],\n                ]\n            )\n            counter += 1\n            obs_names.append(f\"ROI_{counter}\")\n    ROI_table = ad.AnnData(X=np.array(X, dtype=np.float32))\n    ROI_table.obs_names = obs_names\n    ROI_table.var_names = [\n        \"x_micrometer\",\n        \"y_micrometer\",\n        \"z_micrometer\",\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n    ]\n    return ROI_table\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/#fractal_tasks_core.roi.get_overlapping_pair","title":"<code>get_overlapping_pair(tmp_df, tol=1e-10)</code>","text":"<p>Finds the indices for the next overlapping FOVs pair.</p> <p>Note: the returned indices are positional indices, starting from 0.</p> PARAMETER DESCRIPTION <code>tmp_df</code> <p>Dataframe with columns <code>[\"xmin\", \"ymin\", \"xmax\", \"ymax\"]</code>.</p> <p> TYPE: <code>DataFrame</code> </p> <code>tol</code> <p>Finite tolerance for floating-point comparisons.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-10</code> </p> Source code in <code>fractal_tasks_core/roi/v1_overlaps.py</code> <pre><code>def get_overlapping_pair(\n    tmp_df: pd.DataFrame, tol: float = 1e-10\n) -&gt; Union[tuple[int, int], bool]:\n\"\"\"\n    Finds the indices for the next overlapping FOVs pair.\n\n    Note: the returned indices are positional indices, starting from 0.\n\n    Args:\n        tmp_df: Dataframe with columns `[\"xmin\", \"ymin\", \"xmax\", \"ymax\"]`.\n        tol: Finite tolerance for floating-point comparisons.\n    \"\"\"\n\n    num_lines = len(tmp_df.index)\n    for pos_ind_1 in range(num_lines):\n        for pos_ind_2 in range(pos_ind_1):\n            bbox_1 = tmp_df.iloc[pos_ind_1].to_numpy()\n            bbox_2 = tmp_df.iloc[pos_ind_2].to_numpy()\n            if is_overlapping_2D(bbox_1, bbox_2, tol=tol):\n                return (pos_ind_1, pos_ind_2)\n    return False\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/#fractal_tasks_core.roi.get_overlapping_pairs_3D","title":"<code>get_overlapping_pairs_3D(tmp_df, full_res_pxl_sizes_zyx)</code>","text":"<p>Finds the indices for the all overlapping FOVs pair, in three dimensions.</p> <p>Note: the returned indices are positional indices, starting from 0.</p> PARAMETER DESCRIPTION <code>tmp_df</code> <p>Dataframe with columns <code>{x,y,z}_micrometer</code> and <code>len_{x,y,z}_micrometer</code>.</p> <p> TYPE: <code>DataFrame</code> </p> <code>full_res_pxl_sizes_zyx</code> <p>TBD</p> <p> TYPE: <code>Sequence[float]</code> </p> Source code in <code>fractal_tasks_core/roi/v1_overlaps.py</code> <pre><code>def get_overlapping_pairs_3D(\n    tmp_df: pd.DataFrame,\n    full_res_pxl_sizes_zyx: Sequence[float],\n):\n\"\"\"\n    Finds the indices for the all overlapping FOVs pair, in three dimensions.\n\n    Note: the returned indices are positional indices, starting from 0.\n\n    Args:\n        tmp_df: Dataframe with columns `{x,y,z}_micrometer` and\n            `len_{x,y,z}_micrometer`.\n        full_res_pxl_sizes_zyx: TBD\n    \"\"\"\n\n    tol = 1e-10\n    if tol &gt; min(full_res_pxl_sizes_zyx) / 1e3:\n        raise ValueError(f\"{tol=} but {full_res_pxl_sizes_zyx=}\")\n\n    new_tmp_df = tmp_df.copy()\n\n    new_tmp_df[\"x_micrometer_max\"] = (\n        new_tmp_df[\"x_micrometer\"] + new_tmp_df[\"len_x_micrometer\"]\n    )\n    new_tmp_df[\"y_micrometer_max\"] = (\n        new_tmp_df[\"y_micrometer\"] + new_tmp_df[\"len_y_micrometer\"]\n    )\n    new_tmp_df[\"z_micrometer_max\"] = (\n        new_tmp_df[\"z_micrometer\"] + new_tmp_df[\"len_z_micrometer\"]\n    )\n    # Remove columns which are not necessary for overlap checks\n    list_columns = [\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n        \"label\",\n    ]\n    new_tmp_df.drop(labels=list_columns, axis=1, inplace=True)\n\n    # Loop over all pairs, and construct list of overlapping ones\n    num_lines = len(new_tmp_df.index)\n    overlapping_list = []\n    for pos_ind_1 in range(num_lines):\n        for pos_ind_2 in range(pos_ind_1):\n            bbox_1 = new_tmp_df.iloc[pos_ind_1].to_numpy()\n            bbox_2 = new_tmp_df.iloc[pos_ind_2].to_numpy()\n            overlap = is_overlapping_3D(bbox_1, bbox_2, tol=tol)\n            if overlap:\n                overlapping_list.append((pos_ind_1, pos_ind_2))\n    return overlapping_list\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/#fractal_tasks_core.roi.get_single_image_ROI","title":"<code>get_single_image_ROI(array_shape, pixels_ZYX)</code>","text":"<p>Produce a table with a single ROI that covers the whole array</p> <p>TODO: make this flexible with respect to the presence/absence of Z.</p> PARAMETER DESCRIPTION <code>array_shape</code> <p>ZYX shape of the image array.</p> <p> TYPE: <code>tuple[int, int, int]</code> </p> <code>pixels_ZYX</code> <p>ZYX pixel sizes in micrometers.</p> <p> TYPE: <code>list[float]</code> </p> RETURNS DESCRIPTION <code>AnnData</code> <p>An <code>AnnData</code> table with a single ROI.</p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def get_single_image_ROI(\n    array_shape: tuple[int, int, int],\n    pixels_ZYX: list[float],\n) -&gt; ad.AnnData:\n\"\"\"\n    Produce a table with a single ROI that covers the whole array\n\n    TODO: make this flexible with respect to the presence/absence of Z.\n\n    Args:\n        array_shape: ZYX shape of the image array.\n        pixels_ZYX: ZYX pixel sizes in micrometers.\n\n    Returns:\n        An `AnnData` table with a single ROI.\n    \"\"\"\n    shape_z, shape_y, shape_x = array_shape[-3:]\n    ROI_table = ad.AnnData(\n        X=np.array(\n            [\n                [\n                    0.0,\n                    0.0,\n                    0.0,\n                    shape_x * pixels_ZYX[2],\n                    shape_y * pixels_ZYX[1],\n                    shape_z * pixels_ZYX[0],\n                ],\n            ],\n            dtype=np.float32,\n        )\n    )\n    ROI_table.obs_names = [\"image_1\"]\n    ROI_table.var_names = [\n        \"x_micrometer\",\n        \"y_micrometer\",\n        \"z_micrometer\",\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n    ]\n    return ROI_table\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/#fractal_tasks_core.roi.is_ROI_table_valid","title":"<code>is_ROI_table_valid(*, table_path, use_masks)</code>","text":"<p>Verify some validity assumptions on a ROI table.</p> <p>This function reflects our current working assumptions (e.g. the presence of some specific columns); this may change in future versions.</p> <p>If <code>use_masks=True</code>, we verify that the table is a valid <code>masking_roi_table</code> as of table specifications V1; if this check fails, <code>use_masks</code> should be set to <code>False</code> upstream in the parent function.</p> PARAMETER DESCRIPTION <code>table_path</code> <p>Path of the AnnData ROI table to be checked.</p> <p> TYPE: <code>str</code> </p> <code>use_masks</code> <p>If <code>True</code>, perform some additional checks related to masked loading.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Optional[bool]</code> <p>Always <code>None</code> if <code>use_masks=False</code>, otherwise return whether the table is valid for masked loading.</p> Source code in <code>fractal_tasks_core/roi/v1_checks.py</code> <pre><code>def is_ROI_table_valid(*, table_path: str, use_masks: bool) -&gt; Optional[bool]:\n\"\"\"\n    Verify some validity assumptions on a ROI table.\n\n    This function reflects our current working assumptions (e.g. the presence\n    of some specific columns); this may change in future versions.\n\n    If `use_masks=True`, we verify that the table is a valid\n    `masking_roi_table` as of table specifications V1; if this check fails,\n    `use_masks` should be set to `False` upstream in the parent function.\n\n    Args:\n        table_path: Path of the AnnData ROI table to be checked.\n        use_masks: If `True`, perform some additional checks related to\n            masked loading.\n\n    Returns:\n        Always `None` if `use_masks=False`, otherwise return whether the table\n            is valid for masked loading.\n    \"\"\"\n\n    table = ad.read_zarr(table_path)\n    are_ROI_table_columns_valid(table=table)\n    if not use_masks:\n        return None\n\n    # Check whether the table can be used for masked loading\n    attrs = zarr.group(table_path).attrs.asdict()\n    logger.info(f\"ROI table at {table_path} has attrs: {attrs}\")\n    try:\n        MaskingROITableAttrs(**attrs)\n        logging.info(\"ROI table can be used for masked loading\")\n        return True\n    except ValidationError:\n        logging.info(\"ROI table cannot be used for masked loading\")\n        return False\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/#fractal_tasks_core.roi.is_overlapping_1D","title":"<code>is_overlapping_1D(line1, line2, tol=1e-10)</code>","text":"<p>Given two intervals, finds whether they overlap.</p> <p>This is based on https://stackoverflow.com/a/70023212/19085332, and we additionally use a finite tolerance for floating-point comparisons.</p> PARAMETER DESCRIPTION <code>line1</code> <p>The boundaries of the first interval, written as <code>[x_min, x_max]</code>.</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>line2</code> <p>The boundaries of the second interval, written as <code>[x_min, x_max]</code>.</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>tol</code> <p>Finite tolerance for floating-point comparisons.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-10</code> </p> Source code in <code>fractal_tasks_core/roi/_overlaps_common.py</code> <pre><code>def is_overlapping_1D(\n    line1: Sequence[float], line2: Sequence[float], tol: float = 1e-10\n) -&gt; bool:\n\"\"\"\n    Given two intervals, finds whether they overlap.\n\n    This is based on https://stackoverflow.com/a/70023212/19085332, and we\n    additionally use a finite tolerance for floating-point comparisons.\n\n    Args:\n        line1: The boundaries of the first interval, written as\n            `[x_min, x_max]`.\n        line2: The boundaries of the second interval, written as\n            `[x_min, x_max]`.\n        tol: Finite tolerance for floating-point comparisons.\n    \"\"\"\n    return line1[0] &lt;= line2[1] - tol and line2[0] &lt;= line1[1] - tol\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/#fractal_tasks_core.roi.is_overlapping_2D","title":"<code>is_overlapping_2D(box1, box2, tol=1e-10)</code>","text":"<p>Given two rectangular boxes, finds whether they overlap.</p> <p>This is based on https://stackoverflow.com/a/70023212/19085332, and we additionally use a finite tolerance for floating-point comparisons.</p> PARAMETER DESCRIPTION <code>box1</code> <p>The boundaries of the first rectangle, written as <code>[x_min, y_min, x_max, y_max]</code>.</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>box2</code> <p>The boundaries of the second rectangle, written as <code>[x_min, y_min, x_max, y_max]</code>.</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>tol</code> <p>Finite tolerance for floating-point comparisons.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-10</code> </p> Source code in <code>fractal_tasks_core/roi/_overlaps_common.py</code> <pre><code>def is_overlapping_2D(\n    box1: Sequence[float], box2: Sequence[float], tol: float = 1e-10\n) -&gt; bool:\n\"\"\"\n    Given two rectangular boxes, finds whether they overlap.\n\n    This is based on https://stackoverflow.com/a/70023212/19085332, and we\n    additionally use a finite tolerance for floating-point comparisons.\n\n    Args:\n        box1: The boundaries of the first rectangle, written as\n            `[x_min, y_min, x_max, y_max]`.\n        box2: The boundaries of the second rectangle, written as\n            `[x_min, y_min, x_max, y_max]`.\n        tol: Finite tolerance for floating-point comparisons.\n    \"\"\"\n    overlap_x = is_overlapping_1D(\n        [box1[0], box1[2]], [box2[0], box2[2]], tol=tol\n    )\n    overlap_y = is_overlapping_1D(\n        [box1[1], box1[3]], [box2[1], box2[3]], tol=tol\n    )\n    return overlap_x and overlap_y\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/#fractal_tasks_core.roi.is_overlapping_3D","title":"<code>is_overlapping_3D(box1, box2, tol=1e-10)</code>","text":"<p>Given two three-dimensional boxes, finds whether they overlap.</p> <p>This is based on https://stackoverflow.com/a/70023212/19085332, and we additionally use a finite tolerance for floating-point comparisons.</p> PARAMETER DESCRIPTION <code>box1</code> <p>The boundaries of the first box, written as <code>[x_min, y_min, z_min, x_max, y_max, z_max]</code>.</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>box2</code> <p>The boundaries of the second box, written as <code>[x_min, y_min, z_min, x_max, y_max, z_max]</code>.</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>tol</code> <p>Finite tolerance for floating-point comparisons.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-10</code> </p> Source code in <code>fractal_tasks_core/roi/_overlaps_common.py</code> <pre><code>def is_overlapping_3D(\n    box1: Sequence[float], box2: Sequence[float], tol: float = 1e-10\n) -&gt; bool:\n\"\"\"\n    Given two three-dimensional boxes, finds whether they overlap.\n\n    This is based on https://stackoverflow.com/a/70023212/19085332, and we\n    additionally use a finite tolerance for floating-point comparisons.\n\n    Args:\n        box1: The boundaries of the first box, written as\n            `[x_min, y_min, z_min, x_max, y_max, z_max]`.\n        box2: The boundaries of the second box, written as\n            `[x_min, y_min, z_min, x_max, y_max, z_max]`.\n        tol: Finite tolerance for floating-point comparisons.\n    \"\"\"\n\n    overlap_x = is_overlapping_1D(\n        [box1[0], box1[3]], [box2[0], box2[3]], tol=tol\n    )\n    overlap_y = is_overlapping_1D(\n        [box1[1], box1[4]], [box2[1], box2[4]], tol=tol\n    )\n    overlap_z = is_overlapping_1D(\n        [box1[2], box1[5]], [box2[2], box2[5]], tol=tol\n    )\n    return overlap_x and overlap_y and overlap_z\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/#fractal_tasks_core.roi.is_standard_roi_table","title":"<code>is_standard_roi_table(table)</code>","text":"<p>True if the name of the table contains one of the standard Fractal tables</p> <p>If a table name is well_ROI_table, FOV_ROI_table or contains either of the two (e.g. registered_FOV_ROI_table), this function returns True.</p> PARAMETER DESCRIPTION <code>table</code> <p>table name</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>bool of whether it's a standard ROI table</p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def is_standard_roi_table(table: str) -&gt; bool:\n\"\"\"\n    True if the name of the table contains one of the standard Fractal tables\n\n    If a table name is well_ROI_table, FOV_ROI_table or contains either of the\n    two (e.g. registered_FOV_ROI_table), this function returns True.\n\n    Args:\n        table: table name\n\n    Returns:\n        bool of whether it's a standard ROI table\n\n    \"\"\"\n    if \"well_ROI_table\" in table:\n        return True\n    elif \"FOV_ROI_table\" in table:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/#fractal_tasks_core.roi.prepare_FOV_ROI_table","title":"<code>prepare_FOV_ROI_table(df, metadata=('time',))</code>","text":"<p>Prepare an AnnData table for fields-of-view ROIs.</p> PARAMETER DESCRIPTION <code>df</code> <p>Input dataframe, possibly prepared through <code>parse_yokogawa_metadata</code>.</p> <p> TYPE: <code>DataFrame</code> </p> <code>metadata</code> <p>Columns of <code>df</code> to be stored (if present) into AnnData table <code>obs</code>.</p> <p> TYPE: <code>tuple[str, ...]</code> DEFAULT: <code>('time',)</code> </p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def prepare_FOV_ROI_table(\n    df: pd.DataFrame, metadata: tuple[str, ...] = (\"time\",)\n) -&gt; ad.AnnData:\n\"\"\"\n    Prepare an AnnData table for fields-of-view ROIs.\n\n    Args:\n        df:\n            Input dataframe, possibly prepared through\n            `parse_yokogawa_metadata`.\n        metadata:\n            Columns of `df` to be stored (if present) into AnnData table `obs`.\n    \"\"\"\n\n    # Make a local copy of the dataframe, to avoid SettingWithCopyWarning\n    df = df.copy()\n\n    # Convert DataFrame index to str, to avoid\n    # &gt;&gt; ImplicitModificationWarning: Transforming to str index\n    # when creating AnnData object.\n    # Do this in the beginning to allow concatenation with e.g. time\n    df.index = df.index.astype(str)\n\n    # Obtain box size in physical units\n    df = df.assign(len_x_micrometer=df.x_pixel * df.pixel_size_x)\n    df = df.assign(len_y_micrometer=df.y_pixel * df.pixel_size_y)\n    df = df.assign(len_z_micrometer=df.z_pixel * df.pixel_size_z)\n\n    # Select only the numeric positional columns needed to define ROIs\n    # (to avoid) casting things like the data column to float32\n    # or to use unnecessary columns like bit_depth\n    positional_columns = [\n        \"x_micrometer\",\n        \"y_micrometer\",\n        \"z_micrometer\",\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n        \"x_micrometer_original\",\n        \"y_micrometer_original\",\n    ]\n\n    # Assign dtype explicitly, to avoid\n    # &gt;&gt; UserWarning: X converted to numpy array with dtype float64\n    # when creating AnnData object\n    df_roi = df.loc[:, positional_columns].astype(np.float32)\n\n    # Create an AnnData object directly from the DataFrame\n    adata = ad.AnnData(X=df_roi)\n\n    # Reset origin of the FOV ROI table, so that it matches with the well\n    # origin\n    adata = reset_origin(adata)\n\n    # Save any metadata that is specified to the obs df\n    for col in metadata:\n        if col in df:\n            # Cast all metadata to str.\n            # Reason: AnnData Zarr writers don't support all pandas types.\n            # e.g. pandas.core.arrays.datetimes.DatetimeArray can't be written\n            adata.obs[col] = df[col].astype(str)\n\n    # Rename rows and columns: Maintain FOV indices from the dataframe\n    # (they are already enforced to be unique by Pandas and may contain\n    # information for the user, as they are based on the filenames)\n    adata.obs_names = \"FOV_\" + adata.obs.index\n    adata.var_names = list(map(str, df_roi.columns))\n\n    return adata\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/#fractal_tasks_core.roi.prepare_well_ROI_table","title":"<code>prepare_well_ROI_table(df, metadata=('time',))</code>","text":"<p>Prepare an AnnData table with a single well ROI.</p> PARAMETER DESCRIPTION <code>df</code> <p>Input dataframe, possibly prepared through <code>parse_yokogawa_metadata</code>.</p> <p> TYPE: <code>DataFrame</code> </p> <code>metadata</code> <p>Columns of <code>df</code> to be stored (if present) into AnnData table <code>obs</code>.</p> <p> TYPE: <code>tuple[str, ...]</code> DEFAULT: <code>('time',)</code> </p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def prepare_well_ROI_table(\n    df: pd.DataFrame, metadata: tuple[str, ...] = (\"time\",)\n) -&gt; ad.AnnData:\n\"\"\"\n    Prepare an AnnData table with a single well ROI.\n\n    Args:\n        df:\n            Input dataframe, possibly prepared through\n            `parse_yokogawa_metadata`.\n        metadata:\n            Columns of `df` to be stored (if present) into AnnData table `obs`.\n    \"\"\"\n\n    # Make a local copy of the dataframe, to avoid SettingWithCopyWarning\n    df = df.copy()\n\n    # Convert DataFrame index to str, to avoid\n    # &gt;&gt; ImplicitModificationWarning: Transforming to str index\n    # when creating AnnData object.\n    # Do this in the beginning to allow concatenation with e.g. time\n    df.index = df.index.astype(str)\n\n    # Calculate bounding box extents in physical units\n    for mu in [\"x\", \"y\", \"z\"]:\n        # Obtain per-FOV properties in physical units.\n        # NOTE: a FOV ROI is defined here as the interval [min_micrometer,\n        # max_micrometer], with max_micrometer=min_micrometer+len_micrometer\n        min_micrometer = df[f\"{mu}_micrometer\"]\n        len_micrometer = df[f\"{mu}_pixel\"] * df[f\"pixel_size_{mu}\"]\n        max_micrometer = min_micrometer + len_micrometer\n        # Obtain well bounding box, in physical units\n        min_min_micrometer = min_micrometer.min()\n        max_max_micrometer = max_micrometer.max()\n        df[f\"{mu}_micrometer\"] = min_min_micrometer\n        df[f\"len_{mu}_micrometer\"] = max_max_micrometer - min_min_micrometer\n\n    # Select only the numeric positional columns needed to define ROIs\n    # (to avoid) casting things like the data column to float32\n    # or to use unnecessary columns like bit_depth\n    positional_columns = [\n        \"x_micrometer\",\n        \"y_micrometer\",\n        \"z_micrometer\",\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n    ]\n\n    # Assign dtype explicitly, to avoid\n    # &gt;&gt; UserWarning: X converted to numpy array with dtype float64\n    # when creating AnnData object\n    df_roi = df.iloc[0:1, :].loc[:, positional_columns].astype(np.float32)\n\n    # Create an AnnData object directly from the DataFrame\n    adata = ad.AnnData(X=df_roi)\n\n    # Reset origin of the single-entry well ROI table\n    adata = reset_origin(adata)\n\n    # Save any metadata that is specified to the obs df\n    for col in metadata:\n        if col in df:\n            # Cast all metadata to str.\n            # Reason: AnnData Zarr writers don't support all pandas types.\n            # e.g. pandas.core.arrays.datetimes.DatetimeArray can't be written\n            adata.obs[col] = df[col].astype(str)\n\n    # Rename rows and columns: Maintain FOV indices from the dataframe\n    # (they are already enforced to be unique by Pandas and may contain\n    # information for the user, as they are based on the filenames)\n    adata.obs_names = \"well_\" + adata.obs.index\n    adata.var_names = list(map(str, df_roi.columns))\n\n    return adata\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/#fractal_tasks_core.roi.remove_FOV_overlaps","title":"<code>remove_FOV_overlaps(df)</code>","text":"<p>Given a metadata dataframe, shift its columns to remove FOV overlaps.</p> PARAMETER DESCRIPTION <code>df</code> <p>Metadata dataframe.</p> <p> TYPE: <code>DataFrame</code> </p> Source code in <code>fractal_tasks_core/roi/v1_overlaps.py</code> <pre><code>def remove_FOV_overlaps(df: pd.DataFrame):\n\"\"\"\n    Given a metadata dataframe, shift its columns to remove FOV overlaps.\n\n    Args:\n        df: Metadata dataframe.\n    \"\"\"\n\n    # Set tolerance (this should be much smaller than pixel size or expected\n    # round-offs), and maximum number of iterations in constraint solver\n    tol = 1e-10\n    max_iterations = 200\n\n    # Create a local copy of the dataframe\n    df = df.copy()\n\n    # Create temporary columns (to streamline overlap removals), which are\n    # then removed at the end of the remove_FOV_overlaps function\n    df[\"xmin\"] = df[\"x_micrometer\"]\n    df[\"ymin\"] = df[\"y_micrometer\"]\n    df[\"xmax\"] = df[\"x_micrometer\"] + df[\"pixel_size_x\"] * df[\"x_pixel\"]\n    df[\"ymax\"] = df[\"y_micrometer\"] + df[\"pixel_size_y\"] * df[\"y_pixel\"]\n    list_columns = [\"xmin\", \"ymin\", \"xmax\", \"ymax\"]\n\n    # Create columns with the original positions (not to be removed)\n    df[\"x_micrometer_original\"] = df[\"x_micrometer\"]\n    df[\"y_micrometer_original\"] = df[\"y_micrometer\"]\n\n    # Check that tolerance is much smaller than pixel sizes\n    min_pixel_size = df[[\"pixel_size_x\", \"pixel_size_y\"]].min().min()\n    if tol &gt; min_pixel_size / 1e3:\n        raise ValueError(\n            f\"In remove_FOV_overlaps, {tol=} but {min_pixel_size=}\"\n        )\n\n    # Loop over wells\n    wells = sorted(list(set([ind[0] for ind in df.index])))\n    for well in wells:\n        logger.info(f\"removing FOV overlaps for {well=}\")\n        df_well = df.loc[well].copy()\n\n        # NOTE: these are positional indices (i.e. starting from 0)\n        pair_pos_indices = get_overlapping_pair(df_well[list_columns], tol=tol)\n\n        # Keep going until there are no overlaps, or until iteration reaches\n        # max_iterations\n        iteration = 0\n        while pair_pos_indices:\n            iteration += 1\n\n            # Identify overlapping FOVs\n            pos_ind_1, pos_ind_2 = pair_pos_indices\n            fov_id_1 = df_well.index[pos_ind_1]\n            fov_id_2 = df_well.index[pos_ind_2]\n            xmin_1, ymin_1, xmax_1, ymax_1 = df_well[list_columns].iloc[\n                pos_ind_1\n            ]\n            xmin_2, ymin_2, xmax_2, ymax_2 = df_well[list_columns].iloc[\n                pos_ind_2\n            ]\n            logger.debug(\n                f\"{well=}, {iteration=}, removing overlap between\"\n                f\" {fov_id_1=} and {fov_id_2=}\"\n            )\n\n            # Check what kind of overlap is there (X, Y, or XY)\n            is_x_equal = abs(xmin_1 - xmin_2) &lt; tol and (xmax_1 - xmax_2) &lt; tol\n            is_y_equal = abs(ymin_1 - ymin_2) &lt; tol and (ymax_1 - ymax_2) &lt; tol\n            is_x_overlap = is_overlapping_1D(\n                [xmin_1, xmax_1], [xmin_2, xmax_2], tol=tol\n            )\n            is_y_overlap = is_overlapping_1D(\n                [ymin_1, ymax_1], [ymin_2, ymax_2], tol=tol\n            )\n\n            if is_x_equal and is_y_overlap:\n                # Y overlap\n                df_well = apply_shift_in_one_direction(\n                    df_well,\n                    [ymin_1, ymax_1],\n                    [ymin_2, ymax_2],\n                    mu=\"y\",\n                    tol=tol,\n                )\n            elif is_y_equal and is_x_overlap:\n                # X overlap\n                df_well = apply_shift_in_one_direction(\n                    df_well,\n                    [xmin_1, xmax_1],\n                    [xmin_2, xmax_2],\n                    mu=\"x\",\n                    tol=tol,\n                )\n            elif not (is_x_equal or is_y_equal) and (\n                is_x_overlap and is_y_overlap\n            ):\n                # XY overlap\n                df_well = apply_shift_in_one_direction(\n                    df_well,\n                    [xmin_1, xmax_1],\n                    [xmin_2, xmax_2],\n                    mu=\"x\",\n                    tol=tol,\n                )\n                df_well = apply_shift_in_one_direction(\n                    df_well,\n                    [ymin_1, ymax_1],\n                    [ymin_2, ymax_2],\n                    mu=\"y\",\n                    tol=tol,\n                )\n            else:\n                raise ValueError(\n                    \"Trying to remove overlap which is not there.\"\n                )\n\n            # Look for next overlapping FOV pair\n            pair_pos_indices = get_overlapping_pair(\n                df_well[list_columns], tol=tol\n            )\n\n            # Enforce maximum number of iterations\n            if iteration &gt;= max_iterations:\n                raise ValueError(f\"Reached {max_iterations=} for {well=}\")\n\n        # Note: using df.loc[well] = df_well leads to a NaN dataframe, see\n        # for instance https://stackoverflow.com/a/28432733/19085332\n        df.loc[well, :] = df_well.values\n\n    # Remove temporary columns that were added only as part of this function\n    df.drop(list_columns, axis=1, inplace=True)\n\n    return df\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/#fractal_tasks_core.roi.reset_origin","title":"<code>reset_origin(ROI_table, x_pos='x_micrometer', y_pos='y_micrometer', z_pos='z_micrometer')</code>","text":"<p>Return a copy of a ROI table, with shifted-to-zero origin for some columns.</p> PARAMETER DESCRIPTION <code>ROI_table</code> <p>Original ROI table.</p> <p> TYPE: <code>AnnData</code> </p> <code>x_pos</code> <p>Name of the column with X position of ROIs.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'x_micrometer'</code> </p> <code>y_pos</code> <p>Name of the column with Y position of ROIs.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'y_micrometer'</code> </p> <code>z_pos</code> <p>Name of the column with Z position of ROIs.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'z_micrometer'</code> </p> RETURNS DESCRIPTION <code>AnnData</code> <p>A copy of the <code>ROI_table</code> AnnData table, where values of <code>x_pos</code>, <code>y_pos</code> and <code>z_pos</code> columns have been shifted by their minimum values.</p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def reset_origin(\n    ROI_table: ad.AnnData,\n    x_pos: str = \"x_micrometer\",\n    y_pos: str = \"y_micrometer\",\n    z_pos: str = \"z_micrometer\",\n) -&gt; ad.AnnData:\n\"\"\"\n    Return a copy of a ROI table, with shifted-to-zero origin for some columns.\n\n    Args:\n        ROI_table: Original ROI table.\n        x_pos: Name of the column with X position of ROIs.\n        y_pos: Name of the column with Y position of ROIs.\n        z_pos: Name of the column with Z position of ROIs.\n\n    Returns:\n        A copy of the `ROI_table` AnnData table, where values of `x_pos`,\n            `y_pos` and `z_pos` columns have been shifted by their minimum\n            values.\n    \"\"\"\n    new_table = ROI_table.copy()\n\n    origin_x = min(new_table[:, x_pos].X[:, 0])\n    origin_y = min(new_table[:, y_pos].X[:, 0])\n    origin_z = min(new_table[:, z_pos].X[:, 0])\n\n    for FOV in new_table.obs_names:\n        new_table[FOV, x_pos] = new_table[FOV, x_pos].X[0, 0] - origin_x\n        new_table[FOV, y_pos] = new_table[FOV, y_pos].X[0, 0] - origin_y\n        new_table[FOV, z_pos] = new_table[FOV, z_pos].X[0, 0] - origin_z\n\n    return new_table\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/#fractal_tasks_core.roi.run_overlap_check","title":"<code>run_overlap_check(site_metadata, tol=1e-10, plotting_function=None)</code>","text":"<p>Run an overlap check over all wells and optionally plots overlaps.</p> <p>This function is currently only used in tests and examples.</p> <p>The <code>plotting_function</code> parameter is exposed so that other tools (see examples in this repository) may use it to show the FOV ROIs. Its arguments are: <code>[xmin, xmax, ymin, ymax, list_overlapping_FOVs, selected_well]</code>.</p> PARAMETER DESCRIPTION <code>site_metadata</code> <p>TBD</p> <p> TYPE: <code>DataFrame</code> </p> <code>tol</code> <p>TBD</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-10</code> </p> <code>plotting_function</code> <p>TBD</p> <p> TYPE: <code>Optional[Callable]</code> DEFAULT: <code>None</code> </p> Source code in <code>fractal_tasks_core/roi/v1_overlaps.py</code> <pre><code>def run_overlap_check(\n    site_metadata: pd.DataFrame,\n    tol: float = 1e-10,\n    plotting_function: Optional[Callable] = None,\n):\n\"\"\"\n    Run an overlap check over all wells and optionally plots overlaps.\n\n    This function is currently only used in tests and examples.\n\n    The `plotting_function` parameter is exposed so that other tools (see\n    examples in this repository) may use it to show the FOV ROIs. Its arguments\n    are: `[xmin, xmax, ymin, ymax, list_overlapping_FOVs, selected_well]`.\n\n    Args:\n        site_metadata: TBD\n        tol: TBD\n        plotting_function: TBD\n    \"\"\"\n\n    if plotting_function is None:\n\n        def plotting_function(\n            xmin, xmax, ymin, ymax, list_overlapping_FOVs, selected_well\n        ):\n            pass\n\n    wells = site_metadata.index.unique(level=\"well_id\")\n    overlapping_FOVs = []\n    for selected_well in wells:\n        overlap_curr_well = check_well_for_FOV_overlap(\n            site_metadata,\n            selected_well=selected_well,\n            tol=tol,\n            plotting_function=plotting_function,\n        )\n        if overlap_curr_well:\n            print(selected_well)\n            overlapping_FOVs.append(overlap_curr_well)\n\n    return overlapping_FOVs\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/_overlaps_common/","title":"_overlaps_common","text":"<p>Functions to identify overlaps between regions, not related to table specs.</p>"},{"location":"reference/fractal_tasks_core/roi/_overlaps_common/#fractal_tasks_core.roi._overlaps_common._is_overlapping_1D_int","title":"<code>_is_overlapping_1D_int(line1, line2)</code>","text":"<p>Given two integer intervals, find whether they overlap</p> <p>This is the same as <code>is_overlapping_1D</code> (based on https://stackoverflow.com/a/70023212/19085332), for integer-valued intervals.</p> PARAMETER DESCRIPTION <code>line1</code> <p>The boundaries of the first interval , written as <code>[x_min, x_max]</code>.</p> <p> TYPE: <code>Sequence[int]</code> </p> <code>line2</code> <p>The boundaries of the second interval , written as <code>[x_min, x_max]</code>.</p> <p> TYPE: <code>Sequence[int]</code> </p> Source code in <code>fractal_tasks_core/roi/_overlaps_common.py</code> <pre><code>def _is_overlapping_1D_int(\n    line1: Sequence[int],\n    line2: Sequence[int],\n) -&gt; bool:\n\"\"\"\n    Given two integer intervals, find whether they overlap\n\n    This is the same as `is_overlapping_1D` (based on\n    https://stackoverflow.com/a/70023212/19085332), for integer-valued\n    intervals.\n\n    Args:\n        line1: The boundaries of the first interval , written as\n            `[x_min, x_max]`.\n        line2: The boundaries of the second interval , written as\n            `[x_min, x_max]`.\n    \"\"\"\n    return line1[0] &lt; line2[1] and line2[0] &lt; line1[1]\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/_overlaps_common/#fractal_tasks_core.roi._overlaps_common._is_overlapping_3D_int","title":"<code>_is_overlapping_3D_int(box1, box2)</code>","text":"<p>Given two three-dimensional integer boxes, find whether they overlap.</p> <p>This is the same as is_overlapping_3D (based on https://stackoverflow.com/a/70023212/19085332), for integer-valued boxes.</p> PARAMETER DESCRIPTION <code>box1</code> <p>The boundaries of the first box, written as <code>[x_min, y_min, z_min, x_max, y_max, z_max]</code>.</p> <p> TYPE: <code>list[int]</code> </p> <code>box2</code> <p>The boundaries of the second box, written as <code>[x_min, y_min, z_min, x_max, y_max, z_max]</code>.</p> <p> TYPE: <code>list[int]</code> </p> Source code in <code>fractal_tasks_core/roi/_overlaps_common.py</code> <pre><code>def _is_overlapping_3D_int(box1: list[int], box2: list[int]) -&gt; bool:\n\"\"\"\n    Given two three-dimensional integer boxes, find whether they overlap.\n\n    This is the same as is_overlapping_3D (based on\n    https://stackoverflow.com/a/70023212/19085332), for integer-valued\n    boxes.\n\n    Args:\n        box1: The boundaries of the first box, written as\n            `[x_min, y_min, z_min, x_max, y_max, z_max]`.\n        box2: The boundaries of the second box, written as\n            `[x_min, y_min, z_min, x_max, y_max, z_max]`.\n    \"\"\"\n    overlap_x = _is_overlapping_1D_int([box1[0], box1[3]], [box2[0], box2[3]])\n    overlap_y = _is_overlapping_1D_int([box1[1], box1[4]], [box2[1], box2[4]])\n    overlap_z = _is_overlapping_1D_int([box1[2], box1[5]], [box2[2], box2[5]])\n    return overlap_x and overlap_y and overlap_z\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/_overlaps_common/#fractal_tasks_core.roi._overlaps_common.is_overlapping_1D","title":"<code>is_overlapping_1D(line1, line2, tol=1e-10)</code>","text":"<p>Given two intervals, finds whether they overlap.</p> <p>This is based on https://stackoverflow.com/a/70023212/19085332, and we additionally use a finite tolerance for floating-point comparisons.</p> PARAMETER DESCRIPTION <code>line1</code> <p>The boundaries of the first interval, written as <code>[x_min, x_max]</code>.</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>line2</code> <p>The boundaries of the second interval, written as <code>[x_min, x_max]</code>.</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>tol</code> <p>Finite tolerance for floating-point comparisons.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-10</code> </p> Source code in <code>fractal_tasks_core/roi/_overlaps_common.py</code> <pre><code>def is_overlapping_1D(\n    line1: Sequence[float], line2: Sequence[float], tol: float = 1e-10\n) -&gt; bool:\n\"\"\"\n    Given two intervals, finds whether they overlap.\n\n    This is based on https://stackoverflow.com/a/70023212/19085332, and we\n    additionally use a finite tolerance for floating-point comparisons.\n\n    Args:\n        line1: The boundaries of the first interval, written as\n            `[x_min, x_max]`.\n        line2: The boundaries of the second interval, written as\n            `[x_min, x_max]`.\n        tol: Finite tolerance for floating-point comparisons.\n    \"\"\"\n    return line1[0] &lt;= line2[1] - tol and line2[0] &lt;= line1[1] - tol\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/_overlaps_common/#fractal_tasks_core.roi._overlaps_common.is_overlapping_2D","title":"<code>is_overlapping_2D(box1, box2, tol=1e-10)</code>","text":"<p>Given two rectangular boxes, finds whether they overlap.</p> <p>This is based on https://stackoverflow.com/a/70023212/19085332, and we additionally use a finite tolerance for floating-point comparisons.</p> PARAMETER DESCRIPTION <code>box1</code> <p>The boundaries of the first rectangle, written as <code>[x_min, y_min, x_max, y_max]</code>.</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>box2</code> <p>The boundaries of the second rectangle, written as <code>[x_min, y_min, x_max, y_max]</code>.</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>tol</code> <p>Finite tolerance for floating-point comparisons.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-10</code> </p> Source code in <code>fractal_tasks_core/roi/_overlaps_common.py</code> <pre><code>def is_overlapping_2D(\n    box1: Sequence[float], box2: Sequence[float], tol: float = 1e-10\n) -&gt; bool:\n\"\"\"\n    Given two rectangular boxes, finds whether they overlap.\n\n    This is based on https://stackoverflow.com/a/70023212/19085332, and we\n    additionally use a finite tolerance for floating-point comparisons.\n\n    Args:\n        box1: The boundaries of the first rectangle, written as\n            `[x_min, y_min, x_max, y_max]`.\n        box2: The boundaries of the second rectangle, written as\n            `[x_min, y_min, x_max, y_max]`.\n        tol: Finite tolerance for floating-point comparisons.\n    \"\"\"\n    overlap_x = is_overlapping_1D(\n        [box1[0], box1[2]], [box2[0], box2[2]], tol=tol\n    )\n    overlap_y = is_overlapping_1D(\n        [box1[1], box1[3]], [box2[1], box2[3]], tol=tol\n    )\n    return overlap_x and overlap_y\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/_overlaps_common/#fractal_tasks_core.roi._overlaps_common.is_overlapping_3D","title":"<code>is_overlapping_3D(box1, box2, tol=1e-10)</code>","text":"<p>Given two three-dimensional boxes, finds whether they overlap.</p> <p>This is based on https://stackoverflow.com/a/70023212/19085332, and we additionally use a finite tolerance for floating-point comparisons.</p> PARAMETER DESCRIPTION <code>box1</code> <p>The boundaries of the first box, written as <code>[x_min, y_min, z_min, x_max, y_max, z_max]</code>.</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>box2</code> <p>The boundaries of the second box, written as <code>[x_min, y_min, z_min, x_max, y_max, z_max]</code>.</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>tol</code> <p>Finite tolerance for floating-point comparisons.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-10</code> </p> Source code in <code>fractal_tasks_core/roi/_overlaps_common.py</code> <pre><code>def is_overlapping_3D(\n    box1: Sequence[float], box2: Sequence[float], tol: float = 1e-10\n) -&gt; bool:\n\"\"\"\n    Given two three-dimensional boxes, finds whether they overlap.\n\n    This is based on https://stackoverflow.com/a/70023212/19085332, and we\n    additionally use a finite tolerance for floating-point comparisons.\n\n    Args:\n        box1: The boundaries of the first box, written as\n            `[x_min, y_min, z_min, x_max, y_max, z_max]`.\n        box2: The boundaries of the second box, written as\n            `[x_min, y_min, z_min, x_max, y_max, z_max]`.\n        tol: Finite tolerance for floating-point comparisons.\n    \"\"\"\n\n    overlap_x = is_overlapping_1D(\n        [box1[0], box1[3]], [box2[0], box2[3]], tol=tol\n    )\n    overlap_y = is_overlapping_1D(\n        [box1[1], box1[4]], [box2[1], box2[4]], tol=tol\n    )\n    overlap_z = is_overlapping_1D(\n        [box1[2], box1[5]], [box2[2], box2[5]], tol=tol\n    )\n    return overlap_x and overlap_y and overlap_z\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/load_region/","title":"load_region","text":""},{"location":"reference/fractal_tasks_core/roi/load_region/#fractal_tasks_core.roi.load_region.load_region","title":"<code>load_region(data_zyx, region, compute=True, return_as_3D=False)</code>","text":"<p>Load a region from a dask array.</p> <p>Can handle both 2D and 3D dask arrays as input and return them as is or always as a 3D array.</p> PARAMETER DESCRIPTION <code>data_zyx</code> <p>Dask array (2D or 3D).</p> <p> TYPE: <code>Array</code> </p> <code>region</code> <p>Region to load, tuple of three slices (ZYX).</p> <p> TYPE: <code>tuple[slice, slice, slice]</code> </p> <code>compute</code> <p>Whether to compute the result. If <code>True</code>, returns a numpy array. If <code>False</code>, returns a dask array.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>return_as_3D</code> <p>Whether to return a 3D array, even if the input is 2D.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Union[Array, ndarray]</code> <p>3D array.</p> Source code in <code>fractal_tasks_core/roi/load_region.py</code> <pre><code>def load_region(\n    data_zyx: da.Array,\n    region: tuple[slice, slice, slice],\n    compute: bool = True,\n    return_as_3D: bool = False,\n) -&gt; Union[da.Array, np.ndarray]:\n\"\"\"\n    Load a region from a dask array.\n\n    Can handle both 2D and 3D dask arrays as input and return them as is or\n    always as a 3D array.\n\n    Args:\n        data_zyx: Dask array (2D or 3D).\n        region: Region to load, tuple of three slices (ZYX).\n        compute: Whether to compute the result. If `True`, returns a numpy\n            array. If `False`, returns a dask array.\n        return_as_3D: Whether to return a 3D array, even if the input is 2D.\n\n    Returns:\n        3D array.\n    \"\"\"\n\n    if len(region) != 3:\n        raise ValueError(\n            f\"In `load_region`, `region` must have three elements \"\n            f\"(given: {len(region)}).\"\n        )\n\n    if len(data_zyx.shape) == 3:\n        img = data_zyx[region]\n    elif len(data_zyx.shape) == 2:\n        img = data_zyx[(region[1], region[2])]\n        if return_as_3D:\n            img = np.expand_dims(img, axis=0)\n    else:\n        raise ValueError(\n            f\"Shape {data_zyx.shape} not supported for `load_region`\"\n        )\n    if compute:\n        return img.compute()\n    else:\n        return img\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1/","title":"v1","text":"<p>Functions to produce/process ROI tables.</p>"},{"location":"reference/fractal_tasks_core/roi/v1/#fractal_tasks_core.roi.v1.array_to_bounding_box_table","title":"<code>array_to_bounding_box_table(mask_array, pxl_sizes_zyx, origin_zyx=(0, 0, 0))</code>","text":"<p>Construct bounding-box ROI table for a mask array.</p> PARAMETER DESCRIPTION <code>mask_array</code> <p>Original array to construct bounding boxes.</p> <p> TYPE: <code>ndarray</code> </p> <code>pxl_sizes_zyx</code> <p>Physical-unit pixel ZYX sizes.</p> <p> TYPE: <code>list[float]</code> </p> <code>origin_zyx</code> <p>Shift ROI origin by this amount of ZYX pixels.</p> <p> TYPE: <code>tuple[int, int, int]</code> DEFAULT: <code>(0, 0, 0)</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>DataFrame with each line representing the bounding-box ROI that corresponds to a unique value of <code>mask_array</code>. ROI properties are expressed in physical units (with columns defined as elsewhere this module - see e.g. <code>prepare_well_ROI_table</code>), and positions are optionally shifted (if <code>origin_zyx</code> is set). An additional column <code>label</code> keeps track of the <code>mask_array</code> value corresponding to each ROI.</p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def array_to_bounding_box_table(\n    mask_array: np.ndarray,\n    pxl_sizes_zyx: list[float],\n    origin_zyx: tuple[int, int, int] = (0, 0, 0),\n) -&gt; pd.DataFrame:\n\"\"\"\n    Construct bounding-box ROI table for a mask array.\n\n    Args:\n        mask_array: Original array to construct bounding boxes.\n        pxl_sizes_zyx: Physical-unit pixel ZYX sizes.\n        origin_zyx: Shift ROI origin by this amount of ZYX pixels.\n\n    Returns:\n        DataFrame with each line representing the bounding-box ROI that\n            corresponds to a unique value of `mask_array`. ROI properties are\n            expressed in physical units (with columns defined as elsewhere this\n            module - see e.g. `prepare_well_ROI_table`), and positions are\n            optionally shifted (if `origin_zyx` is set). An additional column\n            `label` keeps track of the `mask_array` value corresponding to each\n            ROI.\n    \"\"\"\n\n    pxl_sizes_zyx_array = np.array(pxl_sizes_zyx)\n    z_origin, y_origin, x_origin = origin_zyx[:]\n\n    labels = np.unique(mask_array)\n    labels = labels[labels &gt; 0]\n    elem_list = []\n    for label in labels:\n        # Compute bounding box\n        label_match = np.where(mask_array == label)\n        zmin, ymin, xmin = np.min(label_match, axis=1) * pxl_sizes_zyx_array\n        zmax, ymax, xmax = (\n            np.max(label_match, axis=1) + 1\n        ) * pxl_sizes_zyx_array\n\n        # Compute bounding-box edges\n        length_x = xmax - xmin\n        length_y = ymax - ymin\n        length_z = zmax - zmin\n\n        # Shift origin\n        zmin += z_origin * pxl_sizes_zyx[0]\n        ymin += y_origin * pxl_sizes_zyx[1]\n        xmin += x_origin * pxl_sizes_zyx[2]\n\n        elem_list.append((xmin, ymin, zmin, length_x, length_y, length_z))\n\n    df_columns = [\n        \"x_micrometer\",\n        \"y_micrometer\",\n        \"z_micrometer\",\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n    ]\n\n    if len(elem_list) == 0:\n        df = pd.DataFrame(columns=[x for x in df_columns] + [\"label\"])\n    else:\n        df = pd.DataFrame(np.array(elem_list), columns=df_columns)\n        df[\"label\"] = labels\n\n    return df\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1/#fractal_tasks_core.roi.v1.convert_ROI_table_to_indices","title":"<code>convert_ROI_table_to_indices(ROI, full_res_pxl_sizes_zyx, level=0, coarsening_xy=2, cols_xyz_pos=['x_micrometer', 'y_micrometer', 'z_micrometer'], cols_xyz_len=['len_x_micrometer', 'len_y_micrometer', 'len_z_micrometer'])</code>","text":"<p>Convert a ROI AnnData table into integer array indices.</p> PARAMETER DESCRIPTION <code>ROI</code> <p>AnnData table with list of ROIs.</p> <p> TYPE: <code>AnnData</code> </p> <code>full_res_pxl_sizes_zyx</code> <p>Physical-unit pixel ZYX sizes at the full-resolution pyramid level.</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>level</code> <p>Pyramid level.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>coarsening_xy</code> <p>Linear coarsening factor in the YX plane.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>cols_xyz_pos</code> <p>Column names for XYZ ROI positions.</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>['x_micrometer', 'y_micrometer', 'z_micrometer']</code> </p> <code>cols_xyz_len</code> <p>Column names for XYZ ROI edges.</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>['len_x_micrometer', 'len_y_micrometer', 'len_z_micrometer']</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If any of the array indices is negative.</p> RETURNS DESCRIPTION <code>list[list[int]]</code> <p>Nested list of indices. The main list has one item per ROI. Each ROI item is a list of six integers as in <code>[start_z, end_z, start_y, end_y, start_x, end_x]</code>. The array-index interval for a given ROI is <code>start_x:end_x</code> along X, and so on for Y and Z.</p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def convert_ROI_table_to_indices(\n    ROI: ad.AnnData,\n    full_res_pxl_sizes_zyx: Sequence[float],\n    level: int = 0,\n    coarsening_xy: int = 2,\n    cols_xyz_pos: Sequence[str] = [\n        \"x_micrometer\",\n        \"y_micrometer\",\n        \"z_micrometer\",\n    ],\n    cols_xyz_len: Sequence[str] = [\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n    ],\n) -&gt; list[list[int]]:\n\"\"\"\n    Convert a ROI AnnData table into integer array indices.\n\n    Args:\n        ROI: AnnData table with list of ROIs.\n        full_res_pxl_sizes_zyx:\n            Physical-unit pixel ZYX sizes at the full-resolution pyramid level.\n        level: Pyramid level.\n        coarsening_xy: Linear coarsening factor in the YX plane.\n        cols_xyz_pos: Column names for XYZ ROI positions.\n        cols_xyz_len: Column names for XYZ ROI edges.\n\n    Raises:\n        ValueError:\n            If any of the array indices is negative.\n\n    Returns:\n        Nested list of indices. The main list has one item per ROI. Each ROI\n            item is a list of six integers as in `[start_z, end_z, start_y,\n            end_y, start_x, end_x]`. The array-index interval for a given ROI\n            is `start_x:end_x` along X, and so on for Y and Z.\n    \"\"\"\n    # Handle empty ROI table\n    if len(ROI) == 0:\n        return []\n\n    # Set pyramid-level pixel sizes\n    pxl_size_z, pxl_size_y, pxl_size_x = full_res_pxl_sizes_zyx\n    prefactor = coarsening_xy**level\n    pxl_size_x *= prefactor\n    pxl_size_y *= prefactor\n\n    x_pos, y_pos, z_pos = cols_xyz_pos[:]\n    x_len, y_len, z_len = cols_xyz_len[:]\n\n    list_indices = []\n    for ROI_name in ROI.obs_names:\n        # Extract data from anndata table\n        x_micrometer = ROI[ROI_name, x_pos].X[0, 0]\n        y_micrometer = ROI[ROI_name, y_pos].X[0, 0]\n        z_micrometer = ROI[ROI_name, z_pos].X[0, 0]\n        len_x_micrometer = ROI[ROI_name, x_len].X[0, 0]\n        len_y_micrometer = ROI[ROI_name, y_len].X[0, 0]\n        len_z_micrometer = ROI[ROI_name, z_len].X[0, 0]\n\n        # Identify indices along the three dimensions\n        start_x = x_micrometer / pxl_size_x\n        end_x = (x_micrometer + len_x_micrometer) / pxl_size_x\n        start_y = y_micrometer / pxl_size_y\n        end_y = (y_micrometer + len_y_micrometer) / pxl_size_y\n        start_z = z_micrometer / pxl_size_z\n        end_z = (z_micrometer + len_z_micrometer) / pxl_size_z\n        indices = [start_z, end_z, start_y, end_y, start_x, end_x]\n\n        # Round indices to lower integer\n        indices = list(map(round, indices))\n\n        # Fail for negative indices\n        if min(indices) &lt; 0:\n            raise ValueError(\n                f\"ROI {ROI_name} converted into negative array indices.\\n\"\n                f\"ZYX position: {z_micrometer}, {y_micrometer}, \"\n                f\"{x_micrometer}\\n\"\n                f\"ZYX pixel sizes: {pxl_size_z}, {pxl_size_y}, \"\n                f\"{pxl_size_x} ({level=})\\n\"\n                \"Hint: As of fractal-tasks-core v0.12, FOV/well ROI \"\n                \"tables with non-zero origins (e.g. the ones created with \"\n                \"v0.11) are not supported.\"\n            )\n\n        # Append ROI indices to to list\n        list_indices.append(indices[:])\n\n    return list_indices\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1/#fractal_tasks_core.roi.v1.convert_ROIs_from_3D_to_2D","title":"<code>convert_ROIs_from_3D_to_2D(adata, pixel_size_z)</code>","text":"<p>TBD</p> <p>Note that this function is only relevant when the ROIs in adata span the whole extent of the Z axis. TODO: check this explicitly.</p> PARAMETER DESCRIPTION <code>adata</code> <p>TBD</p> <p> TYPE: <code>AnnData</code> </p> <code>pixel_size_z</code> <p>TBD</p> <p> TYPE: <code>float</code> </p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def convert_ROIs_from_3D_to_2D(\n    adata: ad.AnnData,\n    pixel_size_z: float,\n) -&gt; ad.AnnData:\n\"\"\"\n    TBD\n\n    Note that this function is only relevant when the ROIs in adata span the\n    whole extent of the Z axis.\n    TODO: check this explicitly.\n\n    Args:\n        adata: TBD\n        pixel_size_z: TBD\n    \"\"\"\n\n    # Compress a 3D stack of images to a single Z plane,\n    # with thickness equal to pixel_size_z\n    df = adata.to_df()\n    df[\"len_z_micrometer\"] = pixel_size_z\n\n    # Assign dtype explicitly, to avoid\n    # &gt;&gt; UserWarning: X converted to numpy array with dtype float64\n    # when creating AnnData object\n    df = df.astype(np.float32)\n\n    # Create an AnnData object directly from the DataFrame\n    new_adata = ad.AnnData(X=df)\n\n    # Rename rows and columns\n    new_adata.obs_names = adata.obs_names\n    new_adata.var_names = list(map(str, df.columns))\n\n    return new_adata\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1/#fractal_tasks_core.roi.v1.convert_indices_to_regions","title":"<code>convert_indices_to_regions(index)</code>","text":"<p>Converts index tuples to region tuple</p> PARAMETER DESCRIPTION <code>index</code> <p>Tuple containing 6 entries of (z_start, z_end, y_start, y_end, x_start, x_end).</p> <p> TYPE: <code>list[int]</code> </p> RETURNS DESCRIPTION <code>region</code> <p>tuple of three slices (ZYX)</p> <p> TYPE: <code>tuple[slice, slice, slice]</code> </p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def convert_indices_to_regions(\n    index: list[int],\n) -&gt; tuple[slice, slice, slice]:\n\"\"\"\n    Converts index tuples to region tuple\n\n    Args:\n        index: Tuple containing 6 entries of (z_start, z_end, y_start,\n            y_end, x_start, x_end).\n\n    Returns:\n        region: tuple of three slices (ZYX)\n    \"\"\"\n    return (\n        slice(index[0], index[1]),\n        slice(index[2], index[3]),\n        slice(index[4], index[5]),\n    )\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1/#fractal_tasks_core.roi.v1.create_roi_table_from_df_list","title":"<code>create_roi_table_from_df_list(bbox_dataframe_list)</code>","text":"<p>Creates an AnnData ROI table from a list of bounding-box tables</p> <p>This function handles empty bbox lists, ensures that it has unique entries per label (and to address #810, it handles duplicate labels by only keeping the first entry for each label) &amp; converts it to an AnnData table with a label column in obs.</p> PARAMETER DESCRIPTION <code>bbox_dataframe_list</code> <p>List of bounding box dataframes. All dataframes are expected to have the same columns and they usually are: x_micrometer, y_micrometer, z_micrometer, len_x_micrometer, len_y_micrometer, len_z_micrometer, label. The label column is required.</p> <p> TYPE: <code>list[DataFrame]</code> </p> RETURNS DESCRIPTION <code>AnnData</code> <p>An <code>AnnData</code> table with all the ROIs.</p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def create_roi_table_from_df_list(\n    bbox_dataframe_list: list[pd.DataFrame],\n) -&gt; ad.AnnData:\n\"\"\"\n    Creates an AnnData ROI table from a list of bounding-box tables\n\n    This function handles empty bbox lists, ensures that it has unique entries\n    per label (and to address #810, it handles duplicate labels by only\n    keeping the first entry for each label) &amp; converts it to an AnnData table\n    with a label column in obs.\n\n    Args:\n        bbox_dataframe_list: List of bounding box dataframes. All dataframes\n            are expected to have the same columns and they usually are:\n            x_micrometer, y_micrometer, z_micrometer, len_x_micrometer,\n            len_y_micrometer, len_z_micrometer, label. The label column is\n            required.\n\n    Returns:\n        An `AnnData` table with all the ROIs.\n    \"\"\"\n    # Handle the case where `bbox_dataframe_list` is empty (typically\n    # because list_indices is also empty)\n    if len(bbox_dataframe_list) == 0:\n        bbox_dataframe_list = [empty_bounding_box_table()]\n    # Concatenate all ROI dataframes\n    df_well = pd.concat(bbox_dataframe_list, axis=0, ignore_index=True)\n\n    # Drop duplicates based on the 'label' column, keeping only the first\n    # occurrence (see #810 for details)\n    df_well = df_well.drop_duplicates(subset=\"label\", keep=\"first\")\n\n    # Extract labels and drop them from df_well\n    labels = pd.DataFrame(df_well[\"label\"].astype(str)).reset_index(drop=True)\n\n    # Check that there are only unique labels. Should be ensured by check above\n    if len(labels[\"label\"]) != len(labels[\"label\"].unique()):\n        raise ValueError(\n            \"The output ROI table contains duplicate entries for labels: \"\n            f\"It contains {len(labels['label'])} entries, but only \"\n            f\"{len(labels['label'].unique())} unique labels\"\n        )\n\n    df_well.index = labels[\"label\"]\n    df_well.drop(labels=[\"label\"], axis=1, inplace=True)\n    # Convert all to float (warning: some would be int, in principle)\n    bbox_dtype = np.float32\n    df_well = df_well.astype(bbox_dtype)\n    # Convert to anndata\n    bbox_table = ad.AnnData(df_well)\n    bbox_table.obs = labels\n    return bbox_table\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1/#fractal_tasks_core.roi.v1.empty_bounding_box_table","title":"<code>empty_bounding_box_table()</code>","text":"<p>Construct an empty bounding-box ROI table of given shape.</p> <p>This function mirrors the functionality of <code>array_to_bounding_box_table</code>, for the specific case where the array includes no label. The advantages of this function are that:</p> <ol> <li>It does not require computing a whole array of zeros;</li> <li>We avoid hardcoding column names in the task functions.</li> </ol> RETURNS DESCRIPTION <code>DataFrame</code> <p>DataFrame with no rows, and with columns corresponding to the output of <code>array_to_bounding_box_table</code>.</p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def empty_bounding_box_table() -&gt; pd.DataFrame:\n\"\"\"\n    Construct an empty bounding-box ROI table of given shape.\n\n    This function mirrors the functionality of `array_to_bounding_box_table`,\n    for the specific case where the array includes no label. The advantages of\n    this function are that:\n\n    1. It does not require computing a whole array of zeros;\n    2. We avoid hardcoding column names in the task functions.\n\n    Returns:\n        DataFrame with no rows, and with columns corresponding to the output of\n            `array_to_bounding_box_table`.\n    \"\"\"\n\n    df_columns = [\n        \"x_micrometer\",\n        \"y_micrometer\",\n        \"z_micrometer\",\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n    ]\n    df = pd.DataFrame(columns=[x for x in df_columns] + [\"label\"])\n    return df\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1/#fractal_tasks_core.roi.v1.get_image_grid_ROIs","title":"<code>get_image_grid_ROIs(array_shape, pixels_ZYX, grid_YX_shape)</code>","text":"<p>Produce a table with ROIS placed on a rectangular grid.</p> <p>The main goal of this ROI grid is to allow processing of smaller subset of the whole array.</p> <p>In a specific case (that is, if the image array was obtained by stitching together a set of FOVs placed on a regular grid), the ROIs correspond to the original FOVs.</p> <p>TODO: make this flexible with respect to the presence/absence of Z.</p> PARAMETER DESCRIPTION <code>array_shape</code> <p>ZYX shape of the image array.</p> <p> TYPE: <code>tuple[int, int, int]</code> </p> <code>pixels_ZYX</code> <p>ZYX pixel sizes in micrometers.</p> <p> TYPE: <code>list[float]</code> </p> <code>grid_YX_shape</code> <p> TYPE: <code>tuple[int, int]</code> </p> RETURNS DESCRIPTION <code>AnnData</code> <p>An <code>AnnData</code> table with a single ROI.</p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def get_image_grid_ROIs(\n    array_shape: tuple[int, int, int],\n    pixels_ZYX: list[float],\n    grid_YX_shape: tuple[int, int],\n) -&gt; ad.AnnData:\n\"\"\"\n    Produce a table with ROIS placed on a rectangular grid.\n\n    The main goal of this ROI grid is to allow processing of smaller subset of\n    the whole array.\n\n    In a specific case (that is, if the image array was obtained by stitching\n    together a set of FOVs placed on a regular grid), the ROIs correspond to\n    the original FOVs.\n\n    TODO: make this flexible with respect to the presence/absence of Z.\n\n    Args:\n        array_shape: ZYX shape of the image array.\n        pixels_ZYX: ZYX pixel sizes in micrometers.\n        grid_YX_shape:\n\n    Returns:\n        An `AnnData` table with a single ROI.\n    \"\"\"\n    shape_z, shape_y, shape_x = array_shape[-3:]\n    grid_size_y, grid_size_x = grid_YX_shape[:]\n    X = []\n    obs_names = []\n    counter = 0\n    start_z = 0\n    len_z = shape_z\n\n    # Find minimal len_y that covers [0,shape_y] with grid_size_y intervals\n    len_y = math.ceil(shape_y / grid_size_y)\n    len_x = math.ceil(shape_x / grid_size_x)\n    for ind_y in range(grid_size_y):\n        start_y = ind_y * len_y\n        tmp_len_y = min(shape_y, start_y + len_y) - start_y\n        for ind_x in range(grid_size_x):\n            start_x = ind_x * len_x\n            tmp_len_x = min(shape_x, start_x + len_x) - start_x\n            X.append(\n                [\n                    start_x * pixels_ZYX[2],\n                    start_y * pixels_ZYX[1],\n                    start_z * pixels_ZYX[0],\n                    tmp_len_x * pixels_ZYX[2],\n                    tmp_len_y * pixels_ZYX[1],\n                    len_z * pixels_ZYX[0],\n                ]\n            )\n            counter += 1\n            obs_names.append(f\"ROI_{counter}\")\n    ROI_table = ad.AnnData(X=np.array(X, dtype=np.float32))\n    ROI_table.obs_names = obs_names\n    ROI_table.var_names = [\n        \"x_micrometer\",\n        \"y_micrometer\",\n        \"z_micrometer\",\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n    ]\n    return ROI_table\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1/#fractal_tasks_core.roi.v1.get_single_image_ROI","title":"<code>get_single_image_ROI(array_shape, pixels_ZYX)</code>","text":"<p>Produce a table with a single ROI that covers the whole array</p> <p>TODO: make this flexible with respect to the presence/absence of Z.</p> PARAMETER DESCRIPTION <code>array_shape</code> <p>ZYX shape of the image array.</p> <p> TYPE: <code>tuple[int, int, int]</code> </p> <code>pixels_ZYX</code> <p>ZYX pixel sizes in micrometers.</p> <p> TYPE: <code>list[float]</code> </p> RETURNS DESCRIPTION <code>AnnData</code> <p>An <code>AnnData</code> table with a single ROI.</p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def get_single_image_ROI(\n    array_shape: tuple[int, int, int],\n    pixels_ZYX: list[float],\n) -&gt; ad.AnnData:\n\"\"\"\n    Produce a table with a single ROI that covers the whole array\n\n    TODO: make this flexible with respect to the presence/absence of Z.\n\n    Args:\n        array_shape: ZYX shape of the image array.\n        pixels_ZYX: ZYX pixel sizes in micrometers.\n\n    Returns:\n        An `AnnData` table with a single ROI.\n    \"\"\"\n    shape_z, shape_y, shape_x = array_shape[-3:]\n    ROI_table = ad.AnnData(\n        X=np.array(\n            [\n                [\n                    0.0,\n                    0.0,\n                    0.0,\n                    shape_x * pixels_ZYX[2],\n                    shape_y * pixels_ZYX[1],\n                    shape_z * pixels_ZYX[0],\n                ],\n            ],\n            dtype=np.float32,\n        )\n    )\n    ROI_table.obs_names = [\"image_1\"]\n    ROI_table.var_names = [\n        \"x_micrometer\",\n        \"y_micrometer\",\n        \"z_micrometer\",\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n    ]\n    return ROI_table\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1/#fractal_tasks_core.roi.v1.is_standard_roi_table","title":"<code>is_standard_roi_table(table)</code>","text":"<p>True if the name of the table contains one of the standard Fractal tables</p> <p>If a table name is well_ROI_table, FOV_ROI_table or contains either of the two (e.g. registered_FOV_ROI_table), this function returns True.</p> PARAMETER DESCRIPTION <code>table</code> <p>table name</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>bool of whether it's a standard ROI table</p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def is_standard_roi_table(table: str) -&gt; bool:\n\"\"\"\n    True if the name of the table contains one of the standard Fractal tables\n\n    If a table name is well_ROI_table, FOV_ROI_table or contains either of the\n    two (e.g. registered_FOV_ROI_table), this function returns True.\n\n    Args:\n        table: table name\n\n    Returns:\n        bool of whether it's a standard ROI table\n\n    \"\"\"\n    if \"well_ROI_table\" in table:\n        return True\n    elif \"FOV_ROI_table\" in table:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1/#fractal_tasks_core.roi.v1.prepare_FOV_ROI_table","title":"<code>prepare_FOV_ROI_table(df, metadata=('time',))</code>","text":"<p>Prepare an AnnData table for fields-of-view ROIs.</p> PARAMETER DESCRIPTION <code>df</code> <p>Input dataframe, possibly prepared through <code>parse_yokogawa_metadata</code>.</p> <p> TYPE: <code>DataFrame</code> </p> <code>metadata</code> <p>Columns of <code>df</code> to be stored (if present) into AnnData table <code>obs</code>.</p> <p> TYPE: <code>tuple[str, ...]</code> DEFAULT: <code>('time',)</code> </p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def prepare_FOV_ROI_table(\n    df: pd.DataFrame, metadata: tuple[str, ...] = (\"time\",)\n) -&gt; ad.AnnData:\n\"\"\"\n    Prepare an AnnData table for fields-of-view ROIs.\n\n    Args:\n        df:\n            Input dataframe, possibly prepared through\n            `parse_yokogawa_metadata`.\n        metadata:\n            Columns of `df` to be stored (if present) into AnnData table `obs`.\n    \"\"\"\n\n    # Make a local copy of the dataframe, to avoid SettingWithCopyWarning\n    df = df.copy()\n\n    # Convert DataFrame index to str, to avoid\n    # &gt;&gt; ImplicitModificationWarning: Transforming to str index\n    # when creating AnnData object.\n    # Do this in the beginning to allow concatenation with e.g. time\n    df.index = df.index.astype(str)\n\n    # Obtain box size in physical units\n    df = df.assign(len_x_micrometer=df.x_pixel * df.pixel_size_x)\n    df = df.assign(len_y_micrometer=df.y_pixel * df.pixel_size_y)\n    df = df.assign(len_z_micrometer=df.z_pixel * df.pixel_size_z)\n\n    # Select only the numeric positional columns needed to define ROIs\n    # (to avoid) casting things like the data column to float32\n    # or to use unnecessary columns like bit_depth\n    positional_columns = [\n        \"x_micrometer\",\n        \"y_micrometer\",\n        \"z_micrometer\",\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n        \"x_micrometer_original\",\n        \"y_micrometer_original\",\n    ]\n\n    # Assign dtype explicitly, to avoid\n    # &gt;&gt; UserWarning: X converted to numpy array with dtype float64\n    # when creating AnnData object\n    df_roi = df.loc[:, positional_columns].astype(np.float32)\n\n    # Create an AnnData object directly from the DataFrame\n    adata = ad.AnnData(X=df_roi)\n\n    # Reset origin of the FOV ROI table, so that it matches with the well\n    # origin\n    adata = reset_origin(adata)\n\n    # Save any metadata that is specified to the obs df\n    for col in metadata:\n        if col in df:\n            # Cast all metadata to str.\n            # Reason: AnnData Zarr writers don't support all pandas types.\n            # e.g. pandas.core.arrays.datetimes.DatetimeArray can't be written\n            adata.obs[col] = df[col].astype(str)\n\n    # Rename rows and columns: Maintain FOV indices from the dataframe\n    # (they are already enforced to be unique by Pandas and may contain\n    # information for the user, as they are based on the filenames)\n    adata.obs_names = \"FOV_\" + adata.obs.index\n    adata.var_names = list(map(str, df_roi.columns))\n\n    return adata\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1/#fractal_tasks_core.roi.v1.prepare_well_ROI_table","title":"<code>prepare_well_ROI_table(df, metadata=('time',))</code>","text":"<p>Prepare an AnnData table with a single well ROI.</p> PARAMETER DESCRIPTION <code>df</code> <p>Input dataframe, possibly prepared through <code>parse_yokogawa_metadata</code>.</p> <p> TYPE: <code>DataFrame</code> </p> <code>metadata</code> <p>Columns of <code>df</code> to be stored (if present) into AnnData table <code>obs</code>.</p> <p> TYPE: <code>tuple[str, ...]</code> DEFAULT: <code>('time',)</code> </p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def prepare_well_ROI_table(\n    df: pd.DataFrame, metadata: tuple[str, ...] = (\"time\",)\n) -&gt; ad.AnnData:\n\"\"\"\n    Prepare an AnnData table with a single well ROI.\n\n    Args:\n        df:\n            Input dataframe, possibly prepared through\n            `parse_yokogawa_metadata`.\n        metadata:\n            Columns of `df` to be stored (if present) into AnnData table `obs`.\n    \"\"\"\n\n    # Make a local copy of the dataframe, to avoid SettingWithCopyWarning\n    df = df.copy()\n\n    # Convert DataFrame index to str, to avoid\n    # &gt;&gt; ImplicitModificationWarning: Transforming to str index\n    # when creating AnnData object.\n    # Do this in the beginning to allow concatenation with e.g. time\n    df.index = df.index.astype(str)\n\n    # Calculate bounding box extents in physical units\n    for mu in [\"x\", \"y\", \"z\"]:\n        # Obtain per-FOV properties in physical units.\n        # NOTE: a FOV ROI is defined here as the interval [min_micrometer,\n        # max_micrometer], with max_micrometer=min_micrometer+len_micrometer\n        min_micrometer = df[f\"{mu}_micrometer\"]\n        len_micrometer = df[f\"{mu}_pixel\"] * df[f\"pixel_size_{mu}\"]\n        max_micrometer = min_micrometer + len_micrometer\n        # Obtain well bounding box, in physical units\n        min_min_micrometer = min_micrometer.min()\n        max_max_micrometer = max_micrometer.max()\n        df[f\"{mu}_micrometer\"] = min_min_micrometer\n        df[f\"len_{mu}_micrometer\"] = max_max_micrometer - min_min_micrometer\n\n    # Select only the numeric positional columns needed to define ROIs\n    # (to avoid) casting things like the data column to float32\n    # or to use unnecessary columns like bit_depth\n    positional_columns = [\n        \"x_micrometer\",\n        \"y_micrometer\",\n        \"z_micrometer\",\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n    ]\n\n    # Assign dtype explicitly, to avoid\n    # &gt;&gt; UserWarning: X converted to numpy array with dtype float64\n    # when creating AnnData object\n    df_roi = df.iloc[0:1, :].loc[:, positional_columns].astype(np.float32)\n\n    # Create an AnnData object directly from the DataFrame\n    adata = ad.AnnData(X=df_roi)\n\n    # Reset origin of the single-entry well ROI table\n    adata = reset_origin(adata)\n\n    # Save any metadata that is specified to the obs df\n    for col in metadata:\n        if col in df:\n            # Cast all metadata to str.\n            # Reason: AnnData Zarr writers don't support all pandas types.\n            # e.g. pandas.core.arrays.datetimes.DatetimeArray can't be written\n            adata.obs[col] = df[col].astype(str)\n\n    # Rename rows and columns: Maintain FOV indices from the dataframe\n    # (they are already enforced to be unique by Pandas and may contain\n    # information for the user, as they are based on the filenames)\n    adata.obs_names = \"well_\" + adata.obs.index\n    adata.var_names = list(map(str, df_roi.columns))\n\n    return adata\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1/#fractal_tasks_core.roi.v1.reset_origin","title":"<code>reset_origin(ROI_table, x_pos='x_micrometer', y_pos='y_micrometer', z_pos='z_micrometer')</code>","text":"<p>Return a copy of a ROI table, with shifted-to-zero origin for some columns.</p> PARAMETER DESCRIPTION <code>ROI_table</code> <p>Original ROI table.</p> <p> TYPE: <code>AnnData</code> </p> <code>x_pos</code> <p>Name of the column with X position of ROIs.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'x_micrometer'</code> </p> <code>y_pos</code> <p>Name of the column with Y position of ROIs.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'y_micrometer'</code> </p> <code>z_pos</code> <p>Name of the column with Z position of ROIs.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'z_micrometer'</code> </p> RETURNS DESCRIPTION <code>AnnData</code> <p>A copy of the <code>ROI_table</code> AnnData table, where values of <code>x_pos</code>, <code>y_pos</code> and <code>z_pos</code> columns have been shifted by their minimum values.</p> Source code in <code>fractal_tasks_core/roi/v1.py</code> <pre><code>def reset_origin(\n    ROI_table: ad.AnnData,\n    x_pos: str = \"x_micrometer\",\n    y_pos: str = \"y_micrometer\",\n    z_pos: str = \"z_micrometer\",\n) -&gt; ad.AnnData:\n\"\"\"\n    Return a copy of a ROI table, with shifted-to-zero origin for some columns.\n\n    Args:\n        ROI_table: Original ROI table.\n        x_pos: Name of the column with X position of ROIs.\n        y_pos: Name of the column with Y position of ROIs.\n        z_pos: Name of the column with Z position of ROIs.\n\n    Returns:\n        A copy of the `ROI_table` AnnData table, where values of `x_pos`,\n            `y_pos` and `z_pos` columns have been shifted by their minimum\n            values.\n    \"\"\"\n    new_table = ROI_table.copy()\n\n    origin_x = min(new_table[:, x_pos].X[:, 0])\n    origin_y = min(new_table[:, y_pos].X[:, 0])\n    origin_z = min(new_table[:, z_pos].X[:, 0])\n\n    for FOV in new_table.obs_names:\n        new_table[FOV, x_pos] = new_table[FOV, x_pos].X[0, 0] - origin_x\n        new_table[FOV, y_pos] = new_table[FOV, y_pos].X[0, 0] - origin_y\n        new_table[FOV, z_pos] = new_table[FOV, z_pos].X[0, 0] - origin_z\n\n    return new_table\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1_checks/","title":"v1_checks","text":"<p>Functions to check content of ROI tables.</p>"},{"location":"reference/fractal_tasks_core/roi/v1_checks/#fractal_tasks_core.roi.v1_checks.are_ROI_table_columns_valid","title":"<code>are_ROI_table_columns_valid(*, table)</code>","text":"<p>Verify some validity assumptions on a ROI table.</p> <p>This function reflects our current working assumptions (e.g. the presence of some specific columns); this may change in future versions.</p> PARAMETER DESCRIPTION <code>table</code> <p>AnnData table to be checked</p> <p> TYPE: <code>AnnData</code> </p> Source code in <code>fractal_tasks_core/roi/v1_checks.py</code> <pre><code>def are_ROI_table_columns_valid(*, table: ad.AnnData) -&gt; None:\n\"\"\"\n    Verify some validity assumptions on a ROI table.\n\n    This function reflects our current working assumptions (e.g. the presence\n    of some specific columns); this may change in future versions.\n\n    Args:\n        table: AnnData table to be checked\n    \"\"\"\n\n    # Hard constraint: table columns must include some expected ones\n    columns = [\n        \"x_micrometer\",\n        \"y_micrometer\",\n        \"z_micrometer\",\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n    ]\n    for column in columns:\n        if column not in table.var_names:\n            raise ValueError(f\"Column {column} is not present in ROI table\")\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1_checks/#fractal_tasks_core.roi.v1_checks.check_valid_ROI_indices","title":"<code>check_valid_ROI_indices(list_indices, ROI_table_name)</code>","text":"<p>Check that list of indices has zero origin on each axis.</p> <p>See fractal-tasks-core issues #530 and #554.</p> <p>This helper function is meant to provide informative error messages when ROI tables created with fractal-tasks-core up to v0.11 are used in v0.12. This function will be deprecated and removed as soon as the v0.11/v0.12 transition advances.</p> <p>Note that only <code>FOV_ROI_table</code> and <code>well_ROI_table</code> have to fulfill this constraint, while ROI tables obtained through segmentation may have arbitrary (non-negative) indices.</p> PARAMETER DESCRIPTION <code>list_indices</code> <p>Output of <code>convert_ROI_table_to_indices</code>; each item is like <code>[start_z, end_z, start_y, end_y, start_x, end_x]</code>.</p> <p> TYPE: <code>list[list[int]]</code> </p> <code>ROI_table_name</code> <p>Name of the ROI table.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the table name is <code>FOV_ROI_table</code> or <code>well_ROI_table</code> and the     minimum value of <code>start_x</code>, <code>start_y</code> and <code>start_z</code> are not all     zero.</p> Source code in <code>fractal_tasks_core/roi/v1_checks.py</code> <pre><code>def check_valid_ROI_indices(\n    list_indices: list[list[int]],\n    ROI_table_name: str,\n) -&gt; None:\n\"\"\"\n    Check that list of indices has zero origin on each axis.\n\n    See fractal-tasks-core issues #530 and #554.\n\n    This helper function is meant to provide informative error messages when\n    ROI tables created with fractal-tasks-core up to v0.11 are used in v0.12.\n    This function will be deprecated and removed as soon as the v0.11/v0.12\n    transition advances.\n\n    Note that only `FOV_ROI_table` and `well_ROI_table` have to fulfill this\n    constraint, while ROI tables obtained through segmentation may have\n    arbitrary (non-negative) indices.\n\n    Args:\n        list_indices:\n            Output of `convert_ROI_table_to_indices`; each item is like\n            `[start_z, end_z, start_y, end_y, start_x, end_x]`.\n        ROI_table_name: Name of the ROI table.\n\n    Raises:\n        ValueError:\n            If the table name is `FOV_ROI_table` or `well_ROI_table` and the\n                minimum value of `start_x`, `start_y` and `start_z` are not all\n                zero.\n    \"\"\"\n    if ROI_table_name not in [\"FOV_ROI_table\", \"well_ROI_table\"]:\n        # This validation function only applies to the FOV/well ROI tables\n        # generated with fractal-tasks-core\n        return\n\n    # Find minimum index along ZYX\n    min_start_z = min(item[0] for item in list_indices)\n    min_start_y = min(item[2] for item in list_indices)\n    min_start_x = min(item[4] for item in list_indices)\n\n    # Check that minimum indices are all zero\n    for ind, min_index in enumerate((min_start_z, min_start_y, min_start_x)):\n        if min_index != 0:\n            axis = [\"Z\", \"Y\", \"X\"][ind]\n            raise ValueError(\n                f\"{axis} component of ROI indices for table `{ROI_table_name}`\"\n                f\" do not start with 0, but with {min_index}.\\n\"\n                \"Hint: As of fractal-tasks-core v0.12, FOV/well ROI \"\n                \"tables with non-zero origins (e.g. the ones created with \"\n                \"v0.11) are not supported.\"\n            )\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1_checks/#fractal_tasks_core.roi.v1_checks.is_ROI_table_valid","title":"<code>is_ROI_table_valid(*, table_path, use_masks)</code>","text":"<p>Verify some validity assumptions on a ROI table.</p> <p>This function reflects our current working assumptions (e.g. the presence of some specific columns); this may change in future versions.</p> <p>If <code>use_masks=True</code>, we verify that the table is a valid <code>masking_roi_table</code> as of table specifications V1; if this check fails, <code>use_masks</code> should be set to <code>False</code> upstream in the parent function.</p> PARAMETER DESCRIPTION <code>table_path</code> <p>Path of the AnnData ROI table to be checked.</p> <p> TYPE: <code>str</code> </p> <code>use_masks</code> <p>If <code>True</code>, perform some additional checks related to masked loading.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>Optional[bool]</code> <p>Always <code>None</code> if <code>use_masks=False</code>, otherwise return whether the table is valid for masked loading.</p> Source code in <code>fractal_tasks_core/roi/v1_checks.py</code> <pre><code>def is_ROI_table_valid(*, table_path: str, use_masks: bool) -&gt; Optional[bool]:\n\"\"\"\n    Verify some validity assumptions on a ROI table.\n\n    This function reflects our current working assumptions (e.g. the presence\n    of some specific columns); this may change in future versions.\n\n    If `use_masks=True`, we verify that the table is a valid\n    `masking_roi_table` as of table specifications V1; if this check fails,\n    `use_masks` should be set to `False` upstream in the parent function.\n\n    Args:\n        table_path: Path of the AnnData ROI table to be checked.\n        use_masks: If `True`, perform some additional checks related to\n            masked loading.\n\n    Returns:\n        Always `None` if `use_masks=False`, otherwise return whether the table\n            is valid for masked loading.\n    \"\"\"\n\n    table = ad.read_zarr(table_path)\n    are_ROI_table_columns_valid(table=table)\n    if not use_masks:\n        return None\n\n    # Check whether the table can be used for masked loading\n    attrs = zarr.group(table_path).attrs.asdict()\n    logger.info(f\"ROI table at {table_path} has attrs: {attrs}\")\n    try:\n        MaskingROITableAttrs(**attrs)\n        logging.info(\"ROI table can be used for masked loading\")\n        return True\n    except ValidationError:\n        logging.info(\"ROI table cannot be used for masked loading\")\n        return False\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1_overlaps/","title":"v1_overlaps","text":"<p>Functions to identify and remove ROI overlaps, based on V1 table specs.</p>"},{"location":"reference/fractal_tasks_core/roi/v1_overlaps/#fractal_tasks_core.roi.v1_overlaps.apply_shift_in_one_direction","title":"<code>apply_shift_in_one_direction(tmp_df_well, line_1, line_2, mu, tol=1e-10)</code>","text":"<p>TBD</p> PARAMETER DESCRIPTION <code>tmp_df_well</code> <p>TBD</p> <p> TYPE: <code>DataFrame</code> </p> <code>line_1</code> <p>TBD</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>line_2</code> <p>TBD</p> <p> TYPE: <code>Sequence[float]</code> </p> <code>mu</code> <p>TBD</p> <p> TYPE: <code>str</code> </p> <code>tol</code> <p>TBD</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-10</code> </p> Source code in <code>fractal_tasks_core/roi/v1_overlaps.py</code> <pre><code>def apply_shift_in_one_direction(\n    tmp_df_well: pd.DataFrame,\n    line_1: Sequence[float],\n    line_2: Sequence[float],\n    mu: str,\n    tol: float = 1e-10,\n):\n\"\"\"\n    TBD\n\n    Args:\n        tmp_df_well: TBD\n        line_1: TBD\n        line_2: TBD\n        mu: TBD\n        tol: TBD\n    \"\"\"\n    min_1, max_1 = line_1[:]\n    min_2, max_2 = line_2[:]\n    min_max = min(max_1, max_2)\n    max_min = max(min_1, min_2)\n    shift = min_max - max_min\n    logging.debug(f\"{mu}-shifting by {shift=}\")\n    ind = tmp_df_well.loc[:, f\"{mu}min\"] &gt;= max_min - tol\n    if not (shift &gt; 0.0 and ind.to_numpy().max() &gt; 0):\n        raise ValueError(\n            \"Something wrong in apply_shift_in_one_direction\\n\"\n            f\"{mu=}\\n{shift=}\\n{ind.to_numpy()=}\"\n        )\n    tmp_df_well.loc[ind, f\"{mu}min\"] += shift\n    tmp_df_well.loc[ind, f\"{mu}max\"] += shift\n    tmp_df_well.loc[ind, f\"{mu}_micrometer\"] += shift\n    return tmp_df_well\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1_overlaps/#fractal_tasks_core.roi.v1_overlaps.check_well_for_FOV_overlap","title":"<code>check_well_for_FOV_overlap(site_metadata, selected_well, plotting_function, tol=1e-10)</code>","text":"<p>This function is currently only used in tests and examples.</p> <p>The <code>plotting_function</code> parameter is exposed so that other tools (see examples in this repository) may use it to show the FOV ROIs.</p> PARAMETER DESCRIPTION <code>site_metadata</code> <p>TBD</p> <p> TYPE: <code>DataFrame</code> </p> <code>selected_well</code> <p>TBD</p> <p> TYPE: <code>str</code> </p> <code>plotting_function</code> <p>TBD</p> <p> TYPE: <code>Callable</code> </p> <code>tol</code> <p>TBD</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-10</code> </p> Source code in <code>fractal_tasks_core/roi/v1_overlaps.py</code> <pre><code>def check_well_for_FOV_overlap(\n    site_metadata: pd.DataFrame,\n    selected_well: str,\n    plotting_function: Callable,\n    tol: float = 1e-10,\n):\n\"\"\"\n    This function is currently only used in tests and examples.\n\n    The `plotting_function` parameter is exposed so that other tools (see\n    examples in this repository) may use it to show the FOV ROIs.\n\n    Args:\n        site_metadata: TBD\n        selected_well: TBD\n        plotting_function: TBD\n        tol: TBD\n    \"\"\"\n\n    df = site_metadata.loc[selected_well].copy()\n    df[\"xmin\"] = df[\"x_micrometer\"]\n    df[\"ymin\"] = df[\"y_micrometer\"]\n    df[\"xmax\"] = df[\"x_micrometer\"] + df[\"pixel_size_x\"] * df[\"x_pixel\"]\n    df[\"ymax\"] = df[\"y_micrometer\"] + df[\"pixel_size_y\"] * df[\"y_pixel\"]\n\n    xmin = list(df.loc[:, \"xmin\"])\n    ymin = list(df.loc[:, \"ymin\"])\n    xmax = list(df.loc[:, \"xmax\"])\n    ymax = list(df.loc[:, \"ymax\"])\n    num_lines = len(xmin)\n\n    list_overlapping_FOVs = []\n    for line_1 in range(num_lines):\n        min_x_1, max_x_1 = [a[line_1] for a in [xmin, xmax]]\n        min_y_1, max_y_1 = [a[line_1] for a in [ymin, ymax]]\n        for line_2 in range(line_1):\n            min_x_2, max_x_2 = [a[line_2] for a in [xmin, xmax]]\n            min_y_2, max_y_2 = [a[line_2] for a in [ymin, ymax]]\n            overlap = is_overlapping_2D(\n                (min_x_1, min_y_1, max_x_1, max_y_1),\n                (min_x_2, min_y_2, max_x_2, max_y_2),\n                tol=tol,\n            )\n            if overlap:\n                list_overlapping_FOVs.append(line_1)\n                list_overlapping_FOVs.append(line_2)\n\n    # Call plotting_function\n    plotting_function(\n        xmin, xmax, ymin, ymax, list_overlapping_FOVs, selected_well\n    )\n\n    if len(list_overlapping_FOVs) &gt; 0:\n        # Increase values by one to switch from index to the label plotted\n        return {selected_well: [x + 1 for x in list_overlapping_FOVs]}\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1_overlaps/#fractal_tasks_core.roi.v1_overlaps.find_overlaps_in_ROI_indices","title":"<code>find_overlaps_in_ROI_indices(list_indices)</code>","text":"<p>Given a list of integer ROI indices, find whether there are overlaps.</p> PARAMETER DESCRIPTION <code>list_indices</code> <p>List of ROI indices, where each element in the list should look like <code>[start_z, end_z, start_y, end_y, start_x, end_x]</code>.</p> <p> TYPE: <code>list[list[int]]</code> </p> RETURNS DESCRIPTION <code>Optional[tuple[int, int]]</code> <p><code>None</code> if no overlap was detected, otherwise a tuple with the positional indices of a pair of overlapping ROIs.</p> Source code in <code>fractal_tasks_core/roi/v1_overlaps.py</code> <pre><code>def find_overlaps_in_ROI_indices(\n    list_indices: list[list[int]],\n) -&gt; Optional[tuple[int, int]]:\n\"\"\"\n    Given a list of integer ROI indices, find whether there are overlaps.\n\n    Args:\n        list_indices: List of ROI indices, where each element in the list\n            should look like\n            `[start_z, end_z, start_y, end_y, start_x, end_x]`.\n\n    Returns:\n        `None` if no overlap was detected, otherwise a tuple with the\n            positional indices of a pair of overlapping ROIs.\n    \"\"\"\n\n    for ind_1, ROI_1 in enumerate(list_indices):\n        s_z, e_z, s_y, e_y, s_x, e_x = ROI_1[:]\n        box_1 = [s_x, s_y, s_z, e_x, e_y, e_z]\n        for ind_2 in range(ind_1):\n            ROI_2 = list_indices[ind_2]\n            s_z, e_z, s_y, e_y, s_x, e_x = ROI_2[:]\n            box_2 = [s_x, s_y, s_z, e_x, e_y, e_z]\n            if _is_overlapping_3D_int(box_1, box_2):\n                return (ind_1, ind_2)\n    return None\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1_overlaps/#fractal_tasks_core.roi.v1_overlaps.get_overlapping_pair","title":"<code>get_overlapping_pair(tmp_df, tol=1e-10)</code>","text":"<p>Finds the indices for the next overlapping FOVs pair.</p> <p>Note: the returned indices are positional indices, starting from 0.</p> PARAMETER DESCRIPTION <code>tmp_df</code> <p>Dataframe with columns <code>[\"xmin\", \"ymin\", \"xmax\", \"ymax\"]</code>.</p> <p> TYPE: <code>DataFrame</code> </p> <code>tol</code> <p>Finite tolerance for floating-point comparisons.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-10</code> </p> Source code in <code>fractal_tasks_core/roi/v1_overlaps.py</code> <pre><code>def get_overlapping_pair(\n    tmp_df: pd.DataFrame, tol: float = 1e-10\n) -&gt; Union[tuple[int, int], bool]:\n\"\"\"\n    Finds the indices for the next overlapping FOVs pair.\n\n    Note: the returned indices are positional indices, starting from 0.\n\n    Args:\n        tmp_df: Dataframe with columns `[\"xmin\", \"ymin\", \"xmax\", \"ymax\"]`.\n        tol: Finite tolerance for floating-point comparisons.\n    \"\"\"\n\n    num_lines = len(tmp_df.index)\n    for pos_ind_1 in range(num_lines):\n        for pos_ind_2 in range(pos_ind_1):\n            bbox_1 = tmp_df.iloc[pos_ind_1].to_numpy()\n            bbox_2 = tmp_df.iloc[pos_ind_2].to_numpy()\n            if is_overlapping_2D(bbox_1, bbox_2, tol=tol):\n                return (pos_ind_1, pos_ind_2)\n    return False\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1_overlaps/#fractal_tasks_core.roi.v1_overlaps.get_overlapping_pairs_3D","title":"<code>get_overlapping_pairs_3D(tmp_df, full_res_pxl_sizes_zyx)</code>","text":"<p>Finds the indices for the all overlapping FOVs pair, in three dimensions.</p> <p>Note: the returned indices are positional indices, starting from 0.</p> PARAMETER DESCRIPTION <code>tmp_df</code> <p>Dataframe with columns <code>{x,y,z}_micrometer</code> and <code>len_{x,y,z}_micrometer</code>.</p> <p> TYPE: <code>DataFrame</code> </p> <code>full_res_pxl_sizes_zyx</code> <p>TBD</p> <p> TYPE: <code>Sequence[float]</code> </p> Source code in <code>fractal_tasks_core/roi/v1_overlaps.py</code> <pre><code>def get_overlapping_pairs_3D(\n    tmp_df: pd.DataFrame,\n    full_res_pxl_sizes_zyx: Sequence[float],\n):\n\"\"\"\n    Finds the indices for the all overlapping FOVs pair, in three dimensions.\n\n    Note: the returned indices are positional indices, starting from 0.\n\n    Args:\n        tmp_df: Dataframe with columns `{x,y,z}_micrometer` and\n            `len_{x,y,z}_micrometer`.\n        full_res_pxl_sizes_zyx: TBD\n    \"\"\"\n\n    tol = 1e-10\n    if tol &gt; min(full_res_pxl_sizes_zyx) / 1e3:\n        raise ValueError(f\"{tol=} but {full_res_pxl_sizes_zyx=}\")\n\n    new_tmp_df = tmp_df.copy()\n\n    new_tmp_df[\"x_micrometer_max\"] = (\n        new_tmp_df[\"x_micrometer\"] + new_tmp_df[\"len_x_micrometer\"]\n    )\n    new_tmp_df[\"y_micrometer_max\"] = (\n        new_tmp_df[\"y_micrometer\"] + new_tmp_df[\"len_y_micrometer\"]\n    )\n    new_tmp_df[\"z_micrometer_max\"] = (\n        new_tmp_df[\"z_micrometer\"] + new_tmp_df[\"len_z_micrometer\"]\n    )\n    # Remove columns which are not necessary for overlap checks\n    list_columns = [\n        \"len_x_micrometer\",\n        \"len_y_micrometer\",\n        \"len_z_micrometer\",\n        \"label\",\n    ]\n    new_tmp_df.drop(labels=list_columns, axis=1, inplace=True)\n\n    # Loop over all pairs, and construct list of overlapping ones\n    num_lines = len(new_tmp_df.index)\n    overlapping_list = []\n    for pos_ind_1 in range(num_lines):\n        for pos_ind_2 in range(pos_ind_1):\n            bbox_1 = new_tmp_df.iloc[pos_ind_1].to_numpy()\n            bbox_2 = new_tmp_df.iloc[pos_ind_2].to_numpy()\n            overlap = is_overlapping_3D(bbox_1, bbox_2, tol=tol)\n            if overlap:\n                overlapping_list.append((pos_ind_1, pos_ind_2))\n    return overlapping_list\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1_overlaps/#fractal_tasks_core.roi.v1_overlaps.remove_FOV_overlaps","title":"<code>remove_FOV_overlaps(df)</code>","text":"<p>Given a metadata dataframe, shift its columns to remove FOV overlaps.</p> PARAMETER DESCRIPTION <code>df</code> <p>Metadata dataframe.</p> <p> TYPE: <code>DataFrame</code> </p> Source code in <code>fractal_tasks_core/roi/v1_overlaps.py</code> <pre><code>def remove_FOV_overlaps(df: pd.DataFrame):\n\"\"\"\n    Given a metadata dataframe, shift its columns to remove FOV overlaps.\n\n    Args:\n        df: Metadata dataframe.\n    \"\"\"\n\n    # Set tolerance (this should be much smaller than pixel size or expected\n    # round-offs), and maximum number of iterations in constraint solver\n    tol = 1e-10\n    max_iterations = 200\n\n    # Create a local copy of the dataframe\n    df = df.copy()\n\n    # Create temporary columns (to streamline overlap removals), which are\n    # then removed at the end of the remove_FOV_overlaps function\n    df[\"xmin\"] = df[\"x_micrometer\"]\n    df[\"ymin\"] = df[\"y_micrometer\"]\n    df[\"xmax\"] = df[\"x_micrometer\"] + df[\"pixel_size_x\"] * df[\"x_pixel\"]\n    df[\"ymax\"] = df[\"y_micrometer\"] + df[\"pixel_size_y\"] * df[\"y_pixel\"]\n    list_columns = [\"xmin\", \"ymin\", \"xmax\", \"ymax\"]\n\n    # Create columns with the original positions (not to be removed)\n    df[\"x_micrometer_original\"] = df[\"x_micrometer\"]\n    df[\"y_micrometer_original\"] = df[\"y_micrometer\"]\n\n    # Check that tolerance is much smaller than pixel sizes\n    min_pixel_size = df[[\"pixel_size_x\", \"pixel_size_y\"]].min().min()\n    if tol &gt; min_pixel_size / 1e3:\n        raise ValueError(\n            f\"In remove_FOV_overlaps, {tol=} but {min_pixel_size=}\"\n        )\n\n    # Loop over wells\n    wells = sorted(list(set([ind[0] for ind in df.index])))\n    for well in wells:\n        logger.info(f\"removing FOV overlaps for {well=}\")\n        df_well = df.loc[well].copy()\n\n        # NOTE: these are positional indices (i.e. starting from 0)\n        pair_pos_indices = get_overlapping_pair(df_well[list_columns], tol=tol)\n\n        # Keep going until there are no overlaps, or until iteration reaches\n        # max_iterations\n        iteration = 0\n        while pair_pos_indices:\n            iteration += 1\n\n            # Identify overlapping FOVs\n            pos_ind_1, pos_ind_2 = pair_pos_indices\n            fov_id_1 = df_well.index[pos_ind_1]\n            fov_id_2 = df_well.index[pos_ind_2]\n            xmin_1, ymin_1, xmax_1, ymax_1 = df_well[list_columns].iloc[\n                pos_ind_1\n            ]\n            xmin_2, ymin_2, xmax_2, ymax_2 = df_well[list_columns].iloc[\n                pos_ind_2\n            ]\n            logger.debug(\n                f\"{well=}, {iteration=}, removing overlap between\"\n                f\" {fov_id_1=} and {fov_id_2=}\"\n            )\n\n            # Check what kind of overlap is there (X, Y, or XY)\n            is_x_equal = abs(xmin_1 - xmin_2) &lt; tol and (xmax_1 - xmax_2) &lt; tol\n            is_y_equal = abs(ymin_1 - ymin_2) &lt; tol and (ymax_1 - ymax_2) &lt; tol\n            is_x_overlap = is_overlapping_1D(\n                [xmin_1, xmax_1], [xmin_2, xmax_2], tol=tol\n            )\n            is_y_overlap = is_overlapping_1D(\n                [ymin_1, ymax_1], [ymin_2, ymax_2], tol=tol\n            )\n\n            if is_x_equal and is_y_overlap:\n                # Y overlap\n                df_well = apply_shift_in_one_direction(\n                    df_well,\n                    [ymin_1, ymax_1],\n                    [ymin_2, ymax_2],\n                    mu=\"y\",\n                    tol=tol,\n                )\n            elif is_y_equal and is_x_overlap:\n                # X overlap\n                df_well = apply_shift_in_one_direction(\n                    df_well,\n                    [xmin_1, xmax_1],\n                    [xmin_2, xmax_2],\n                    mu=\"x\",\n                    tol=tol,\n                )\n            elif not (is_x_equal or is_y_equal) and (\n                is_x_overlap and is_y_overlap\n            ):\n                # XY overlap\n                df_well = apply_shift_in_one_direction(\n                    df_well,\n                    [xmin_1, xmax_1],\n                    [xmin_2, xmax_2],\n                    mu=\"x\",\n                    tol=tol,\n                )\n                df_well = apply_shift_in_one_direction(\n                    df_well,\n                    [ymin_1, ymax_1],\n                    [ymin_2, ymax_2],\n                    mu=\"y\",\n                    tol=tol,\n                )\n            else:\n                raise ValueError(\n                    \"Trying to remove overlap which is not there.\"\n                )\n\n            # Look for next overlapping FOV pair\n            pair_pos_indices = get_overlapping_pair(\n                df_well[list_columns], tol=tol\n            )\n\n            # Enforce maximum number of iterations\n            if iteration &gt;= max_iterations:\n                raise ValueError(f\"Reached {max_iterations=} for {well=}\")\n\n        # Note: using df.loc[well] = df_well leads to a NaN dataframe, see\n        # for instance https://stackoverflow.com/a/28432733/19085332\n        df.loc[well, :] = df_well.values\n\n    # Remove temporary columns that were added only as part of this function\n    df.drop(list_columns, axis=1, inplace=True)\n\n    return df\n</code></pre>"},{"location":"reference/fractal_tasks_core/roi/v1_overlaps/#fractal_tasks_core.roi.v1_overlaps.run_overlap_check","title":"<code>run_overlap_check(site_metadata, tol=1e-10, plotting_function=None)</code>","text":"<p>Run an overlap check over all wells and optionally plots overlaps.</p> <p>This function is currently only used in tests and examples.</p> <p>The <code>plotting_function</code> parameter is exposed so that other tools (see examples in this repository) may use it to show the FOV ROIs. Its arguments are: <code>[xmin, xmax, ymin, ymax, list_overlapping_FOVs, selected_well]</code>.</p> PARAMETER DESCRIPTION <code>site_metadata</code> <p>TBD</p> <p> TYPE: <code>DataFrame</code> </p> <code>tol</code> <p>TBD</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-10</code> </p> <code>plotting_function</code> <p>TBD</p> <p> TYPE: <code>Optional[Callable]</code> DEFAULT: <code>None</code> </p> Source code in <code>fractal_tasks_core/roi/v1_overlaps.py</code> <pre><code>def run_overlap_check(\n    site_metadata: pd.DataFrame,\n    tol: float = 1e-10,\n    plotting_function: Optional[Callable] = None,\n):\n\"\"\"\n    Run an overlap check over all wells and optionally plots overlaps.\n\n    This function is currently only used in tests and examples.\n\n    The `plotting_function` parameter is exposed so that other tools (see\n    examples in this repository) may use it to show the FOV ROIs. Its arguments\n    are: `[xmin, xmax, ymin, ymax, list_overlapping_FOVs, selected_well]`.\n\n    Args:\n        site_metadata: TBD\n        tol: TBD\n        plotting_function: TBD\n    \"\"\"\n\n    if plotting_function is None:\n\n        def plotting_function(\n            xmin, xmax, ymin, ymax, list_overlapping_FOVs, selected_well\n        ):\n            pass\n\n    wells = site_metadata.index.unique(level=\"well_id\")\n    overlapping_FOVs = []\n    for selected_well in wells:\n        overlap_curr_well = check_well_for_FOV_overlap(\n            site_metadata,\n            selected_well=selected_well,\n            tol=tol,\n            plotting_function=plotting_function,\n        )\n        if overlap_curr_well:\n            print(selected_well)\n            overlapping_FOVs.append(overlap_curr_well)\n\n    return overlapping_FOVs\n</code></pre>"},{"location":"reference/fractal_tasks_core/tables/","title":"tables","text":"<p>Subpackage with functions and classes related to table specifications (see https://fractal-analytics-platform.github.io/fractal-tasks-core/tables).</p>"},{"location":"reference/fractal_tasks_core/tables/#fractal_tasks_core.tables.write_table","title":"<code>write_table(image_group, table_name, table, overwrite=False, table_type=None, table_attrs=None)</code>","text":"<p>Write a table to a Zarr group.</p> <p>This is the general interface that should allow for a smooth coexistence of tables with different <code>fractal_table_version</code> values. Currently only V1 is defined and implemented. The assumption is that V2 should only change:</p> <ol> <li>The lower-level writing function (that is, <code>_write_table_v2</code>).</li> <li>The type of the table (which would also reflect into a more general type     hint for <code>table</code>, in the current funciton);</li> <li>A different definition of what values of <code>table_attrs</code> are valid or    invalid, to be implemented in <code>_write_table_v2</code>.</li> <li>Possibly, additional parameters for <code>_write_table_v2</code>, which will be    optional parameters of <code>write_table</code> (so that <code>write_table</code> remains    valid for both V1 and V2).</li> </ol> PARAMETER DESCRIPTION <code>image_group</code> <p>The image Zarr group where the table will be written.</p> <p> TYPE: <code>Group</code> </p> <code>table_name</code> <p>The name of the table.</p> <p> TYPE: <code>str</code> </p> <code>table</code> <p>The table object (currently an AnnData object, for V1).</p> <p> TYPE: <code>AnnData</code> </p> <code>overwrite</code> <p>If <code>False</code>, check that the new table does not exist (either as a zarr sub-group or as part of the zarr-group attributes). In all cases, propagate parameter to low-level functions, to determine the behavior in case of an existing sub-group named as in <code>table_name</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>table_type</code> <p><code>type</code> attribute for the table; in case <code>type</code> is also present in <code>table_attrs</code>, this function argument takes priority.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>table_attrs</code> <p>If set, overwrite table_group attributes with table_attrs key/value pairs. If <code>table_type</code> is not provided, then <code>table_attrs</code> must include the <code>type</code> key.</p> <p> TYPE: <code>Optional[dict[str, Any]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>group</code> <p>Zarr group of the table.</p> Source code in <code>fractal_tasks_core/tables/__init__.py</code> <pre><code>def write_table(\n    image_group: zarr.hierarchy.Group,\n    table_name: str,\n    table: ad.AnnData,\n    overwrite: bool = False,\n    table_type: Optional[str] = None,\n    table_attrs: Optional[dict[str, Any]] = None,\n) -&gt; zarr.group:\n\"\"\"\n    Write a table to a Zarr group.\n\n    This is the general interface that should allow for a smooth coexistence of\n    tables with different `fractal_table_version` values. Currently only V1 is\n    defined and implemented. The assumption is that V2 should only change:\n\n    1. The lower-level writing function (that is, `_write_table_v2`).\n    2. The type of the table (which would also reflect into a more general type\n        hint for `table`, in the current funciton);\n    3. A different definition of what values of `table_attrs` are valid or\n       invalid, to be implemented in `_write_table_v2`.\n    4. Possibly, additional parameters for `_write_table_v2`, which will be\n       optional parameters of `write_table` (so that `write_table` remains\n       valid for both V1 and V2).\n\n    Args:\n        image_group:\n            The image Zarr group where the table will be written.\n        table_name:\n            The name of the table.\n        table:\n            The table object (currently an AnnData object, for V1).\n        overwrite:\n            If `False`, check that the new table does not exist (either as a\n            zarr sub-group or as part of the zarr-group attributes). In all\n            cases, propagate parameter to low-level functions, to determine the\n            behavior in case of an existing sub-group named as in `table_name`.\n        table_type: `type` attribute for the table; in case `type` is also\n            present in `table_attrs`, this function argument takes priority.\n        table_attrs:\n            If set, overwrite table_group attributes with table_attrs key/value\n            pairs. If `table_type` is not provided, then `table_attrs` must\n            include the `type` key.\n\n    Returns:\n        Zarr group of the table.\n    \"\"\"\n    # Choose which version to use, giving priority to a value that is present\n    # in table_attrs\n    version = __FRACTAL_TABLE_VERSION__\n    if table_attrs is not None:\n        try:\n            version = table_attrs[\"fractal_table_version\"]\n        except KeyError:\n            pass\n\n    if version == \"1\":\n        return _write_table_v1(\n            image_group,\n            table_name,\n            table,\n            overwrite,\n            table_type,\n            table_attrs,\n        )\n    else:\n        raise NotImplementedError(\n            f\"fractal_table_version='{version}' is not supported\"\n        )\n</code></pre>"},{"location":"reference/fractal_tasks_core/tables/v1/","title":"v1","text":"<p>Functions and classes related to table specifications V1 (see https://fractal-analytics-platform.github.io/fractal-tasks-core/tables).</p>"},{"location":"reference/fractal_tasks_core/tables/v1/#fractal_tasks_core.tables.v1._write_elem_with_overwrite","title":"<code>_write_elem_with_overwrite(group, key, elem, *, overwrite, logger=None)</code>","text":"<p>Wrap <code>anndata.experimental.write_elem</code>, to include <code>overwrite</code> parameter.</p> <p>See docs for the original function here.</p> <p>This function writes <code>elem</code> to the sub-group <code>key</code> of <code>group</code>. The <code>overwrite</code>-related expected behavior is:</p> <ul> <li>if the sub-group does not exist, create it (independently on   <code>overwrite</code>);</li> <li>if the sub-group already exists and <code>overwrite=True</code>, overwrite the   sub-group;</li> <li>if the sub-group already exists and <code>overwrite=False</code>, fail.</li> </ul> <p>Note that this version of the wrapper does not include the original <code>dataset_kwargs</code> parameter.</p> PARAMETER DESCRIPTION <code>group</code> <p>The group to write to.</p> <p> TYPE: <code>Group</code> </p> <code>key</code> <p>The key to write to in the group. Note that absolute paths will be written from the root.</p> <p> TYPE: <code>str</code> </p> <code>elem</code> <p>The element to write. Typically an in-memory object, e.g. an AnnData, pandas dataframe, scipy sparse matrix, etc.</p> <p> TYPE: <code>Any</code> </p> <code>overwrite</code> <p>If <code>True</code>, overwrite the <code>key</code> sub-group (if present); if <code>False</code> and <code>key</code> sub-group exists, raise an error.</p> <p> TYPE: <code>bool</code> </p> <code>logger</code> <p>The logger to use (if unset, use <code>logging.getLogger(None)</code>)</p> <p> TYPE: <code>Optional[Logger]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>OverwriteNotAllowedError</code> <p>If <code>overwrite=False</code> and the sub-group already exists.</p> Source code in <code>fractal_tasks_core/tables/v1.py</code> <pre><code>def _write_elem_with_overwrite(\n    group: zarr.hierarchy.Group,\n    key: str,\n    elem: Any,\n    *,\n    overwrite: bool,\n    logger: Optional[logging.Logger] = None,\n) -&gt; None:\n\"\"\"\n    Wrap `anndata.experimental.write_elem`, to include `overwrite` parameter.\n\n    See docs for the original function\n    [here](https://anndata.readthedocs.io/en/stable/generated/anndata.experimental.write_elem.html).\n\n    This function writes `elem` to the sub-group `key` of `group`. The\n    `overwrite`-related expected behavior is:\n\n    * if the sub-group does not exist, create it (independently on\n      `overwrite`);\n    * if the sub-group already exists and `overwrite=True`, overwrite the\n      sub-group;\n    * if the sub-group already exists and `overwrite=False`, fail.\n\n    Note that this version of the wrapper does not include the original\n    `dataset_kwargs` parameter.\n\n    Args:\n        group:\n            The group to write to.\n        key:\n            The key to write to in the group. Note that absolute paths will be\n            written from the root.\n        elem:\n            The element to write. Typically an in-memory object, e.g. an\n            AnnData, pandas dataframe, scipy sparse matrix, etc.\n        overwrite:\n            If `True`, overwrite the `key` sub-group (if present); if `False`\n            and `key` sub-group exists, raise an error.\n        logger:\n            The logger to use (if unset, use `logging.getLogger(None)`)\n\n    Raises:\n        OverwriteNotAllowedError:\n            If `overwrite=False` and the sub-group already exists.\n    \"\"\"\n\n    # Set logger\n    if logger is None:\n        logger = logging.getLogger(None)\n\n    if key in set(group.group_keys()):\n        if not overwrite:\n            error_msg = (\n                f\"Sub-group '{key}' of group {group.store.path} \"\n                f\"already exists, but `{overwrite=}`.\\n\"\n                \"Hint: try setting `overwrite=True`.\"\n            )\n            logger.error(error_msg)\n            raise OverwriteNotAllowedError(error_msg)\n    write_elem(group, key, elem)\n</code></pre>"},{"location":"reference/fractal_tasks_core/tables/v1/#fractal_tasks_core.tables.v1._write_table_v1","title":"<code>_write_table_v1(image_group, table_name, table, overwrite=False, table_type=None, table_attrs=None)</code>","text":"<p>Handle multiple options for writing an AnnData table to a zarr group.</p> <ol> <li>Create the <code>tables</code> group, if needed.</li> <li>If <code>overwrite=False</code>, check that the new table does not exist (either in    zarr attributes or as a zarr sub-group).</li> <li>Call the <code>_write_elem_with_overwrite</code> wrapper with the appropriate    <code>overwrite</code> parameter.</li> <li>Update the <code>tables</code> attribute of the image group.</li> <li>Validate <code>table_type</code> and <code>table_attrs</code> according to Fractal table    specifications, and raise errors/warnings if needed; then set the    appropriate attributes in the new-table Zarr group.</li> </ol> PARAMETER DESCRIPTION <code>image_group</code> <p>The group to write to.</p> <p> TYPE: <code>Group</code> </p> <code>table_name</code> <p>The name of the new table.</p> <p> TYPE: <code>str</code> </p> <code>table</code> <p>The AnnData table to write.</p> <p> TYPE: <code>AnnData</code> </p> <code>overwrite</code> <p>If <code>False</code>, check that the new table does not exist (either as a zarr sub-group or as part of the zarr-group attributes). In all cases, propagate parameter to <code>_write_elem_with_overwrite</code>, to determine the behavior in case of an existing sub-group named as <code>table_name</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>table_type</code> <p><code>type</code> attribute for the table; in case <code>type</code> is also present in <code>table_attrs</code>, this function argument takes priority.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>table_attrs</code> <p>If set, overwrite table_group attributes with table_attrs key/value pairs. If <code>table_type</code> is not provided, then <code>table_attrs</code> must include the <code>type</code> key.</p> <p> TYPE: <code>Optional[dict[str, Any]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>group</code> <p>Zarr group of the new table.</p> Source code in <code>fractal_tasks_core/tables/v1.py</code> <pre><code>def _write_table_v1(\n    image_group: zarr.hierarchy.Group,\n    table_name: str,\n    table: ad.AnnData,\n    overwrite: bool = False,\n    table_type: Optional[str] = None,\n    table_attrs: Optional[dict[str, Any]] = None,\n) -&gt; zarr.group:\n\"\"\"\n    Handle multiple options for writing an AnnData table to a zarr group.\n\n    1. Create the `tables` group, if needed.\n    2. If `overwrite=False`, check that the new table does not exist (either in\n       zarr attributes or as a zarr sub-group).\n    3. Call the `_write_elem_with_overwrite` wrapper with the appropriate\n       `overwrite` parameter.\n    4. Update the `tables` attribute of the image group.\n    5. Validate `table_type` and `table_attrs` according to Fractal table\n       specifications, and raise errors/warnings if needed; then set the\n       appropriate attributes in the new-table Zarr group.\n\n\n    Args:\n        image_group:\n            The group to write to.\n        table_name:\n            The name of the new table.\n        table:\n            The AnnData table to write.\n        overwrite:\n            If `False`, check that the new table does not exist (either as a\n            zarr sub-group or as part of the zarr-group attributes). In all\n            cases, propagate parameter to `_write_elem_with_overwrite`, to\n            determine the behavior in case of an existing sub-group named as\n            `table_name`.\n        table_type: `type` attribute for the table; in case `type` is also\n            present in `table_attrs`, this function argument takes priority.\n        table_attrs:\n            If set, overwrite table_group attributes with table_attrs key/value\n            pairs. If `table_type` is not provided, then `table_attrs` must\n            include the `type` key.\n\n    Returns:\n        Zarr group of the new table.\n    \"\"\"\n\n    # Create tables group (if needed) and extract current_tables\n    if \"tables\" not in set(image_group.group_keys()):\n        tables_group = image_group.create_group(\"tables\", overwrite=False)\n    else:\n        tables_group = image_group[\"tables\"]\n    current_tables = tables_group.attrs.asdict().get(\"tables\", [])\n\n    # If overwrite=False, check that the new table does not exist (either as a\n    # zarr sub-group or as part of the zarr-group attributes)\n    if not overwrite:\n        if table_name in set(tables_group.group_keys()):\n            error_msg = (\n                f\"Sub-group '{table_name}' of group {image_group.store.path} \"\n                f\"already exists, but `{overwrite=}`.\\n\"\n                \"Hint: try setting `overwrite=True`.\"\n            )\n            logger.error(error_msg)\n            raise OverwriteNotAllowedError(error_msg)\n        if table_name in current_tables:\n            error_msg = (\n                f\"Item '{table_name}' already exists in `tables` attribute of \"\n                f\"group {image_group.store.path}, but `{overwrite=}`.\\n\"\n                \"Hint: try setting `overwrite=True`.\"\n            )\n            logger.error(error_msg)\n            raise OverwriteNotAllowedError(error_msg)\n\n    # Always include fractal-roi-table version in table attributes\n    if table_attrs is None:\n        table_attrs = dict(fractal_table_version=\"1\")\n    elif table_attrs.get(\"fractal_table_version\", None) is None:\n        table_attrs[\"fractal_table_version\"] = \"1\"\n\n    # Set type attribute for the table\n    table_type_from_attrs = table_attrs.get(\"type\", None)\n    if table_type is not None:\n        if table_type_from_attrs is not None:\n            logger.warning(\n                f\"Setting table type to '{table_type}' (and overriding \"\n                f\"'{table_type_from_attrs}' attribute).\"\n            )\n        table_attrs[\"type\"] = table_type\n    else:\n        if table_type_from_attrs is None:\n            raise ValueError(\n                \"Missing attribute `type` for table; this must be provided\"\n                \" either via `table_type` or within `table_attrs`.\"\n            )\n\n    # Prepare/validate attributes for the table\n    table_type = table_attrs.get(\"type\", None)\n    if table_type == \"roi_table\":\n        pass\n    elif table_type == \"masking_roi_table\":\n        try:\n            MaskingROITableAttrs(**table_attrs)\n        except ValidationError as e:\n            error_msg = (\n                \"Table attributes do not comply with Fractal \"\n                \"`masking_roi_table` specifications V1.\\nOriginal error:\\n\"\n                f\"ValidationError: {str(e)}\"\n            )\n            logger.error(error_msg)\n            raise ValueError(error_msg)\n    elif table_type == \"feature_table\":\n        try:\n            FeatureTableAttrs(**table_attrs)\n        except ValidationError as e:\n            error_msg = (\n                \"Table attributes do not comply with Fractal \"\n                \"`feature_table` specifications V1.\\nOriginal error:\\n\"\n                f\"ValidationError: {str(e)}\"\n            )\n            logger.error(error_msg)\n            raise ValueError(error_msg)\n    else:\n        logger.warning(f\"Unknown table type `{table_type}`.\")\n\n    # If it's all OK, proceed and write the table\n    _write_elem_with_overwrite(\n        tables_group,\n        table_name,\n        table,\n        overwrite=overwrite,\n    )\n    table_group = tables_group[table_name]\n\n    # Update the `tables` metadata of the image group, if needed\n    if table_name not in current_tables:\n        new_tables = current_tables + [table_name]\n        tables_group.attrs[\"tables\"] = new_tables\n\n    # Update table_group attributes with table_attrs key/value pairs\n    table_group.attrs.update(**table_attrs)\n\n    return table_group\n</code></pre>"},{"location":"reference/fractal_tasks_core/tables/v1/#fractal_tasks_core.tables.v1.get_tables_list_v1","title":"<code>get_tables_list_v1(zarr_url, table_type=None, strict=False)</code>","text":"<p>Find the list of tables in the Zarr file</p> <p>Optionally match a table type and only return the names of those tables.</p> PARAMETER DESCRIPTION <code>zarr_url</code> <p>Path to the OME-Zarr image</p> <p> TYPE: <code>str</code> </p> <code>table_type</code> <p>The type of table to look for. Special handling for \"ROIs\" =&gt; matches both \"roi_table\" &amp; \"masking_roi_table\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>strict</code> <p>If <code>True</code>, only return tables that have a type attribute. If <code>False</code>, also include tables without a type attribute.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>List of the names of available tables</p> Source code in <code>fractal_tasks_core/tables/v1.py</code> <pre><code>def get_tables_list_v1(\n    zarr_url: str, table_type: str = None, strict: bool = False\n) -&gt; list[str]:\n\"\"\"\n    Find the list of tables in the Zarr file\n\n    Optionally match a table type and only return the names of those tables.\n\n    Args:\n        zarr_url: Path to the OME-Zarr image\n        table_type: The type of table to look for. Special handling for\n            \"ROIs\" =&gt; matches both \"roi_table\" &amp; \"masking_roi_table\".\n        strict: If `True`, only return tables that have a type attribute.\n            If `False`, also include tables without a type attribute.\n\n    Returns:\n        List of the names of available tables\n    \"\"\"\n    with zarr.open(zarr_url, mode=\"r\") as zarr_group:\n        zarr_subgroups = list(zarr_group.group_keys())\n    if \"tables\" not in zarr_subgroups:\n        return []\n    with zarr.open(zarr_url, mode=\"r\") as zarr_group:\n        all_tables = list(zarr_group.tables.group_keys())\n\n    if not table_type:\n        return all_tables\n    else:\n        return _filter_tables_by_type_v1(\n            zarr_url, all_tables, table_type, strict\n        )\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/","title":"tasks","text":"<p>Tasks subpackage (requires installation extra <code>fractal-tasks</code>).</p>"},{"location":"reference/fractal_tasks_core/tasks/_registration_utils/","title":"_registration_utils","text":"<p>Utils functions for registration</p>"},{"location":"reference/fractal_tasks_core/tasks/_registration_utils/#fractal_tasks_core.tasks._registration_utils.add_zero_translation_columns","title":"<code>add_zero_translation_columns(ad_table)</code>","text":"<p>Add three zero-filled columns (<code>translation_{x,y,z}</code>) to an AnnData table.</p> Source code in <code>fractal_tasks_core/tasks/_registration_utils.py</code> <pre><code>def add_zero_translation_columns(ad_table: ad.AnnData):\n\"\"\"\n    Add three zero-filled columns (`translation_{x,y,z}`) to an AnnData table.\n    \"\"\"\n    columns = [\"translation_z\", \"translation_y\", \"translation_x\"]\n    if ad_table.var.index.isin(columns).any().any():\n        raise ValueError(\n            \"The roi table already contains translation columns. Did you \"\n            \"enter a wrong reference acquisition?\"\n        )\n    df = pd.DataFrame(np.zeros([len(ad_table), 3]), columns=columns)\n    df.index = ad_table.obs.index\n    ad_new = ad.concat([ad_table, ad.AnnData(df)], axis=1)\n    return ad_new\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/_registration_utils/#fractal_tasks_core.tasks._registration_utils.apply_registration_to_single_ROI_table","title":"<code>apply_registration_to_single_ROI_table(roi_table, max_df, min_df)</code>","text":"<p>Applies the registration to a ROI table</p> <p>Calculates the new position as: p = position + max(shift, 0) - own_shift Calculates the new len as: l = len - max(shift, 0) + min(shift, 0)</p> PARAMETER DESCRIPTION <code>roi_table</code> <p>AnnData table which contains a Fractal ROI table. Rows are ROIs</p> <p> TYPE: <code>AnnData</code> </p> <code>max_df</code> <p>Max translation shift in z, y, x for each ROI. Rows are ROIs, columns are translation_z, translation_y, translation_x</p> <p> TYPE: <code>DataFrame</code> </p> <code>min_df</code> <p>Min translation shift in z, y, x for each ROI. Rows are ROIs, columns are translation_z, translation_y, translation_x</p> <p> TYPE: <code>DataFrame</code> </p> <p>Returns:     ROI table where all ROIs are registered to the smallest common area     across all acquisitions.</p> Source code in <code>fractal_tasks_core/tasks/_registration_utils.py</code> <pre><code>def apply_registration_to_single_ROI_table(\n    roi_table: ad.AnnData,\n    max_df: pd.DataFrame,\n    min_df: pd.DataFrame,\n) -&gt; ad.AnnData:\n\"\"\"\n    Applies the registration to a ROI table\n\n    Calculates the new position as: p = position + max(shift, 0) - own_shift\n    Calculates the new len as: l = len - max(shift, 0) + min(shift, 0)\n\n    Args:\n        roi_table: AnnData table which contains a Fractal ROI table.\n            Rows are ROIs\n        max_df: Max translation shift in z, y, x for each ROI. Rows are ROIs,\n            columns are translation_z, translation_y, translation_x\n        min_df: Min translation shift in z, y, x for each ROI. Rows are ROIs,\n            columns are translation_z, translation_y, translation_x\n    Returns:\n        ROI table where all ROIs are registered to the smallest common area\n        across all acquisitions.\n    \"\"\"\n    roi_table = copy.deepcopy(roi_table)\n    rois = roi_table.obs.index\n    if (rois != max_df.index).all() or (rois != min_df.index).all():\n        raise ValueError(\n            \"ROI table and max &amp; min translation need to contain the same \"\n            f\"ROIS, but they were {rois=}, {max_df.index=}, {min_df.index=}\"\n        )\n\n    for roi in rois:\n        roi_table[[roi], [\"z_micrometer\"]] = (\n            roi_table[[roi], [\"z_micrometer\"]].X\n            + float(max_df.loc[roi, \"translation_z\"])\n            - roi_table[[roi], [\"translation_z\"]].X\n        )\n        roi_table[[roi], [\"y_micrometer\"]] = (\n            roi_table[[roi], [\"y_micrometer\"]].X\n            + float(max_df.loc[roi, \"translation_y\"])\n            - roi_table[[roi], [\"translation_y\"]].X\n        )\n        roi_table[[roi], [\"x_micrometer\"]] = (\n            roi_table[[roi], [\"x_micrometer\"]].X\n            + float(max_df.loc[roi, \"translation_x\"])\n            - roi_table[[roi], [\"translation_x\"]].X\n        )\n        # This calculation only works if all ROIs are the same size initially!\n        roi_table[[roi], [\"len_z_micrometer\"]] = (\n            roi_table[[roi], [\"len_z_micrometer\"]].X\n            - float(max_df.loc[roi, \"translation_z\"])\n            + float(min_df.loc[roi, \"translation_z\"])\n        )\n        roi_table[[roi], [\"len_y_micrometer\"]] = (\n            roi_table[[roi], [\"len_y_micrometer\"]].X\n            - float(max_df.loc[roi, \"translation_y\"])\n            + float(min_df.loc[roi, \"translation_y\"])\n        )\n        roi_table[[roi], [\"len_x_micrometer\"]] = (\n            roi_table[[roi], [\"len_x_micrometer\"]].X\n            - float(max_df.loc[roi, \"translation_x\"])\n            + float(min_df.loc[roi, \"translation_x\"])\n        )\n    return roi_table\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/_registration_utils/#fractal_tasks_core.tasks._registration_utils.calculate_physical_shifts","title":"<code>calculate_physical_shifts(shifts, level, coarsening_xy, full_res_pxl_sizes_zyx)</code>","text":"<p>Calculates shifts in physical units based on pixel shifts</p> PARAMETER DESCRIPTION <code>shifts</code> <p>array of shifts, zyx or yx</p> <p> TYPE: <code>array</code> </p> <code>level</code> <p>resolution level</p> <p> TYPE: <code>int</code> </p> <code>coarsening_xy</code> <p>coarsening factor between levels</p> <p> TYPE: <code>int</code> </p> <code>full_res_pxl_sizes_zyx</code> <p>pixel sizes in physical units as zyx</p> <p> TYPE: <code>list[float]</code> </p> RETURNS DESCRIPTION <code>list[float]</code> <p>shifts in physical units as zyx</p> Source code in <code>fractal_tasks_core/tasks/_registration_utils.py</code> <pre><code>def calculate_physical_shifts(\n    shifts: np.array,\n    level: int,\n    coarsening_xy: int,\n    full_res_pxl_sizes_zyx: list[float],\n) -&gt; list[float]:\n\"\"\"\n    Calculates shifts in physical units based on pixel shifts\n\n    Args:\n        shifts: array of shifts, zyx or yx\n        level: resolution level\n        coarsening_xy: coarsening factor between levels\n        full_res_pxl_sizes_zyx: pixel sizes in physical units as zyx\n\n    Returns:\n        shifts in physical units as zyx\n    \"\"\"\n\n    curr_pixel_size = np.array(full_res_pxl_sizes_zyx) * coarsening_xy**level\n    if len(shifts) == 3:\n        shifts_physical = shifts * curr_pixel_size\n    elif len(shifts) == 2:\n        shifts_physical = [\n            0,\n            shifts[0] * curr_pixel_size[1],\n            shifts[1] * curr_pixel_size[2],\n        ]\n    else:\n        raise ValueError(\n            f\"Wrong input for calculate_physical_shifts ({shifts=})\"\n        )\n    return shifts_physical\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/_registration_utils/#fractal_tasks_core.tasks._registration_utils.chi2_shift_out","title":"<code>chi2_shift_out(img_ref, img_cycle_x)</code>","text":"<p>Helper function to get the output of chi2_shift into the same format as phase_cross_correlation. Calculates the shift between two images using the chi2_shift method.</p> PARAMETER DESCRIPTION <code>img_ref</code> <p>First image.</p> <p> TYPE: <code>ndarray</code> </p> <code>img_cycle_x</code> <p>Second image.</p> <p> TYPE: <code>ndarray</code> </p> RETURNS DESCRIPTION <code>list[ndarray]</code> <p>List containing numpy array of shift in y and x direction.</p> Source code in <code>fractal_tasks_core/tasks/_registration_utils.py</code> <pre><code>def chi2_shift_out(img_ref, img_cycle_x) -&gt; list[np.ndarray]:\n\"\"\"\n    Helper function to get the output of chi2_shift into the same format as\n    phase_cross_correlation. Calculates the shift between two images using\n    the chi2_shift method.\n\n    Args:\n        img_ref (np.ndarray): First image.\n        img_cycle_x (np.ndarray): Second image.\n\n    Returns:\n        List containing numpy array of shift in y and x direction.\n    \"\"\"\n    x, y, a, b = chi2_shift(np.squeeze(img_ref), np.squeeze(img_cycle_x))\n\n\"\"\"\n    Running into issues when using direct float output for fractal.\n    When rounding to integer and using integer dtype, it typically works\n    but for some reasons fails when run over a whole 384 well plate (but\n    the well where it fails works fine when run alone). For now, rounding\n    to integer, but still using float64 dtype (like the scikit-image\n    phase cross correlation function) seems to be the safest option.\n    \"\"\"\n    shifts = np.array([-np.round(y), -np.round(x)], dtype=\"float64\")\n    # return as a list to adhere to the phase_cross_correlation output format\n    return [shifts]\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/_registration_utils/#fractal_tasks_core.tasks._registration_utils.get_ROI_table_with_translation","title":"<code>get_ROI_table_with_translation(ROI_table, new_shifts)</code>","text":"<p>Adds translation columns to a ROI table</p> PARAMETER DESCRIPTION <code>ROI_table</code> <p>Fractal ROI table</p> <p> TYPE: <code>AnnData</code> </p> <code>new_shifts</code> <p>zyx list of shifts</p> <p> TYPE: <code>dict[str, list[float]]</code> </p> RETURNS DESCRIPTION <code>AnnData</code> <p>Fractal ROI table with 3 additional columns for calculated translations</p> Source code in <code>fractal_tasks_core/tasks/_registration_utils.py</code> <pre><code>def get_ROI_table_with_translation(\n    ROI_table: ad.AnnData,\n    new_shifts: dict[str, list[float]],\n) -&gt; ad.AnnData:\n\"\"\"\n    Adds translation columns to a ROI table\n\n    Args:\n        ROI_table: Fractal ROI table\n        new_shifts: zyx list of shifts\n\n    Returns:\n        Fractal ROI table with 3 additional columns for calculated translations\n    \"\"\"\n\n    shift_table = pd.DataFrame(new_shifts).T\n    shift_table.columns = [\"translation_z\", \"translation_y\", \"translation_x\"]\n    shift_table = shift_table.rename_axis(\"FieldIndex\")\n    new_roi_table = ROI_table.to_df().merge(\n        shift_table, left_index=True, right_index=True\n    )\n    if len(new_roi_table) != len(ROI_table):\n        raise ValueError(\n            \"New ROI table with registration info has a \"\n            f\"different length ({len(new_roi_table)=}) \"\n            f\"from the original ROI table ({len(ROI_table)=})\"\n        )\n\n    adata = ad.AnnData(X=new_roi_table.astype(np.float32))\n    adata.obs_names = new_roi_table.index\n    adata.var_names = list(map(str, new_roi_table.columns))\n    return adata\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/_registration_utils/#fractal_tasks_core.tasks._registration_utils.is_3D","title":"<code>is_3D(dask_array)</code>","text":"<p>Check if a dask array is 3D.</p> <p>Treats singelton Z dimensions as 2D images. (1, 2000, 2000) =&gt; False (10, 2000, 2000) =&gt; True</p> PARAMETER DESCRIPTION <code>dask_array</code> <p>Input array to be checked</p> <p> TYPE: <code>array</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>bool on whether the array is 3D</p> Source code in <code>fractal_tasks_core/tasks/_registration_utils.py</code> <pre><code>def is_3D(dask_array: da.array) -&gt; bool:\n\"\"\"\n    Check if a dask array is 3D.\n\n    Treats singelton Z dimensions as 2D images.\n    (1, 2000, 2000) =&gt; False\n    (10, 2000, 2000) =&gt; True\n\n    Args:\n        dask_array: Input array to be checked\n\n    Returns:\n        bool on whether the array is 3D\n    \"\"\"\n    if len(dask_array.shape) == 3 and dask_array.shape[0] &gt; 1:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/_utils/","title":"_utils","text":"<p>Standard input/output interface for tasks.</p>"},{"location":"reference/fractal_tasks_core/tasks/_utils/#fractal_tasks_core.tasks._utils.TaskParameterEncoder","title":"<code>TaskParameterEncoder</code>","text":"<p>               Bases: <code>JSONEncoder</code></p> <p>Custom JSONEncoder that transforms Path objects to strings.</p> Source code in <code>fractal_tasks_core/tasks/_utils.py</code> <pre><code>class TaskParameterEncoder(JSONEncoder):\n\"\"\"\n    Custom JSONEncoder that transforms Path objects to strings.\n    \"\"\"\n\n    def default(self, value):\n\"\"\"\n        Subclass implementation of `default`, to serialize Path objects as\n        strings.\n        \"\"\"\n        if isinstance(value, Path):\n            return value.as_posix()\n        return JSONEncoder.default(self, value)\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/_utils/#fractal_tasks_core.tasks._utils.TaskParameterEncoder.default","title":"<code>default(value)</code>","text":"<p>Subclass implementation of <code>default</code>, to serialize Path objects as strings.</p> Source code in <code>fractal_tasks_core/tasks/_utils.py</code> <pre><code>def default(self, value):\n\"\"\"\n    Subclass implementation of `default`, to serialize Path objects as\n    strings.\n    \"\"\"\n    if isinstance(value, Path):\n        return value.as_posix()\n    return JSONEncoder.default(self, value)\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/_utils/#fractal_tasks_core.tasks._utils.run_fractal_task","title":"<code>run_fractal_task(*, task_function, logger_name=None)</code>","text":"<p>Implement standard task interface and call task_function.</p> PARAMETER DESCRIPTION <code>task_function</code> <p>the callable function that runs the task.</p> <p> TYPE: <code>Callable</code> </p> <code>logger_name</code> <p>TBD</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>fractal_tasks_core/tasks/_utils.py</code> <pre><code>@deprecated(DEPRECATION_MSG_FUN)\ndef run_fractal_task(\n    *,\n    task_function: Callable,\n    logger_name: Optional[str] = None,\n):\n\"\"\"\n    Implement standard task interface and call task_function.\n\n    Args:\n        task_function: the callable function that runs the task.\n        logger_name: TBD\n    \"\"\"\n\n    # Parse `-j` and `--metadata-out` arguments\n    parser = ArgumentParser()\n    parser.add_argument(\n        \"--args-json\", help=\"Read parameters from json file\", required=True\n    )\n    parser.add_argument(\n        \"--out-json\",\n        help=\"Output file to redirect serialised returned data\",\n        required=True,\n    )\n    parsed_args = parser.parse_args()\n\n    # Set logger\n    logger = logging.getLogger(logger_name)\n\n    # Preliminary check\n    if Path(parsed_args.out_json).exists():\n        logger.error(\n            f\"Output file {parsed_args.out_json} already exists. Terminating\"\n        )\n        exit(1)\n\n    # Read parameters dictionary\n    with open(parsed_args.args_json, \"r\") as f:\n        pars = json.load(f)\n\n    # Run task\n    logger.info(f\"START {task_function.__name__} task\")\n    metadata_update = task_function(**pars)\n    logger.info(f\"END {task_function.__name__} task\")\n\n    # Write output metadata to file, with custom JSON encoder\n    with open(parsed_args.out_json, \"w\") as fout:\n        json.dump(metadata_update, fout, cls=TaskParameterEncoder, indent=2)\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/_zarr_utils/","title":"_zarr_utils","text":""},{"location":"reference/fractal_tasks_core/tasks/_zarr_utils/#fractal_tasks_core.tasks._zarr_utils._copy_hcs_ome_zarr_metadata","title":"<code>_copy_hcs_ome_zarr_metadata(zarr_url_origin, zarr_url_new)</code>","text":"<p>Updates the necessary metadata for a new copy of an OME-Zarr image</p> <p>Based on an existing OME-Zarr image in the same well, the metadata is copied and added to the new zarr well. Additionally, the well-level metadata is updated to include this new image.</p> PARAMETER DESCRIPTION <code>zarr_url_origin</code> <p>zarr_url of the origin image</p> <p> TYPE: <code>str</code> </p> <code>zarr_url_new</code> <p>zarr_url of the newly created image. The zarr-group already needs to exist, but metadata is written by this function.</p> <p> TYPE: <code>str</code> </p> Source code in <code>fractal_tasks_core/tasks/_zarr_utils.py</code> <pre><code>def _copy_hcs_ome_zarr_metadata(\n    zarr_url_origin: str,\n    zarr_url_new: str,\n) -&gt; None:\n\"\"\"\n    Updates the necessary metadata for a new copy of an OME-Zarr image\n\n    Based on an existing OME-Zarr image in the same well, the metadata is\n    copied and added to the new zarr well. Additionally, the well-level\n    metadata is updated to include this new image.\n\n    Args:\n        zarr_url_origin: zarr_url of the origin image\n        zarr_url_new: zarr_url of the newly created image. The zarr-group\n            already needs to exist, but metadata is written by this function.\n    \"\"\"\n    # Copy over OME-Zarr metadata for illumination_corrected image\n    # See #681 for discussion for validation of this zattrs\n    old_image_group = zarr.open_group(zarr_url_origin, mode=\"r\")\n    old_attrs = old_image_group.attrs.asdict()\n    zarr_url_new = zarr_url_new.rstrip(\"/\")\n    new_image_group = zarr.group(zarr_url_new)\n    new_image_group.attrs.put(old_attrs)\n\n    # Update well metadata about adding the new image:\n    new_image_path = zarr_url_new.split(\"/\")[-1]\n    well_url, old_image_path = _split_well_path_image_path(zarr_url_origin)\n    _update_well_metadata(well_url, old_image_path, new_image_path)\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/_zarr_utils/#fractal_tasks_core.tasks._zarr_utils._copy_tables_from_zarr_url","title":"<code>_copy_tables_from_zarr_url(origin_zarr_url, target_zarr_url, table_type=None, overwrite=True)</code>","text":"<p>Copies all ROI tables from one Zarr into a new Zarr</p> PARAMETER DESCRIPTION <code>origin_zarr_url</code> <p>url of the OME-Zarr image that contains tables. e.g. /path/to/my_plate.zarr/B/03/0</p> <p> TYPE: <code>str</code> </p> <code>target_zarr_url</code> <p>url of the new OME-Zarr image where tables are copied to. e.g. /path/to/my_plate.zarr/B/03/0_illum_corr</p> <p> TYPE: <code>str</code> </p> <code>table_type</code> <p>Filter for specific table types that should be copied.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>overwrite</code> <p>Whether existing tables of the same name in the target_zarr_url should be overwritten.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>fractal_tasks_core/tasks/_zarr_utils.py</code> <pre><code>def _copy_tables_from_zarr_url(\n    origin_zarr_url: str,\n    target_zarr_url: str,\n    table_type: str = None,\n    overwrite: bool = True,\n) -&gt; None:\n\"\"\"\n    Copies all ROI tables from one Zarr into a new Zarr\n\n    Args:\n        origin_zarr_url: url of the OME-Zarr image that contains tables.\n            e.g. /path/to/my_plate.zarr/B/03/0\n        target_zarr_url: url of the new OME-Zarr image where tables are copied\n            to. e.g. /path/to/my_plate.zarr/B/03/0_illum_corr\n        table_type: Filter for specific table types that should be copied.\n        overwrite: Whether existing tables of the same name in the\n            target_zarr_url should be overwritten.\n    \"\"\"\n    table_list = get_tables_list_v1(\n        zarr_url=origin_zarr_url, table_type=table_type\n    )\n\n    if table_list:\n        logger.info(\n            f\"Copying the tables {table_list} from {origin_zarr_url} to \"\n            f\"{target_zarr_url}.\"\n        )\n        new_image_group = zarr.group(target_zarr_url)\n\n        for table in table_list:\n            logger.info(f\"Copying table: {table}\")\n            # Get the relevant metadata of the Zarr table &amp; add it\n            table_url = f\"{origin_zarr_url}/tables/{table}\"\n            old_table_group = zarr.open_group(table_url, mode=\"r\")\n            # Write the Zarr table\n            curr_table = ad.read_zarr(table_url)\n            write_table(\n                new_image_group,\n                table,\n                curr_table,\n                table_attrs=old_table_group.attrs.asdict(),\n                overwrite=overwrite,\n            )\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/_zarr_utils/#fractal_tasks_core.tasks._zarr_utils._get_matching_ref_acquisition_path_heuristic","title":"<code>_get_matching_ref_acquisition_path_heuristic(path_list, path)</code>","text":"<p>Pick the best match from path_list to a given path</p> <p>This is a workaround to find the reference registration acquisition when there are multiple OME-Zarrs with the same acquisition identifier in the well metadata and we need to find which one is the reference for a given path.</p> PARAMETER DESCRIPTION <code>path_list</code> <p>List of paths to OME-Zarr images in the well metadata. For example: ['0', '0_illum_corr']</p> <p> TYPE: <code>list[str]</code> </p> <code>path</code> <p>A given path for which we want to find the reference image. For example, '1_illum_corr'</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The best matching reference path. If no direct match is found, it</p> <code>str</code> <p>returns the most similar one based on suffix hierarchy or the base</p> <code>str</code> <p>path if applicable. For example, '0_illum_corr' with the example</p> <code>str</code> <p>inputs above.</p> Source code in <code>fractal_tasks_core/tasks/_zarr_utils.py</code> <pre><code>def _get_matching_ref_acquisition_path_heuristic(\n    path_list: list[str], path: str\n) -&gt; str:\n\"\"\"\n    Pick the best match from path_list to a given path\n\n    This is a workaround to find the reference registration acquisition when\n    there are multiple OME-Zarrs with the same acquisition identifier in the\n    well metadata and we need to find which one is the reference for a given\n    path.\n\n    Args:\n        path_list: List of paths to OME-Zarr images in the well metadata. For\n            example: ['0', '0_illum_corr']\n        path: A given path for which we want to find the reference image. For\n            example, '1_illum_corr'\n\n    Returns:\n        The best matching reference path. If no direct match is found, it\n        returns the most similar one based on suffix hierarchy or the base\n        path if applicable. For example, '0_illum_corr' with the example\n        inputs above.\n    \"\"\"\n\n    # Extract the base number and suffix from the input path\n    base, suffix = _split_base_suffix(path)\n\n    # Sort path_list\n    sorted_path_list = sorted(path_list)\n\n    # First matching rule: a path with the same suffix\n    for p in sorted_path_list:\n        # Split the list path into base and suffix\n        p_base, p_suffix = _split_base_suffix(p)\n        # If suffices match, it's the match.\n        if p_suffix == suffix:\n            return p\n\n    # If no match is found, return the first entry in the list\n    logger.warning(\n        \"No heuristic reference acquisition match found, defaulting to first \"\n        f\"option {sorted_path_list[0]}.\"\n    )\n    return sorted_path_list[0]\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/_zarr_utils/#fractal_tasks_core.tasks._zarr_utils._update_well_metadata","title":"<code>_update_well_metadata(well_url, old_image_path, new_image_path, timeout=120)</code>","text":"<p>Update the well metadata by adding the new_image_path to the image list.</p> <p>The content of new_image_path will be based on old_image_path, the origin for the new image that was created. This function aims to avoid race conditions with other processes that try to update the well metadata file by using FileLock &amp; Timeouts</p> PARAMETER DESCRIPTION <code>well_url</code> <p>Path to the HCS OME-Zarr well that needs to be updated</p> <p> TYPE: <code>str</code> </p> <code>old_image_path</code> <p>path relative to well_url where the original image is found</p> <p> TYPE: <code>str</code> </p> <code>new_image_path</code> <p>path relative to well_url where the new image is placed</p> <p> TYPE: <code>str</code> </p> <code>timeout</code> <p>Timeout in seconds for trying to get the file lock</p> <p> TYPE: <code>int</code> DEFAULT: <code>120</code> </p> Source code in <code>fractal_tasks_core/tasks/_zarr_utils.py</code> <pre><code>def _update_well_metadata(\n    well_url: str,\n    old_image_path: str,\n    new_image_path: str,\n    timeout: int = 120,\n) -&gt; None:\n\"\"\"\n    Update the well metadata by adding the new_image_path to the image list.\n\n    The content of new_image_path will be based on old_image_path, the origin\n    for the new image that was created.\n    This function aims to avoid race conditions with other processes that try\n    to update the well metadata file by using FileLock &amp; Timeouts\n\n    Args:\n        well_url: Path to the HCS OME-Zarr well that needs to be updated\n        old_image_path: path relative to well_url where the original image is\n            found\n        new_image_path: path relative to well_url where the new image is placed\n        timeout: Timeout in seconds for trying to get the file lock\n    \"\"\"\n    lock = FileLock(f\"{well_url}/.zattrs.lock\")\n    with lock.acquire(timeout=timeout):\n        well_meta = load_NgffWellMeta(well_url)\n        existing_well_images = [image.path for image in well_meta.well.images]\n        if new_image_path in existing_well_images:\n            raise ValueError(\n                f\"Could not add the {new_image_path=} image to the well \"\n                \"metadata because and image with that name \"\n                f\"already existed in the well metadata: {well_meta}\"\n            )\n        try:\n            well_meta_image_old = next(\n                image\n                for image in well_meta.well.images\n                if image.path == old_image_path\n            )\n        except StopIteration:\n            raise ValueError(\n                f\"Could not find an image with {old_image_path=} in the \"\n                \"current well metadata.\"\n            )\n        well_meta_image = copy.deepcopy(well_meta_image_old)\n        well_meta_image.path = new_image_path\n        well_meta.well.images.append(well_meta_image)\n        well_meta.well.images = sorted(\n            well_meta.well.images,\n            key=lambda _image: _image.path,\n        )\n\n        well_group = zarr.group(well_url)\n        well_group.attrs.put(well_meta.model_dump(exclude_none=True))\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/apply_registration_to_image/","title":"apply_registration_to_image","text":"<p>Calculates translation for 2D image-based registration</p>"},{"location":"reference/fractal_tasks_core/tasks/apply_registration_to_image/#fractal_tasks_core.tasks.apply_registration_to_image.apply_registration_to_image","title":"<code>apply_registration_to_image(*, zarr_url, registered_roi_table, reference_acquisition=0, overwrite_input=True)</code>","text":"<p>Apply registration to images by using a registered ROI table</p> <p>This task consists of 4 parts:</p> <ol> <li>Mask all regions in images that are not available in the registered ROI table and store each acquisition aligned to the reference_acquisition (by looping over ROIs).</li> <li>Do the same for all label images.</li> <li>Copy all tables from the non-aligned image to the aligned image (currently only works well if the only tables are well &amp; FOV ROI tables (registered and original). Not implemented for measurement tables and other ROI tables).</li> <li>Clean up: Delete the old, non-aligned image and rename the new, aligned image to take over its place.</li> </ol> PARAMETER DESCRIPTION <code>zarr_url</code> <p>Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>registered_roi_table</code> <p>Name of the ROI table which has been registered and will be applied to mask and shift the images. Examples: <code>registered_FOV_ROI_table</code> =&gt; loop over the field of views, <code>registered_well_ROI_table</code> =&gt; process the whole well as one image.</p> <p> TYPE: <code>str</code> </p> <code>reference_acquisition</code> <p>Which acquisition to register against. Uses the OME-NGFF HCS well metadata acquisition keys to find the reference acquisition.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>overwrite_input</code> <p>Whether the old image data should be replaced with the newly registered image data. Currently only implemented for <code>overwrite_input=True</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>fractal_tasks_core/tasks/apply_registration_to_image.py</code> <pre><code>@validate_call\ndef apply_registration_to_image(\n    *,\n    # Fractal parameters\n    zarr_url: str,\n    # Core parameters\n    registered_roi_table: str,\n    reference_acquisition: int = 0,\n    overwrite_input: bool = True,\n):\n\"\"\"\n    Apply registration to images by using a registered ROI table\n\n    This task consists of 4 parts:\n\n    1. Mask all regions in images that are not available in the\n    registered ROI table and store each acquisition aligned to the\n    reference_acquisition (by looping over ROIs).\n    2. Do the same for all label images.\n    3. Copy all tables from the non-aligned image to the aligned image\n    (currently only works well if the only tables are well &amp; FOV ROI tables\n    (registered and original). Not implemented for measurement tables and\n    other ROI tables).\n    4. Clean up: Delete the old, non-aligned image and rename the new,\n    aligned image to take over its place.\n\n    Args:\n        zarr_url: Path or url to the individual OME-Zarr image to be processed.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        registered_roi_table: Name of the ROI table which has been registered\n            and will be applied to mask and shift the images.\n            Examples: `registered_FOV_ROI_table` =&gt; loop over the field of\n            views, `registered_well_ROI_table` =&gt; process the whole well as\n            one image.\n        reference_acquisition: Which acquisition to register against. Uses the\n            OME-NGFF HCS well metadata acquisition keys to find the reference\n            acquisition.\n        overwrite_input: Whether the old image data should be replaced with the\n            newly registered image data. Currently only implemented for\n            `overwrite_input=True`.\n\n    \"\"\"\n    logger.info(zarr_url)\n    logger.info(\n        f\"Running `apply_registration_to_image` on {zarr_url=}, \"\n        f\"{registered_roi_table=} and {reference_acquisition=}. \"\n        f\"Using {overwrite_input=}\"\n    )\n\n    well_url, old_img_path = _split_well_path_image_path(zarr_url)\n    new_zarr_url = f\"{well_url}/{zarr_url.split('/')[-1]}_registered\"\n    # Get the zarr_url for the reference acquisition\n    acq_dict = load_NgffWellMeta(well_url).get_acquisition_paths()\n    if reference_acquisition not in acq_dict:\n        raise ValueError(\n            f\"{reference_acquisition=} was not one of the available \"\n            f\"acquisitions in {acq_dict=} for well {well_url}\"\n        )\n    elif len(acq_dict[reference_acquisition]) &gt; 1:\n        ref_path = _get_matching_ref_acquisition_path_heuristic(\n            acq_dict[reference_acquisition], old_img_path\n        )\n        logger.warning(\n            \"Running registration when there are multiple images of the same \"\n            \"acquisition in a well. Using a heuristic to match the reference \"\n            f\"acquisition. Using {ref_path} as the reference image.\"\n        )\n    else:\n        ref_path = acq_dict[reference_acquisition][0]\n    reference_zarr_url = f\"{well_url}/{ref_path}\"\n\n    ROI_table_ref = ad.read_zarr(\n        f\"{reference_zarr_url}/tables/{registered_roi_table}\"\n    )\n    ROI_table_acq = ad.read_zarr(f\"{zarr_url}/tables/{registered_roi_table}\")\n\n    ngff_image_meta = load_NgffImageMeta(zarr_url)\n    coarsening_xy = ngff_image_meta.coarsening_xy\n    num_levels = ngff_image_meta.num_levels\n\n    ####################\n    # Process images\n    ####################\n    logger.info(\"Write the registered Zarr image to disk\")\n    write_registered_zarr(\n        zarr_url=zarr_url,\n        new_zarr_url=new_zarr_url,\n        ROI_table=ROI_table_acq,\n        ROI_table_ref=ROI_table_ref,\n        num_levels=num_levels,\n        coarsening_xy=coarsening_xy,\n        aggregation_function=np.mean,\n    )\n\n    ####################\n    # Process labels\n    ####################\n    try:\n        labels_group = zarr.open_group(f\"{zarr_url}/labels\", \"r\")\n        label_list = labels_group.attrs[\"labels\"]\n    except (zarr.errors.GroupNotFoundError, KeyError):\n        label_list = []\n\n    if label_list:\n        logger.info(f\"Processing the label images: {label_list}\")\n        labels_group = zarr.group(f\"{new_zarr_url}/labels\")\n        labels_group.attrs[\"labels\"] = label_list\n\n        for label in label_list:\n            write_registered_zarr(\n                zarr_url=f\"{zarr_url}/labels/{label}\",\n                new_zarr_url=f\"{new_zarr_url}/labels/{label}\",\n                ROI_table=ROI_table_acq,\n                ROI_table_ref=ROI_table_ref,\n                num_levels=num_levels,\n                coarsening_xy=coarsening_xy,\n                aggregation_function=np.max,\n            )\n\n    ####################\n    # Copy tables\n    # 1. Copy all standard ROI tables from the reference acquisition.\n    # 2. Copy all tables that aren't standard ROI tables from the given\n    # acquisition.\n    ####################\n    table_dict_reference = _get_table_path_dict(reference_zarr_url)\n    table_dict_component = _get_table_path_dict(zarr_url)\n\n    table_dict = {}\n    # Define which table should get copied:\n    for table in table_dict_reference:\n        if is_standard_roi_table(table):\n            table_dict[table] = table_dict_reference[table]\n    for table in table_dict_component:\n        if not is_standard_roi_table(table):\n            if reference_zarr_url != zarr_url:\n                logger.warning(\n                    f\"{zarr_url} contained a table that is not a standard \"\n                    \"ROI table. The `Apply Registration To Image task` is \"\n                    \"best used before additional tables are generated. It \"\n                    f\"will copy the {table} from this acquisition without \"\n                    \"applying any transformations. This will work well if \"\n                    f\"{table} contains measurements. But if {table} is a \"\n                    \"custom ROI table coming from another task, the \"\n                    \"transformation is not applied and it will not match \"\n                    \"with the registered image anymore.\"\n                )\n            table_dict[table] = table_dict_component[table]\n\n    if table_dict:\n        logger.info(f\"Processing the tables: {table_dict}\")\n        new_image_group = zarr.group(new_zarr_url)\n\n        for table in table_dict.keys():\n            logger.info(f\"Copying table: {table}\")\n            # Get the relevant metadata of the Zarr table &amp; add it\n            # See issue #516 for the need for this workaround\n            max_retries = 20\n            sleep_time = 10\n            current_round = 0\n            while current_round &lt; max_retries:\n                try:\n                    old_table_group = zarr.open_group(\n                        table_dict[table], mode=\"r\"\n                    )\n                    current_round = max_retries\n                    curr_table = ad.read_zarr(table_dict[table])\n                    break  # Exit loop on success\n                except (\n                    zarr.errors.GroupNotFoundError,\n                    zarr.errors.PathNotFoundError,\n                    FileNotFoundError,\n                ):\n                    logger.debug(\n                        f\"Table {table} not found in attempt {current_round}. \"\n                        f\"Waiting {sleep_time} seconds before trying again.\"\n                    )\n                    current_round += 1\n                    time.sleep(sleep_time)\n            else:\n                # This runs only if the loop exits via exhaustion\n                raise RuntimeError(\n                    f\"Table {table} not found after {max_retries} attempts.\"\n                    \"Check whether this table actually exists. If it does, \"\n                    \"this may be a race condition issue.\"\n                )\n            # Write the Zarr table\n            write_table(\n                new_image_group,\n                table,\n                curr_table,\n                table_attrs=old_table_group.attrs.asdict(),\n                overwrite=True,\n            )\n\n    ####################\n    # Clean up Zarr file\n    ####################\n    if overwrite_input:\n        logger.info(\n            \"Replace original zarr image with the newly created Zarr image\"\n        )\n        # Potential for race conditions: Every acquisition reads the\n        # reference acquisition, but the reference acquisition also gets\n        # modified\n        # See issue #516 for the details\n        os.rename(zarr_url, f\"{zarr_url}_tmp\")\n        os.rename(new_zarr_url, zarr_url)\n        shutil.rmtree(f\"{zarr_url}_tmp\")\n        image_list_updates = dict(image_list_updates=[dict(zarr_url=zarr_url)])\n    else:\n        image_list_updates = dict(\n            image_list_updates=[dict(zarr_url=new_zarr_url, origin=zarr_url)]\n        )\n        # Update the metadata of the the well\n        well_url, new_img_path = _split_well_path_image_path(new_zarr_url)\n        _update_well_metadata(\n            well_url=well_url,\n            old_image_path=old_img_path,\n            new_image_path=new_img_path,\n        )\n\n    return image_list_updates\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/apply_registration_to_image/#fractal_tasks_core.tasks.apply_registration_to_image.write_registered_zarr","title":"<code>write_registered_zarr(zarr_url, new_zarr_url, ROI_table, ROI_table_ref, num_levels, coarsening_xy=2, aggregation_function=np.mean)</code>","text":"<p>Write registered zarr array based on ROI tables</p> <p>This function loads the image or label data from a zarr array based on the ROI bounding-box coordinates and stores them into a new zarr array. The new Zarr array has the same shape as the original array, but will have 0s where the ROI tables don't specify loading of the image data. The ROIs loaded from <code>list_indices</code> will be written into the <code>list_indices_ref</code> position, thus performing translational registration if the two lists of ROI indices vary.</p> PARAMETER DESCRIPTION <code>zarr_url</code> <p>Path or url to the individual OME-Zarr image to be used as the basis for the new OME-Zarr image.</p> <p> TYPE: <code>str</code> </p> <code>new_zarr_url</code> <p>Path or url to the new OME-Zarr image to be written</p> <p> TYPE: <code>str</code> </p> <code>ROI_table</code> <p>Fractal ROI table for the component</p> <p> TYPE: <code>AnnData</code> </p> <code>ROI_table_ref</code> <p>Fractal ROI table for the reference acquisition</p> <p> TYPE: <code>AnnData</code> </p> <code>num_levels</code> <p>Number of pyramid layers to be created (argument of <code>build_pyramid</code>).</p> <p> TYPE: <code>int</code> </p> <code>coarsening_xy</code> <p>Coarsening factor between pyramid levels</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>aggregation_function</code> <p>Function to be used when downsampling (argument of <code>build_pyramid</code>).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>mean</code> </p> Source code in <code>fractal_tasks_core/tasks/apply_registration_to_image.py</code> <pre><code>def write_registered_zarr(\n    zarr_url: str,\n    new_zarr_url: str,\n    ROI_table: ad.AnnData,\n    ROI_table_ref: ad.AnnData,\n    num_levels: int,\n    coarsening_xy: int = 2,\n    aggregation_function: Callable = np.mean,\n):\n\"\"\"\n    Write registered zarr array based on ROI tables\n\n    This function loads the image or label data from a zarr array based on the\n    ROI bounding-box coordinates and stores them into a new zarr array.\n    The new Zarr array has the same shape as the original array, but will have\n    0s where the ROI tables don't specify loading of the image data.\n    The ROIs loaded from `list_indices` will be written into the\n    `list_indices_ref` position, thus performing translational registration if\n    the two lists of ROI indices vary.\n\n    Args:\n        zarr_url: Path or url to the individual OME-Zarr image to be used as\n            the basis for the new OME-Zarr image.\n        new_zarr_url: Path or url to the new OME-Zarr image to be written\n        ROI_table: Fractal ROI table for the component\n        ROI_table_ref: Fractal ROI table for the reference acquisition\n        num_levels: Number of pyramid layers to be created (argument of\n            `build_pyramid`).\n        coarsening_xy: Coarsening factor between pyramid levels\n        aggregation_function: Function to be used when downsampling (argument\n            of `build_pyramid`).\n\n    \"\"\"\n    # Read pixel sizes from Zarr attributes\n    ngff_image_meta = load_NgffImageMeta(zarr_url)\n    pxl_sizes_zyx = ngff_image_meta.get_pixel_sizes_zyx(level=0)\n\n    # Create list of indices for 3D ROIs\n    list_indices = convert_ROI_table_to_indices(\n        ROI_table,\n        level=0,\n        coarsening_xy=coarsening_xy,\n        full_res_pxl_sizes_zyx=pxl_sizes_zyx,\n    )\n    list_indices_ref = convert_ROI_table_to_indices(\n        ROI_table_ref,\n        level=0,\n        coarsening_xy=coarsening_xy,\n        full_res_pxl_sizes_zyx=pxl_sizes_zyx,\n    )\n\n    old_image_group = zarr.open_group(zarr_url, mode=\"r\")\n    old_ngff_image_meta = load_NgffImageMeta(zarr_url)\n    new_image_group = zarr.group(new_zarr_url)\n    new_image_group.attrs.put(old_image_group.attrs.asdict())\n\n    # Loop over all channels. For each channel, write full-res image data.\n    data_array = da.from_zarr(old_image_group[\"0\"])\n    # Create dask array with 0s of same shape\n    new_array = da.zeros_like(data_array)\n\n    # TODO: Add sanity checks on the 2 ROI tables:\n    # 1. The number of ROIs need to match\n    # 2. The size of the ROIs need to match\n    # (otherwise, we can't assign them to the reference regions)\n    # ROI_table_ref vs ROI_table_acq\n    for i, roi_indices in enumerate(list_indices):\n        reference_region = convert_indices_to_regions(list_indices_ref[i])\n        region = convert_indices_to_regions(roi_indices)\n\n        axes_list = old_ngff_image_meta.axes_names\n\n        if axes_list == [\"c\", \"z\", \"y\", \"x\"]:\n            num_channels = data_array.shape[0]\n            # Loop over channels\n            for ind_ch in range(num_channels):\n                idx = tuple(\n                    [slice(ind_ch, ind_ch + 1)] + list(reference_region)\n                )\n                new_array[idx] = load_region(\n                    data_zyx=data_array[ind_ch], region=region, compute=False\n                )\n        elif axes_list == [\"z\", \"y\", \"x\"]:\n            new_array[reference_region] = load_region(\n                data_zyx=data_array, region=region, compute=False\n            )\n        elif axes_list == [\"c\", \"y\", \"x\"]:\n            # TODO: Implement cyx case (based on looping over xy case)\n            raise NotImplementedError(\n                \"`write_registered_zarr` has not been implemented for \"\n                f\"a zarr with {axes_list=}\"\n            )\n        elif axes_list == [\"y\", \"x\"]:\n            # TODO: Implement yx case\n            raise NotImplementedError(\n                \"`write_registered_zarr` has not been implemented for \"\n                f\"a zarr with {axes_list=}\"\n            )\n        else:\n            raise NotImplementedError(\n                \"`write_registered_zarr` has not been implemented for \"\n                f\"a zarr with {axes_list=}\"\n            )\n\n    new_array.to_zarr(\n        f\"{new_zarr_url}/0\",\n        overwrite=True,\n        dimension_separator=\"/\",\n        write_empty_chunks=False,\n    )\n\n    # Starting from on-disk highest-resolution data, build and write to\n    # disk a pyramid of coarser levels\n    build_pyramid(\n        zarrurl=new_zarr_url,\n        overwrite=True,\n        num_levels=num_levels,\n        coarsening_xy=coarsening_xy,\n        chunksize=data_array.chunksize,\n        aggregation_function=aggregation_function,\n    )\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/calculate_registration_image_based/","title":"calculate_registration_image_based","text":"<p>Calculates translation for image-based registration</p>"},{"location":"reference/fractal_tasks_core/tasks/calculate_registration_image_based/#fractal_tasks_core.tasks.calculate_registration_image_based.RegistrationMethod","title":"<code>RegistrationMethod</code>","text":"<p>               Bases: <code>Enum</code></p> <p>RegistrationMethod Enum class</p> ATTRIBUTE DESCRIPTION <code>PHASE_CROSS_CORRELATION</code> <p>phase cross correlation based on scikit-image (works with 2D &amp; 3D images).</p> <p> </p> <code>CHI2_SHIFT</code> <p>chi2 shift based on image-registration library (only works with 2D images).</p> <p> </p> Source code in <code>fractal_tasks_core/tasks/calculate_registration_image_based.py</code> <pre><code>class RegistrationMethod(Enum):\n\"\"\"\n    RegistrationMethod Enum class\n\n    Attributes:\n        PHASE_CROSS_CORRELATION: phase cross correlation based on scikit-image\n            (works with 2D &amp; 3D images).\n        CHI2_SHIFT: chi2 shift based on image-registration library\n            (only works with 2D images).\n    \"\"\"\n\n    PHASE_CROSS_CORRELATION = \"phase_cross_correlation\"\n    CHI2_SHIFT = \"chi2_shift\"\n\n    def register(self, img_ref, img_acq_x):\n        if self == RegistrationMethod.PHASE_CROSS_CORRELATION:\n            return phase_cross_correlation(img_ref, img_acq_x)\n        elif self == RegistrationMethod.CHI2_SHIFT:\n            return chi2_shift_out(img_ref, img_acq_x)\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/calculate_registration_image_based/#fractal_tasks_core.tasks.calculate_registration_image_based.calculate_registration_image_based","title":"<code>calculate_registration_image_based(*, zarr_url, init_args, wavelength_id, method=RegistrationMethod.PHASE_CROSS_CORRELATION, lower_rescale_quantile=0.0, upper_rescale_quantile=0.99, roi_table='FOV_ROI_table', level=2)</code>","text":"<p>Calculate registration based on images</p> <p>This task consists of 3 parts:</p> <ol> <li>Loading the images of a given ROI (=&gt; loop over ROIs)</li> <li>Calculating the transformation for that ROI</li> <li>Storing the calculated transformation in the ROI table</li> </ol> PARAMETER DESCRIPTION <code>zarr_url</code> <p>Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>init_args</code> <p>Intialization arguments provided by <code>image_based_registration_hcs_init</code>. They contain the reference_zarr_url that is used for registration. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>InitArgsRegistration</code> </p> <code>wavelength_id</code> <p>Wavelength that will be used for image-based registration; e.g. <code>A01_C01</code> for Yokogawa, <code>C01</code> for MD.</p> <p> TYPE: <code>str</code> </p> <code>method</code> <p>Method to use for image registration. The available methods are <code>phase_cross_correlation</code> (scikit-image package, works for 2D &amp; 3D) and \"chi2_shift\" (image_registration package, only works for 2D images).</p> <p> TYPE: <code>RegistrationMethod</code> DEFAULT: <code>PHASE_CROSS_CORRELATION</code> </p> <code>lower_rescale_quantile</code> <p>Lower quantile for rescaling the image intensities before applying registration. Can be helpful  to deal with image artifacts. Default is 0.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> <code>upper_rescale_quantile</code> <p>Upper quantile for rescaling the image intensities before applying registration. Can be helpful to deal with image artifacts. Default is 0.99.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.99</code> </p> <code>roi_table</code> <p>Name of the ROI table over which the task loops to calculate the registration. Examples: <code>FOV_ROI_table</code> =&gt; loop over the field of views, <code>well_ROI_table</code> =&gt; process the whole well as one image.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'FOV_ROI_table'</code> </p> <code>level</code> <p>Pyramid level of the image to be used for registration. Choose <code>0</code> to process at full resolution.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> Source code in <code>fractal_tasks_core/tasks/calculate_registration_image_based.py</code> <pre><code>@validate_call\ndef calculate_registration_image_based(\n    *,\n    # Fractal arguments\n    zarr_url: str,\n    init_args: InitArgsRegistration,\n    # Core parameters\n    wavelength_id: str,\n    method: RegistrationMethod = RegistrationMethod.PHASE_CROSS_CORRELATION,\n    lower_rescale_quantile: float = 0.0,\n    upper_rescale_quantile: float = 0.99,\n    roi_table: str = \"FOV_ROI_table\",\n    level: int = 2,\n) -&gt; None:\n\"\"\"\n    Calculate registration based on images\n\n    This task consists of 3 parts:\n\n    1. Loading the images of a given ROI (=&gt; loop over ROIs)\n    2. Calculating the transformation for that ROI\n    3. Storing the calculated transformation in the ROI table\n\n    Args:\n        zarr_url: Path or url to the individual OME-Zarr image to be processed.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        init_args: Intialization arguments provided by\n            `image_based_registration_hcs_init`. They contain the\n            reference_zarr_url that is used for registration.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        wavelength_id: Wavelength that will be used for image-based\n            registration; e.g. `A01_C01` for Yokogawa, `C01` for MD.\n        method: Method to use for image registration. The available methods\n            are `phase_cross_correlation` (scikit-image package, works for 2D\n            &amp; 3D) and \"chi2_shift\" (image_registration package, only works for\n            2D images).\n        lower_rescale_quantile: Lower quantile for rescaling the image\n            intensities before applying registration. Can be helpful\n             to deal with image artifacts. Default is 0.\n        upper_rescale_quantile: Upper quantile for rescaling the image\n            intensities before applying registration. Can be helpful\n            to deal with image artifacts. Default is 0.99.\n        roi_table: Name of the ROI table over which the task loops to\n            calculate the registration. Examples: `FOV_ROI_table` =&gt; loop over\n            the field of views, `well_ROI_table` =&gt; process the whole well as\n            one image.\n        level: Pyramid level of the image to be used for registration.\n            Choose `0` to process at full resolution.\n\n    \"\"\"\n    logger.info(\n        f\"Running for {zarr_url=}.\\n\"\n        f\"Calculating translation registration per {roi_table=} for \"\n        f\"{wavelength_id=}.\"\n    )\n\n    init_args.reference_zarr_url = init_args.reference_zarr_url\n\n    # Read some parameters from Zarr metadata\n    ngff_image_meta = load_NgffImageMeta(str(init_args.reference_zarr_url))\n    coarsening_xy = ngff_image_meta.coarsening_xy\n\n    # Get channel_index via wavelength_id.\n    # Intially only allow registration of the same wavelength\n    channel_ref: OmeroChannel = get_channel_from_image_zarr(\n        image_zarr_path=init_args.reference_zarr_url,\n        wavelength_id=wavelength_id,\n    )\n    channel_index_ref = channel_ref.index\n\n    channel_align: OmeroChannel = get_channel_from_image_zarr(\n        image_zarr_path=zarr_url,\n        wavelength_id=wavelength_id,\n    )\n    channel_index_align = channel_align.index\n\n    # Lazily load zarr array\n    data_reference_zyx = da.from_zarr(\n        f\"{init_args.reference_zarr_url}/{level}\"\n    )[channel_index_ref]\n    data_alignment_zyx = da.from_zarr(f\"{zarr_url}/{level}\")[\n        channel_index_align\n    ]\n\n    # Check if data is 3D (as not all registration methods work in 3D)\n    # TODO: Abstract this check into a higher-level Zarr loading class\n    if is_3D(data_reference_zyx):\n        if method == RegistrationMethod(RegistrationMethod.CHI2_SHIFT):\n            raise ValueError(\n                f\"The `{RegistrationMethod.CHI2_SHIFT}` registration method \"\n                \"has not been implemented for 3D images and the input image \"\n                f\"had a shape of {data_reference_zyx.shape}.\"\n            )\n\n    # Read ROIs\n    ROI_table_ref = ad.read_zarr(\n        f\"{init_args.reference_zarr_url}/tables/{roi_table}\"\n    )\n    ROI_table_x = ad.read_zarr(f\"{zarr_url}/tables/{roi_table}\")\n    logger.info(\n        f\"Found {len(ROI_table_x)} ROIs in {roi_table=} to be processed.\"\n    )\n\n    # Check that table type of ROI_table_ref is valid. Note that\n    # \"ngff:region_table\" and None are accepted for backwards compatibility\n    valid_table_types = [\n        \"roi_table\",\n        \"masking_roi_table\",\n        \"ngff:region_table\",\n        None,\n    ]\n    ROI_table_ref_group = zarr.open_group(\n        f\"{init_args.reference_zarr_url}/tables/{roi_table}\",\n        mode=\"r\",\n    )\n    ref_table_attrs = ROI_table_ref_group.attrs.asdict()\n    ref_table_type = ref_table_attrs.get(\"type\")\n    if ref_table_type not in valid_table_types:\n        raise ValueError(\n            (\n                f\"Table '{roi_table}' (with type '{ref_table_type}') is \"\n                \"not a valid ROI table.\"\n            )\n        )\n\n    # For each acquisition, get the relevant info\n    # TODO: Add additional checks on ROIs?\n    if (ROI_table_ref.obs.index != ROI_table_x.obs.index).all():\n        raise ValueError(\n            \"Registration is only implemented for ROIs that match between the \"\n            \"acquisitions (e.g. well, FOV ROIs). Here, the ROIs in the \"\n            f\"reference acquisitions were {ROI_table_ref.obs.index}, but the \"\n            f\"ROIs in the alignment acquisition were {ROI_table_x.obs.index}\"\n        )\n    # TODO: Make this less restrictive? i.e. could we also run it if different\n    # acquisitions have different FOVs? But then how do we know which FOVs to\n    # match?\n    # If we relax this, downstream assumptions on matching based on order\n    # in the list will break.\n\n    # Read pixel sizes from zarr attributes\n    ngff_image_meta_acq_x = load_NgffImageMeta(zarr_url)\n    pxl_sizes_zyx = ngff_image_meta.get_pixel_sizes_zyx(level=0)\n    pxl_sizes_zyx_acq_x = ngff_image_meta_acq_x.get_pixel_sizes_zyx(level=0)\n\n    if pxl_sizes_zyx != pxl_sizes_zyx_acq_x:\n        raise ValueError(\n            \"Pixel sizes need to be equal between acquisitions for \"\n            \"registration.\"\n        )\n\n    # Create list of indices for 3D ROIs spanning the entire Z direction\n    list_indices_ref = convert_ROI_table_to_indices(\n        ROI_table_ref,\n        level=level,\n        coarsening_xy=coarsening_xy,\n        full_res_pxl_sizes_zyx=pxl_sizes_zyx,\n    )\n    check_valid_ROI_indices(list_indices_ref, roi_table)\n\n    list_indices_acq_x = convert_ROI_table_to_indices(\n        ROI_table_x,\n        level=level,\n        coarsening_xy=coarsening_xy,\n        full_res_pxl_sizes_zyx=pxl_sizes_zyx,\n    )\n    check_valid_ROI_indices(list_indices_acq_x, roi_table)\n\n    num_ROIs = len(list_indices_ref)\n    compute = True\n    new_shifts = {}\n    for i_ROI in range(num_ROIs):\n        logger.info(\n            f\"Now processing ROI {i_ROI+1}/{num_ROIs} \"\n            f\"for channel {channel_align}.\"\n        )\n        img_ref = load_region(\n            data_zyx=data_reference_zyx,\n            region=convert_indices_to_regions(list_indices_ref[i_ROI]),\n            compute=compute,\n        )\n        img_acq_x = load_region(\n            data_zyx=data_alignment_zyx,\n            region=convert_indices_to_regions(list_indices_acq_x[i_ROI]),\n            compute=compute,\n        )\n\n        # Rescale the images\n        img_ref = rescale_intensity(\n            img_ref,\n            in_range=(\n                np.quantile(img_ref, lower_rescale_quantile),\n                np.quantile(img_ref, upper_rescale_quantile),\n            ),\n        )\n        img_acq_x = rescale_intensity(\n            img_acq_x,\n            in_range=(\n                np.quantile(img_acq_x, lower_rescale_quantile),\n                np.quantile(img_acq_x, upper_rescale_quantile),\n            ),\n        )\n\n        ##############\n        #  Calculate the transformation\n        ##############\n        if img_ref.shape != img_acq_x.shape:\n            raise NotImplementedError(\n                \"This registration is not implemented for ROIs with \"\n                \"different shapes between acquisitions.\"\n            )\n\n        shifts = method.register(np.squeeze(img_ref), np.squeeze(img_acq_x))[0]\n\n        ##############\n        # Store the calculated transformation ###\n        ##############\n        # Adapt ROIs for the given ROI table:\n        ROI_name = ROI_table_ref.obs.index[i_ROI]\n        new_shifts[ROI_name] = calculate_physical_shifts(\n            shifts,\n            level=level,\n            coarsening_xy=coarsening_xy,\n            full_res_pxl_sizes_zyx=pxl_sizes_zyx,\n        )\n\n    # Write physical shifts to disk (as part of the ROI table)\n    logger.info(f\"Updating the {roi_table=} with translation columns\")\n    image_group = zarr.group(zarr_url)\n    new_ROI_table = get_ROI_table_with_translation(ROI_table_x, new_shifts)\n    write_table(\n        image_group,\n        roi_table,\n        new_ROI_table,\n        overwrite=True,\n        table_attrs=ref_table_attrs,\n    )\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_segmentation/","title":"cellpose_segmentation","text":"<p>Image segmentation via Cellpose library.</p>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_segmentation/#fractal_tasks_core.tasks.cellpose_segmentation.cellpose_segmentation","title":"<code>cellpose_segmentation(*, zarr_url, level, channel, channel2=Field(default_factory=CellposeChannel2InputModel), input_ROI_table='FOV_ROI_table', output_ROI_table=None, output_label_name=None, diameter_level0=30.0, model_type='cyto2', pretrained_model=None, relabeling=True, use_masks=True, advanced_cellpose_model_params=Field(default_factory=CellposeModelParams), overwrite=True)</code>","text":"<p>Run cellpose segmentation on the ROIs of a single OME-Zarr image.</p> PARAMETER DESCRIPTION <code>zarr_url</code> <p>Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>level</code> <p>Pyramid level of the image to be segmented. Choose <code>0</code> to process at full resolution.</p> <p> TYPE: <code>int</code> </p> <code>channel</code> <p>Primary channel for segmentation; requires either <code>wavelength_id</code> (e.g. <code>A01_C01</code>) or <code>label</code> (e.g. <code>DAPI</code>), but not both. Also contains normalization options. By default, data is normalized so 0.0=1st percentile and 1.0=99th percentile of image intensities in each channel. This automatic normalization can lead to issues when the image to be segmented is very sparse. You can turn off the default rescaling. With the \"custom\" option, you can either provide your own rescaling percentiles or fixed rescaling upper and lower bound integers.</p> <p> TYPE: <code>CellposeChannel1InputModel</code> </p> <code>channel2</code> <p>Second channel for segmentation (in the same format as <code>channel</code>). If specified, cellpose runs in dual channel mode. For dual channel segmentation of cells, the first channel should contain the membrane marker, the second channel should contain the nuclear marker.</p> <p> TYPE: <code>CellposeChannel2InputModel</code> DEFAULT: <code>Field(default_factory=CellposeChannel2InputModel)</code> </p> <code>input_ROI_table</code> <p>Name of the ROI table over which the task loops to apply Cellpose segmentation. Examples: <code>FOV_ROI_table</code> =&gt; loop over the field of views, <code>organoid_ROI_table</code> =&gt; loop over the organoid ROI table (generated by another task), <code>well_ROI_table</code> =&gt; process the whole well as one image.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'FOV_ROI_table'</code> </p> <code>output_ROI_table</code> <p>If provided, a ROI table with that name is created, which will contain the bounding boxes of the newly segmented labels. ROI tables should have <code>ROI</code> in their name.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>output_label_name</code> <p>Name of the output label image (e.g. <code>\"organoids\"</code>).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>diameter_level0</code> <p>Expected diameter of the objects that should be segmented in pixels at level 0. Initial diameter is rescaled using the <code>level</code> that was selected. The rescaled value is passed as the diameter to the <code>CellposeModel.eval</code> method.</p> <p> TYPE: <code>float</code> DEFAULT: <code>30.0</code> </p> <code>model_type</code> <p>Parameter of <code>CellposeModel</code> class. Defines which model should be used. Typical choices are <code>nuclei</code>, <code>cyto</code>, <code>cyto2</code>, etc.</p> <p> TYPE: <code>Literal[tuple(MODEL_NAMES)]</code> DEFAULT: <code>'cyto2'</code> </p> <code>pretrained_model</code> <p>Parameter of <code>CellposeModel</code> class (takes precedence over <code>model_type</code>). Allows you to specify the path of a custom trained cellpose model.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>relabeling</code> <p>If <code>True</code>, apply relabeling so that label values are unique for all objects in the well.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>use_masks</code> <p>If <code>True</code>, try to use masked loading and fall back to <code>use_masks=False</code> if the ROI table is not suitable. Masked loading is relevant when only a subset of the bounding box should actually be processed (e.g. running within <code>organoid_ROI_table</code>).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>advanced_cellpose_model_params</code> <p>Advanced Cellpose model parameters that are passed to the Cellpose <code>model.eval</code> method.</p> <p> TYPE: <code>CellposeModelParams</code> DEFAULT: <code>Field(default_factory=CellposeModelParams)</code> </p> <code>overwrite</code> <p>If <code>True</code>, overwrite the task output.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>fractal_tasks_core/tasks/cellpose_segmentation.py</code> <pre><code>@validate_call\ndef cellpose_segmentation(\n    *,\n    # Fractal parameters\n    zarr_url: str,\n    # Core parameters\n    level: int,\n    channel: CellposeChannel1InputModel,\n    channel2: CellposeChannel2InputModel = Field(\n        default_factory=CellposeChannel2InputModel\n    ),\n    input_ROI_table: str = \"FOV_ROI_table\",\n    output_ROI_table: Optional[str] = None,\n    output_label_name: Optional[str] = None,\n    # Cellpose-related arguments\n    diameter_level0: float = 30.0,\n    # https://github.com/fractal-analytics-platform/fractal-tasks-core/issues/401 # noqa E501\n    model_type: Literal[tuple(models.MODEL_NAMES)] = \"cyto2\",  # type: ignore\n    pretrained_model: Optional[str] = None,\n    relabeling: bool = True,\n    use_masks: bool = True,\n    advanced_cellpose_model_params: CellposeModelParams = Field(\n        default_factory=CellposeModelParams\n    ),\n    overwrite: bool = True,\n) -&gt; None:\n\"\"\"\n    Run cellpose segmentation on the ROIs of a single OME-Zarr image.\n\n    Args:\n        zarr_url: Path or url to the individual OME-Zarr image to be processed.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        level: Pyramid level of the image to be segmented. Choose `0` to\n            process at full resolution.\n        channel: Primary channel for segmentation; requires either\n            `wavelength_id` (e.g. `A01_C01`) or `label` (e.g. `DAPI`), but not\n            both. Also contains normalization options. By default, data is\n            normalized so 0.0=1st percentile and 1.0=99th percentile of image\n            intensities in each channel.\n            This automatic normalization can lead to issues when the image to\n            be segmented is very sparse. You can turn off the default\n            rescaling. With the \"custom\" option, you can either provide your\n            own rescaling percentiles or fixed rescaling upper and lower\n            bound integers.\n        channel2: Second channel for segmentation (in the same format as\n            `channel`). If specified, cellpose runs in dual channel mode.\n            For dual channel segmentation of cells, the first channel should\n            contain the membrane marker, the second channel should contain the\n            nuclear marker.\n        input_ROI_table: Name of the ROI table over which the task loops to\n            apply Cellpose segmentation. Examples: `FOV_ROI_table` =&gt; loop over\n            the field of views, `organoid_ROI_table` =&gt; loop over the organoid\n            ROI table (generated by another task), `well_ROI_table` =&gt; process\n            the whole well as one image.\n        output_ROI_table: If provided, a ROI table with that name is created,\n            which will contain the bounding boxes of the newly segmented\n            labels. ROI tables should have `ROI` in their name.\n        output_label_name: Name of the output label image (e.g. `\"organoids\"`).\n        diameter_level0: Expected diameter of the objects that should be\n            segmented in pixels at level 0. Initial diameter is rescaled using\n            the `level` that was selected. The rescaled value is passed as\n            the diameter to the `CellposeModel.eval` method.\n        model_type: Parameter of `CellposeModel` class. Defines which model\n            should be used. Typical choices are `nuclei`, `cyto`, `cyto2`, etc.\n        pretrained_model: Parameter of `CellposeModel` class (takes\n            precedence over `model_type`). Allows you to specify the path of\n            a custom trained cellpose model.\n        relabeling: If `True`, apply relabeling so that label values are\n            unique for all objects in the well.\n        use_masks: If `True`, try to use masked loading and fall back to\n            `use_masks=False` if the ROI table is not suitable. Masked\n            loading is relevant when only a subset of the bounding box should\n            actually be processed (e.g. running within `organoid_ROI_table`).\n        advanced_cellpose_model_params: Advanced Cellpose model parameters\n            that are passed to the Cellpose `model.eval` method.\n        overwrite: If `True`, overwrite the task output.\n    \"\"\"\n    logger.info(f\"Processing {zarr_url=}\")\n\n    # Preliminary checks on Cellpose model\n    if pretrained_model:\n        if not os.path.exists(pretrained_model):\n            raise ValueError(f\"{pretrained_model=} does not exist.\")\n\n    # Read attributes from NGFF metadata\n    ngff_image_meta = load_NgffImageMeta(zarr_url)\n    num_levels = ngff_image_meta.num_levels\n    coarsening_xy = ngff_image_meta.coarsening_xy\n    full_res_pxl_sizes_zyx = ngff_image_meta.get_pixel_sizes_zyx(level=0)\n    actual_res_pxl_sizes_zyx = ngff_image_meta.get_pixel_sizes_zyx(level=level)\n    logger.info(f\"NGFF image has {num_levels=}\")\n    logger.info(f\"NGFF image has {coarsening_xy=}\")\n    logger.info(\n        f\"NGFF image has full-res pixel sizes {full_res_pxl_sizes_zyx}\"\n    )\n    logger.info(\n        f\"NGFF image has level-{level} pixel sizes \"\n        f\"{actual_res_pxl_sizes_zyx}\"\n    )\n\n    # Find channel index\n    omero_channel = channel.get_omero_channel(zarr_url)\n    if omero_channel:\n        ind_channel = omero_channel.index\n    else:\n        return\n\n    # Find channel index for second channel, if one is provided\n    if channel2.is_set():\n        omero_channel_2 = channel2.get_omero_channel(zarr_url)\n        if omero_channel_2:\n            ind_channel_c2 = omero_channel_2.index\n        else:\n            return\n\n    # Set channel label\n    if output_label_name is None:\n        try:\n            channel_label = omero_channel.label\n            output_label_name = f\"label_{channel_label}\"\n        except (KeyError, IndexError):\n            output_label_name = f\"label_{ind_channel}\"\n\n    # Load ZYX data\n    # Workaround for #788: Only load channel index when there is a channel\n    # dimension\n    if ngff_image_meta.axes_names[0] != \"c\":\n        data_zyx = da.from_zarr(f\"{zarr_url}/{level}\")\n        if channel2.is_set():\n            raise ValueError(\n                \"Dual channel input was specified for an OME-Zarr image \"\n                \"without a channel axis\"\n            )\n    else:\n        data_zyx = da.from_zarr(f\"{zarr_url}/{level}\")[ind_channel]\n        if channel2.is_set():\n            data_zyx_c2 = da.from_zarr(f\"{zarr_url}/{level}\")[ind_channel_c2]\n            logger.info(f\"Second channel: {data_zyx_c2.shape=}\")\n    logger.info(f\"{data_zyx.shape=}\")\n\n    # Read ROI table\n    ROI_table_path = f\"{zarr_url}/tables/{input_ROI_table}\"\n    ROI_table = ad.read_zarr(ROI_table_path)\n\n    # Perform some checks on the ROI table\n    valid_ROI_table = is_ROI_table_valid(\n        table_path=ROI_table_path, use_masks=use_masks\n    )\n    if use_masks and not valid_ROI_table:\n        logger.info(\n            f\"ROI table at {ROI_table_path} cannot be used for masked \"\n            \"loading. Set use_masks=False.\"\n        )\n        use_masks = False\n    logger.info(f\"{use_masks=}\")\n\n    # Create list of indices for 3D ROIs spanning the entire Z direction\n    list_indices = convert_ROI_table_to_indices(\n        ROI_table,\n        level=level,\n        coarsening_xy=coarsening_xy,\n        full_res_pxl_sizes_zyx=full_res_pxl_sizes_zyx,\n    )\n    check_valid_ROI_indices(list_indices, input_ROI_table)\n\n    # If we are not planning to use masked loading, fail for overlapping ROIs\n    if not use_masks:\n        overlap = find_overlaps_in_ROI_indices(list_indices)\n        if overlap:\n            raise ValueError(\n                f\"ROI indices created from {input_ROI_table} table have \"\n                \"overlaps, but we are not using masked loading.\"\n            )\n\n    # Select 2D/3D behavior and set some parameters\n    do_3D = data_zyx.shape[0] &gt; 1 and len(data_zyx.shape) == 3\n    if do_3D:\n        if advanced_cellpose_model_params.anisotropy is None:\n            # Compute anisotropy as pixel_size_z/pixel_size_x\n            advanced_cellpose_model_params.anisotropy = (\n                actual_res_pxl_sizes_zyx[0] / actual_res_pxl_sizes_zyx[2]\n            )\n        logger.info(f\"Anisotropy: {advanced_cellpose_model_params.anisotropy}\")\n\n    # Rescale datasets (only relevant for level&gt;0)\n    # Workaround for #788\n    if ngff_image_meta.axes_names[0] != \"c\":\n        new_datasets = rescale_datasets(\n            datasets=[ds.model_dump() for ds in ngff_image_meta.datasets],\n            coarsening_xy=coarsening_xy,\n            reference_level=level,\n            remove_channel_axis=False,\n        )\n    else:\n        new_datasets = rescale_datasets(\n            datasets=[ds.model_dump() for ds in ngff_image_meta.datasets],\n            coarsening_xy=coarsening_xy,\n            reference_level=level,\n            remove_channel_axis=True,\n        )\n\n    label_attrs = {\n        \"image-label\": {\n            \"version\": __OME_NGFF_VERSION__,\n            \"source\": {\"image\": \"../../\"},\n        },\n        \"multiscales\": [\n            {\n                \"name\": output_label_name,\n                \"version\": __OME_NGFF_VERSION__,\n                \"axes\": [\n                    ax.dict()\n                    for ax in ngff_image_meta.multiscale.axes\n                    if ax.type != \"channel\"\n                ],\n                \"datasets\": new_datasets,\n            }\n        ],\n    }\n\n    image_group = zarr.group(zarr_url)\n    label_group = prepare_label_group(\n        image_group,\n        output_label_name,\n        overwrite=overwrite,\n        label_attrs=label_attrs,\n        logger=logger,\n    )\n\n    logger.info(\n        f\"Helper function `prepare_label_group` returned {label_group=}\"\n    )\n    logger.info(f\"Output label path: {zarr_url}/labels/{output_label_name}/0\")\n    store = zarr.storage.FSStore(f\"{zarr_url}/labels/{output_label_name}/0\")\n    label_dtype = np.uint32\n\n    # Ensure that all output shapes &amp; chunks are 3D (for 2D data: (1, y, x))\n    # https://github.com/fractal-analytics-platform/fractal-tasks-core/issues/398\n    shape = data_zyx.shape\n    if len(shape) == 2:\n        shape = (1, *shape)\n    chunks = data_zyx.chunksize\n    if len(chunks) == 2:\n        chunks = (1, *chunks)\n    mask_zarr = zarr.create(\n        shape=shape,\n        chunks=chunks,\n        dtype=label_dtype,\n        store=store,\n        overwrite=False,\n        dimension_separator=\"/\",\n    )\n\n    logger.info(\n        f\"mask will have shape {data_zyx.shape} \"\n        f\"and chunks {data_zyx.chunks}\"\n    )\n\n    # Initialize cellpose\n    gpu = advanced_cellpose_model_params.use_gpu and cellpose.core.use_gpu()\n    if pretrained_model:\n        model = models.CellposeModel(\n            gpu=gpu, pretrained_model=pretrained_model\n        )\n    else:\n        model = models.CellposeModel(gpu=gpu, model_type=model_type)\n\n    # Initialize other things\n    logger.info(f\"Start cellpose_segmentation task for {zarr_url}\")\n    logger.info(f\"relabeling: {relabeling}\")\n    logger.info(f\"do_3D: {do_3D}\")\n    logger.info(f\"use_gpu: {gpu}\")\n    logger.info(f\"level: {level}\")\n    logger.info(f\"model_type: {model_type}\")\n    logger.info(f\"pretrained_model: {pretrained_model}\")\n    logger.info(f\"anisotropy: {advanced_cellpose_model_params.anisotropy}\")\n    logger.info(\"Total well shape/chunks:\")\n    logger.info(f\"{data_zyx.shape}\")\n    logger.info(f\"{data_zyx.chunks}\")\n    if channel2.is_set():\n        logger.info(\"Dual channel input for cellpose model\")\n        logger.info(f\"{data_zyx_c2.shape}\")\n        logger.info(f\"{data_zyx_c2.chunks}\")\n\n    # Counters for relabeling\n    num_labels_tot = {\"num_labels_tot\": 0}\n\n    # Iterate over ROIs\n    num_ROIs = len(list_indices)\n\n    if output_ROI_table:\n        bbox_dataframe_list = []\n\n    logger.info(f\"Now starting loop over {num_ROIs} ROIs\")\n    for i_ROI, indices in enumerate(list_indices):\n        # Define region\n        s_z, e_z, s_y, e_y, s_x, e_x = indices[:]\n        region = (\n            slice(s_z, e_z),\n            slice(s_y, e_y),\n            slice(s_x, e_x),\n        )\n        logger.info(f\"Now processing ROI {i_ROI+1}/{num_ROIs}\")\n\n        # Prepare single-channel or dual-channel input for cellpose\n        if channel2.is_set():\n            # Dual channel mode, first channel is the membrane channel\n            img_1 = load_region(\n                data_zyx,\n                region,\n                compute=True,\n                return_as_3D=True,\n            )\n            img_np = np.zeros((2, *img_1.shape))\n            img_np[0, :, :, :] = img_1\n            img_np[1, :, :, :] = load_region(\n                data_zyx_c2,\n                region,\n                compute=True,\n                return_as_3D=True,\n            )\n            channels = [1, 2]\n        else:\n            img_np = np.expand_dims(\n                load_region(data_zyx, region, compute=True, return_as_3D=True),\n                axis=0,\n            )\n            channels = [0, 0]\n\n        # Prepare keyword arguments for segment_ROI function\n        kwargs_segment_ROI = dict(\n            num_labels_tot=num_labels_tot,\n            model=model,\n            channels=channels,\n            do_3D=do_3D,\n            label_dtype=label_dtype,\n            diameter=diameter_level0 / coarsening_xy**level,\n            normalize=channel.normalize,\n            normalize2=channel2.normalize,\n            relabeling=relabeling,\n            advanced_cellpose_model_params=advanced_cellpose_model_params,\n        )\n\n        # Prepare keyword arguments for preprocessing function\n        preprocessing_kwargs = {}\n        if use_masks:\n            preprocessing_kwargs = dict(\n                region=region,\n                current_label_path=f\"{zarr_url}/labels/{output_label_name}/0\",\n                ROI_table_path=ROI_table_path,\n                ROI_positional_index=i_ROI,\n            )\n\n        # Call segment_ROI through the masked-loading wrapper, which includes\n        # pre/post-processing functions if needed\n        new_label_img = masked_loading_wrapper(\n            image_array=img_np,\n            function=segment_ROI,\n            kwargs=kwargs_segment_ROI,\n            use_masks=use_masks,\n            preprocessing_kwargs=preprocessing_kwargs,\n        )\n\n        if output_ROI_table:\n            bbox_df = array_to_bounding_box_table(\n                new_label_img,\n                actual_res_pxl_sizes_zyx,\n                origin_zyx=(s_z, s_y, s_x),\n            )\n\n            bbox_dataframe_list.append(bbox_df)\n\n        # Compute and store 0-th level to disk\n        da.array(new_label_img).to_zarr(\n            url=mask_zarr,\n            region=region,\n            compute=True,\n        )\n\n    logger.info(\n        f\"End cellpose_segmentation task for {zarr_url}, \"\n        \"now building pyramids.\"\n    )\n\n    # Starting from on-disk highest-resolution data, build and write to disk a\n    # pyramid of coarser levels\n    build_pyramid(\n        zarrurl=f\"{zarr_url}/labels/{output_label_name}\",\n        overwrite=overwrite,\n        num_levels=num_levels,\n        coarsening_xy=coarsening_xy,\n        chunksize=chunks,\n        aggregation_function=np.max,\n    )\n\n    logger.info(\"End building pyramids\")\n\n    if output_ROI_table:\n        bbox_table = create_roi_table_from_df_list(bbox_dataframe_list)\n\n        # Write to zarr group\n        image_group = zarr.group(zarr_url)\n        logger.info(\n            \"Now writing bounding-box ROI table to \"\n            f\"{zarr_url}/tables/{output_ROI_table}\"\n        )\n        table_attrs = {\n            \"type\": \"masking_roi_table\",\n            \"region\": {\"path\": f\"../labels/{output_label_name}\"},\n            \"instance_key\": \"label\",\n        }\n        write_table(\n            image_group,\n            output_ROI_table,\n            bbox_table,\n            overwrite=overwrite,\n            table_attrs=table_attrs,\n        )\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_segmentation/#fractal_tasks_core.tasks.cellpose_segmentation.segment_ROI","title":"<code>segment_ROI(x, num_labels_tot, model=None, do_3D=True, channels=[0, 0], diameter=30.0, normalize=CellposeCustomNormalizer(), normalize2=None, label_dtype=None, relabeling=True, advanced_cellpose_model_params=CellposeModelParams())</code>","text":"<p>Internal function that runs Cellpose segmentation for a single ROI.</p> PARAMETER DESCRIPTION <code>x</code> <p>4D numpy array.</p> <p> TYPE: <code>ndarray</code> </p> <code>num_labels_tot</code> <p>Number of labels already in total image. Used for relabeling purposes. Using a dict to have a mutable object that can be edited from within the function without having to be passed back through the masked_loading_wrapper.</p> <p> TYPE: <code>dict[str, int]</code> </p> <code>model</code> <p>An instance of <code>models.CellposeModel</code>.</p> <p> TYPE: <code>CellposeModel</code> DEFAULT: <code>None</code> </p> <code>do_3D</code> <p>If <code>True</code>, cellpose runs in 3D mode: runs on xy, xz &amp; yz planes, then averages the flows.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>channels</code> <p>Which channels to use. If only one channel is provided, <code>[0, 0]</code> should be used. If two channels are provided (the first dimension of <code>x</code> has length of 2), <code>[1, 2]</code> should be used (<code>x[0, :, :,:]</code> contains the membrane channel and <code>x[1, :, :, :]</code> contains the nuclear channel).</p> <p> TYPE: <code>list[int]</code> DEFAULT: <code>[0, 0]</code> </p> <code>diameter</code> <p>Expected object diameter in pixels for cellpose.</p> <p> TYPE: <code>float</code> DEFAULT: <code>30.0</code> </p> <code>normalize</code> <p>By default, data is normalized so 0.0=1st percentile and 1.0=99th percentile of image intensities in each channel. This automatic normalization can lead to issues when the image to be segmented is very sparse. You can turn off the default rescaling. With the \"custom\" option, you can either provide your own rescaling percentiles or fixed rescaling upper and lower bound integers.</p> <p> TYPE: <code>CellposeCustomNormalizer</code> DEFAULT: <code>CellposeCustomNormalizer()</code> </p> <code>normalize2</code> <p>Normalization options for channel 2. If one channel is normalized with default settings, both channels need to be normalized with default settings.</p> <p> TYPE: <code>Optional[CellposeCustomNormalizer]</code> DEFAULT: <code>None</code> </p> <code>label_dtype</code> <p>Label images are cast into this <code>np.dtype</code>.</p> <p> TYPE: <code>Optional[dtype]</code> DEFAULT: <code>None</code> </p> <code>relabeling</code> <p>Whether relabeling based on num_labels_tot is performed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>advanced_cellpose_model_params</code> <p>Advanced Cellpose model parameters that are passed to the Cellpose <code>model.eval</code> method.</p> <p> TYPE: <code>CellposeModelParams</code> DEFAULT: <code>CellposeModelParams()</code> </p> Source code in <code>fractal_tasks_core/tasks/cellpose_segmentation.py</code> <pre><code>def segment_ROI(\n    x: np.ndarray,\n    num_labels_tot: dict[str, int],\n    model: models.CellposeModel = None,\n    do_3D: bool = True,\n    channels: list[int] = [0, 0],\n    diameter: float = 30.0,\n    normalize: CellposeCustomNormalizer = CellposeCustomNormalizer(),\n    normalize2: Optional[CellposeCustomNormalizer] = None,\n    label_dtype: Optional[np.dtype] = None,\n    relabeling: bool = True,\n    advanced_cellpose_model_params: CellposeModelParams = CellposeModelParams(),  # noqa: E501\n) -&gt; np.ndarray:\n\"\"\"\n    Internal function that runs Cellpose segmentation for a single ROI.\n\n    Args:\n        x: 4D numpy array.\n        num_labels_tot: Number of labels already in total image. Used for\n            relabeling purposes. Using a dict to have a mutable object that\n            can be edited from within the function without having to be passed\n            back through the masked_loading_wrapper.\n        model: An instance of `models.CellposeModel`.\n        do_3D: If `True`, cellpose runs in 3D mode: runs on xy, xz &amp; yz planes,\n            then averages the flows.\n        channels: Which channels to use. If only one channel is provided, `[0,\n            0]` should be used. If two channels are provided (the first\n            dimension of `x` has length of 2), `[1, 2]` should be used\n            (`x[0, :, :,:]` contains the membrane channel and\n            `x[1, :, :, :]` contains the nuclear channel).\n        diameter: Expected object diameter in pixels for cellpose.\n        normalize: By default, data is normalized so 0.0=1st percentile and\n            1.0=99th percentile of image intensities in each channel.\n            This automatic normalization can lead to issues when the image to\n            be segmented is very sparse. You can turn off the default\n            rescaling. With the \"custom\" option, you can either provide your\n            own rescaling percentiles or fixed rescaling upper and lower\n            bound integers.\n        normalize2: Normalization options for channel 2. If one channel is\n            normalized with default settings, both channels need to be\n            normalized with default settings.\n        label_dtype: Label images are cast into this `np.dtype`.\n        relabeling: Whether relabeling based on num_labels_tot is performed.\n        advanced_cellpose_model_params: Advanced Cellpose model parameters\n            that are passed to the Cellpose `model.eval` method.\n    \"\"\"\n\n    # Write some debugging info\n    logger.info(\n        \"[segment_ROI] START |\"\n        f\" x: {type(x)}, {x.shape} |\"\n        f\" {do_3D=} |\"\n        f\" {model.diam_mean=} |\"\n        f\" {diameter=} |\"\n        f\" {advanced_cellpose_model_params.flow_threshold=} |\"\n        f\" {normalize.type=}\"\n    )\n    x = _normalize_cellpose_channels(x, channels, normalize, normalize2)\n\n    # Actual labeling\n    t0 = time.perf_counter()\n    mask, _, _ = model.eval(\n        x,\n        channels=channels,\n        do_3D=do_3D,\n        net_avg=advanced_cellpose_model_params.net_avg,\n        augment=advanced_cellpose_model_params.augment,\n        diameter=diameter,\n        anisotropy=advanced_cellpose_model_params.anisotropy,\n        cellprob_threshold=advanced_cellpose_model_params.cellprob_threshold,\n        flow_threshold=advanced_cellpose_model_params.flow_threshold,\n        normalize=normalize.cellpose_normalize,\n        min_size=advanced_cellpose_model_params.min_size,\n        batch_size=advanced_cellpose_model_params.batch_size,\n        invert=advanced_cellpose_model_params.invert,\n        tile=advanced_cellpose_model_params.tile,\n        tile_overlap=advanced_cellpose_model_params.tile_overlap,\n        resample=advanced_cellpose_model_params.resample,\n        interp=advanced_cellpose_model_params.interp,\n        stitch_threshold=advanced_cellpose_model_params.stitch_threshold,\n    )\n\n    if mask.ndim == 2:\n        # If we get a 2D image, we still return it as a 3D array\n        mask = np.expand_dims(mask, axis=0)\n    t1 = time.perf_counter()\n\n    # Write some debugging info\n    logger.info(\n        \"[segment_ROI] END   |\"\n        f\" Elapsed: {t1-t0:.3f} s |\"\n        f\" {mask.shape=},\"\n        f\" {mask.dtype=} (then {label_dtype}),\"\n        f\" {np.max(mask)=} |\"\n        f\" {model.diam_mean=} |\"\n        f\" {diameter=} |\"\n        f\" {advanced_cellpose_model_params.flow_threshold=}\"\n    )\n\n    # Shift labels and update relabeling counters\n    if relabeling:\n        num_labels_roi = np.max(mask)\n        mask[mask &gt; 0] += num_labels_tot[\"num_labels_tot\"]\n        num_labels_tot[\"num_labels_tot\"] += num_labels_roi\n\n        # Write some logs\n        logger.info(f\"ROI had {num_labels_roi=}, {num_labels_tot=}\")\n\n        # Check that total number of labels is under control\n        if num_labels_tot[\"num_labels_tot\"] &gt; np.iinfo(label_dtype).max:\n            raise ValueError(\n                \"ERROR in re-labeling:\"\n                f\"Reached {num_labels_tot} labels, \"\n                f\"but dtype={label_dtype}\"\n            )\n\n    return mask.astype(label_dtype)\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_utils/","title":"cellpose_utils","text":"<p>Helper functions for image normalization in</p>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_utils/#fractal_tasks_core.tasks.cellpose_utils.CellposeChannel1InputModel","title":"<code>CellposeChannel1InputModel</code>","text":"<p>               Bases: <code>ChannelInputModel</code></p> <p>Channel input for cellpose with normalization options.</p> ATTRIBUTE DESCRIPTION <code>wavelength_id</code> <p>Unique ID for the channel wavelength, e.g. <code>A01_C01</code>. Can only be specified if label is not set.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>label</code> <p>Name of the channel. Can only be specified if wavelength_id is not set.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>normalize</code> <p>Validator to handle different normalization scenarios for Cellpose models</p> <p> TYPE: <code>CellposeCustomNormalizer</code> </p> Source code in <code>fractal_tasks_core/tasks/cellpose_utils.py</code> <pre><code>class CellposeChannel1InputModel(ChannelInputModel):\n\"\"\"\n    Channel input for cellpose with normalization options.\n\n    Attributes:\n        wavelength_id: Unique ID for the channel wavelength, e.g. `A01_C01`.\n            Can only be specified if label is not set.\n        label: Name of the channel. Can only be specified if wavelength_id is\n            not set.\n        normalize: Validator to handle different normalization scenarios for\n            Cellpose models\n    \"\"\"\n\n    normalize: CellposeCustomNormalizer = Field(\n        default_factory=CellposeCustomNormalizer\n    )\n\n    def get_omero_channel(self, zarr_url) -&gt; OmeroChannel:\n        try:\n            return get_channel_from_image_zarr(\n                image_zarr_path=zarr_url,\n                wavelength_id=self.wavelength_id,\n                label=self.label,\n            )\n        except ChannelNotFoundError as e:\n            logger.warning(\n                f\"Channel with wavelength_id: {self.wavelength_id} \"\n                f\"and label: {self.label} not found, exit from the task.\\n\"\n                f\"Original error: {str(e)}\"\n            )\n            return None\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_utils/#fractal_tasks_core.tasks.cellpose_utils.CellposeChannel2InputModel","title":"<code>CellposeChannel2InputModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Channel input for secondary cellpose channel with normalization options.</p> <p>The secondary channel is Optional, thus both wavelength_id and label are optional to be set. The <code>is_set</code> function shows whether either value was set.</p> ATTRIBUTE DESCRIPTION <code>wavelength_id</code> <p>Unique ID for the channel wavelength, e.g. <code>A01_C01</code>. Can only be specified if label is not set.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>label</code> <p>Name of the channel. Can only be specified if wavelength_id is not set.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>normalize</code> <p>Validator to handle different normalization scenarios for Cellpose models</p> <p> TYPE: <code>CellposeCustomNormalizer</code> </p> Source code in <code>fractal_tasks_core/tasks/cellpose_utils.py</code> <pre><code>class CellposeChannel2InputModel(BaseModel):\n\"\"\"\n    Channel input for secondary cellpose channel with normalization options.\n\n    The secondary channel is Optional, thus both wavelength_id and label are\n    optional to be set. The `is_set` function shows whether either value was\n    set.\n\n    Attributes:\n        wavelength_id: Unique ID for the channel wavelength, e.g. `A01_C01`.\n            Can only be specified if label is not set.\n        label: Name of the channel. Can only be specified if wavelength_id is\n            not set.\n        normalize: Validator to handle different normalization scenarios for\n            Cellpose models\n    \"\"\"\n\n    wavelength_id: Optional[str] = None\n    label: Optional[str] = None\n    normalize: CellposeCustomNormalizer = Field(\n        default_factory=CellposeCustomNormalizer\n    )\n\n    @model_validator(mode=\"after\")\n    def mutually_exclusive_channel_attributes(self: Self) -&gt; Self:\n\"\"\"\n        Check that only 1 of `label` or `wavelength_id` is set.\n        \"\"\"\n        wavelength_id = self.wavelength_id\n        label = self.label\n        if (wavelength_id is not None) and (label is not None):\n            raise ValueError(\n                \"`wavelength_id` and `label` cannot be both set \"\n                f\"(given {wavelength_id=} and {label=}).\"\n            )\n        return self\n\n    def is_set(self):\n        if self.wavelength_id or self.label:\n            return True\n        return False\n\n    def get_omero_channel(self, zarr_url) -&gt; OmeroChannel:\n        try:\n            return get_channel_from_image_zarr(\n                image_zarr_path=zarr_url,\n                wavelength_id=self.wavelength_id,\n                label=self.label,\n            )\n        except ChannelNotFoundError as e:\n            logger.warning(\n                f\"Second channel with wavelength_id: {self.wavelength_id} \"\n                f\"and label: {self.label} not found, exit from the task.\\n\"\n                f\"Original error: {str(e)}\"\n            )\n            return None\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_utils/#fractal_tasks_core.tasks.cellpose_utils.CellposeChannel2InputModel.mutually_exclusive_channel_attributes","title":"<code>mutually_exclusive_channel_attributes()</code>","text":"<p>Check that only 1 of <code>label</code> or <code>wavelength_id</code> is set.</p> Source code in <code>fractal_tasks_core/tasks/cellpose_utils.py</code> <pre><code>@model_validator(mode=\"after\")\ndef mutually_exclusive_channel_attributes(self: Self) -&gt; Self:\n\"\"\"\n    Check that only 1 of `label` or `wavelength_id` is set.\n    \"\"\"\n    wavelength_id = self.wavelength_id\n    label = self.label\n    if (wavelength_id is not None) and (label is not None):\n        raise ValueError(\n            \"`wavelength_id` and `label` cannot be both set \"\n            f\"(given {wavelength_id=} and {label=}).\"\n        )\n    return self\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_utils/#fractal_tasks_core.tasks.cellpose_utils.CellposeCustomNormalizer","title":"<code>CellposeCustomNormalizer</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Validator to handle different normalization scenarios for Cellpose models</p> <p>If <code>type=\"default\"</code>, then Cellpose default normalization is used and no other parameters can be specified. If <code>type=\"no_normalization\"</code>, then no normalization is used and no other parameters can be specified. If <code>type=\"custom\"</code>, then either percentiles or explicit integer bounds can be applied.</p> ATTRIBUTE DESCRIPTION <code>type</code> <p>One of <code>default</code> (Cellpose default normalization), <code>custom</code> (using the other custom parameters) or <code>no_normalization</code>.</p> <p> TYPE: <code>Literal['default', 'custom', 'no_normalization']</code> </p> <code>lower_percentile</code> <p>Specify a custom lower-bound percentile for rescaling as a float value between 0 and 100. Set to 1 to run the same as default). You can only specify percentiles or bounds, not both.</p> <p> TYPE: <code>Optional[float]</code> </p> <code>upper_percentile</code> <p>Specify a custom upper-bound percentile for rescaling as a float value between 0 and 100. Set to 99 to run the same as default, set to e.g. 99.99 if the default rescaling was too harsh. You can only specify percentiles or bounds, not both.</p> <p> TYPE: <code>Optional[float]</code> </p> <code>lower_bound</code> <p>Explicit lower bound value to rescale the image at. Needs to be an integer, e.g. 100. You can only specify percentiles or bounds, not both.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>upper_bound</code> <p>Explicit upper bound value to rescale the image at. Needs to be an integer, e.g. 2000. You can only specify percentiles or bounds, not both.</p> <p> TYPE: <code>Optional[int]</code> </p> Source code in <code>fractal_tasks_core/tasks/cellpose_utils.py</code> <pre><code>class CellposeCustomNormalizer(BaseModel):\n\"\"\"\n    Validator to handle different normalization scenarios for Cellpose models\n\n    If `type=\"default\"`, then Cellpose default normalization is\n    used and no other parameters can be specified.\n    If `type=\"no_normalization\"`, then no normalization is used and no\n    other parameters can be specified.\n    If `type=\"custom\"`, then either percentiles or explicit integer\n    bounds can be applied.\n\n    Attributes:\n        type:\n            One of `default` (Cellpose default normalization), `custom`\n            (using the other custom parameters) or `no_normalization`.\n        lower_percentile: Specify a custom lower-bound percentile for rescaling\n            as a float value between 0 and 100. Set to 1 to run the same as\n            default). You can only specify percentiles or bounds, not both.\n        upper_percentile: Specify a custom upper-bound percentile for rescaling\n            as a float value between 0 and 100. Set to 99 to run the same as\n            default, set to e.g. 99.99 if the default rescaling was too harsh.\n            You can only specify percentiles or bounds, not both.\n        lower_bound: Explicit lower bound value to rescale the image at.\n            Needs to be an integer, e.g. 100.\n            You can only specify percentiles or bounds, not both.\n        upper_bound: Explicit upper bound value to rescale the image at.\n            Needs to be an integer, e.g. 2000.\n            You can only specify percentiles or bounds, not both.\n    \"\"\"\n\n    type: Literal[\"default\", \"custom\", \"no_normalization\"] = \"default\"\n    lower_percentile: Optional[float] = Field(None, ge=0, le=100)\n    upper_percentile: Optional[float] = Field(None, ge=0, le=100)\n    lower_bound: Optional[int] = None\n    upper_bound: Optional[int] = None\n\n    # In the future, add an option to allow using precomputed percentiles\n    # that are stored in OME-Zarr histograms and use this pydantic model that\n    # those histograms actually exist\n\n    @model_validator(mode=\"after\")\n    def validate_conditions(self: Self) -&gt; Self:\n        # Extract values\n        type = self.type\n        lower_percentile = self.lower_percentile\n        upper_percentile = self.upper_percentile\n        lower_bound = self.lower_bound\n        upper_bound = self.upper_bound\n\n        # Verify that custom parameters are only provided when type=\"custom\"\n        if type != \"custom\":\n            if lower_percentile is not None:\n                raise ValueError(\n                    f\"Type='{type}' but {lower_percentile=}. \"\n                    \"Hint: set type='custom'.\"\n                )\n            if upper_percentile is not None:\n                raise ValueError(\n                    f\"Type='{type}' but {upper_percentile=}. \"\n                    \"Hint: set type='custom'.\"\n                )\n            if lower_bound is not None:\n                raise ValueError(\n                    f\"Type='{type}' but {lower_bound=}. \"\n                    \"Hint: set type='custom'.\"\n                )\n            if upper_bound is not None:\n                raise ValueError(\n                    f\"Type='{type}' but {upper_bound=}. \"\n                    \"Hint: set type='custom'.\"\n                )\n\n        # The only valid options are:\n        # 1. Both percentiles are set and both bounds are unset\n        # 2. Both bounds are set and both percentiles are unset\n        are_percentiles_set = (\n            lower_percentile is not None,\n            upper_percentile is not None,\n        )\n        are_bounds_set = (\n            lower_bound is not None,\n            upper_bound is not None,\n        )\n        if len(set(are_percentiles_set)) != 1:\n            raise ValueError(\n                \"Both lower_percentile and upper_percentile must be set \"\n                \"together.\"\n            )\n        if len(set(are_bounds_set)) != 1:\n            raise ValueError(\n                \"Both lower_bound and upper_bound must be set together\"\n            )\n        if lower_percentile is not None and lower_bound is not None:\n            raise ValueError(\n                \"You cannot set both explicit bounds and percentile bounds \"\n                \"at the same time. Hint: use only one of the two options.\"\n            )\n\n        return self\n\n    @property\n    def cellpose_normalize(self) -&gt; bool:\n\"\"\"\n        Determine whether cellpose should apply its internal normalization.\n\n        If type is set to `custom` or `no_normalization`, don't apply cellpose\n        internal normalization\n        \"\"\"\n        return self.type == \"default\"\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_utils/#fractal_tasks_core.tasks.cellpose_utils.CellposeCustomNormalizer.cellpose_normalize","title":"<code>cellpose_normalize: bool</code>  <code>property</code>","text":"<p>Determine whether cellpose should apply its internal normalization.</p> <p>If type is set to <code>custom</code> or <code>no_normalization</code>, don't apply cellpose internal normalization</p>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_utils/#fractal_tasks_core.tasks.cellpose_utils.CellposeModelParams","title":"<code>CellposeModelParams</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Advanced Cellpose Model Parameters</p> ATTRIBUTE DESCRIPTION <code>cellprob_threshold</code> <p>Parameter of <code>CellposeModel.eval</code> method. Valid values between -6 to 6. From Cellpose documentation: \"Decrease this threshold if cellpose is not returning as many ROIs as you'd expect. Similarly, increase this threshold if cellpose is returning too ROIs particularly from dim areas.\"</p> <p> TYPE: <code>float</code> </p> <code>flow_threshold</code> <p>Parameter of <code>CellposeModel.eval</code> method. Valid values between 0.0 and 1.0. From Cellpose documentation: \"Increase this threshold if cellpose is not returning as many ROIs as you'd expect. Similarly, decrease this threshold if cellpose is returning too many ill-shaped ROIs.\"</p> <p> TYPE: <code>float</code> </p> <code>anisotropy</code> <p>Ratio of the pixel sizes along Z and XY axis (ignored if the image is not three-dimensional). If unset, it is inferred from the OME-NGFF metadata.</p> <p> TYPE: <code>Optional[float]</code> </p> <code>min_size</code> <p>Parameter of <code>CellposeModel</code> class. Minimum size of the segmented objects (in pixels). Use <code>-1</code> to turn off the size filter.</p> <p> TYPE: <code>int</code> </p> <code>augment</code> <p>Parameter of <code>CellposeModel</code> class. Whether to use cellpose augmentation to tile images with overlap.</p> <p> TYPE: <code>bool</code> </p> <code>net_avg</code> <p>Parameter of <code>CellposeModel</code> class. Whether to use cellpose net averaging to run the 4 built-in networks (useful for <code>nuclei</code>, <code>cyto</code> and <code>cyto2</code>, not sure it works for the others).</p> <p> TYPE: <code>bool</code> </p> <code>use_gpu</code> <p>If <code>False</code>, always use the CPU; if <code>True</code>, use the GPU if possible (as defined in <code>cellpose.core.use_gpu()</code>) and fall-back to the CPU otherwise.</p> <p> TYPE: <code>bool</code> </p> <code>batch_size</code> <p>number of 224x224 patches to run simultaneously on the GPU (can make smaller or bigger depending on GPU memory usage)</p> <p> TYPE: <code>int</code> </p> <code>invert</code> <p>invert image pixel intensity before running network (if True, image is also normalized)</p> <p> TYPE: <code>bool</code> </p> <code>tile</code> <p>tiles image to ensure GPU/CPU memory usage limited (recommended)</p> <p> TYPE: <code>bool</code> </p> <code>tile_overlap</code> <p>fraction of overlap of tiles when computing flows</p> <p> TYPE: <code>float</code> </p> <code>resample</code> <p>run dynamics at original image size (will be slower but create more accurate boundaries)</p> <p> TYPE: <code>bool</code> </p> <code>interp</code> <p>interpolate during 2D dynamics (not available in 3D) (in previous versions it was False, now it defaults to True)</p> <p> TYPE: <code>bool</code> </p> <code>stitch_threshold</code> <p>if stitch_threshold&gt;0.0 and not do_3D and equal image sizes, masks are stitched in 3D to return volume segmentation</p> <p> TYPE: <code>float</code> </p> Source code in <code>fractal_tasks_core/tasks/cellpose_utils.py</code> <pre><code>class CellposeModelParams(BaseModel):\n\"\"\"\n    Advanced Cellpose Model Parameters\n\n    Attributes:\n        cellprob_threshold: Parameter of `CellposeModel.eval` method. Valid\n            values between -6 to 6. From Cellpose documentation: \"Decrease this\n            threshold if cellpose is not returning as many ROIs as you'd\n            expect. Similarly, increase this threshold if cellpose is returning\n            too ROIs particularly from dim areas.\"\n        flow_threshold: Parameter of `CellposeModel.eval` method. Valid\n            values between 0.0 and 1.0. From Cellpose documentation: \"Increase\n            this threshold if cellpose is not returning as many ROIs as you'd\n            expect. Similarly, decrease this threshold if cellpose is returning\n            too many ill-shaped ROIs.\"\n        anisotropy: Ratio of the pixel sizes along Z and XY axis (ignored if\n            the image is not three-dimensional). If unset, it is inferred from\n            the OME-NGFF metadata.\n        min_size: Parameter of `CellposeModel` class. Minimum size of the\n            segmented objects (in pixels). Use `-1` to turn off the size\n            filter.\n        augment: Parameter of `CellposeModel` class. Whether to use cellpose\n            augmentation to tile images with overlap.\n        net_avg: Parameter of `CellposeModel` class. Whether to use cellpose\n            net averaging to run the 4 built-in networks (useful for `nuclei`,\n            `cyto` and `cyto2`, not sure it works for the others).\n        use_gpu: If `False`, always use the CPU; if `True`, use the GPU if\n            possible (as defined in `cellpose.core.use_gpu()`) and fall-back\n            to the CPU otherwise.\n        batch_size: number of 224x224 patches to run simultaneously on the GPU\n            (can make smaller or bigger depending on GPU memory usage)\n        invert: invert image pixel intensity before running network (if True,\n            image is also normalized)\n        tile: tiles image to ensure GPU/CPU memory usage limited (recommended)\n        tile_overlap: fraction of overlap of tiles when computing flows\n        resample: run dynamics at original image size (will be slower but\n            create more accurate boundaries)\n        interp: interpolate during 2D dynamics (not available in 3D)\n            (in previous versions it was False, now it defaults to True)\n        stitch_threshold: if stitch_threshold&gt;0.0 and not do_3D and equal\n            image sizes, masks are stitched in 3D to return volume segmentation\n    \"\"\"\n\n    cellprob_threshold: float = 0.0\n    flow_threshold: float = 0.4\n    anisotropy: Optional[float] = None\n    min_size: int = 15\n    augment: bool = False\n    net_avg: bool = False\n    use_gpu: bool = True\n    batch_size: int = 8\n    invert: bool = False\n    tile: bool = True\n    tile_overlap: float = 0.1\n    resample: bool = True\n    interp: bool = True\n    stitch_threshold: float = 0.0\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_utils/#fractal_tasks_core.tasks.cellpose_utils._normalize_cellpose_channels","title":"<code>_normalize_cellpose_channels(x, channels, normalize, normalize2)</code>","text":"<p>Normalize a cellpose input array by channel.</p> PARAMETER DESCRIPTION <code>x</code> <p>4D numpy array.</p> <p> TYPE: <code>ndarray</code> </p> <code>channels</code> <p>Which channels to use. If only one channel is provided, <code>[0, 0]</code> should be used. If two channels are provided (the first dimension of <code>x</code> has length of 2), <code>[1, 2]</code> should be used (<code>x[0, :, :,:]</code> contains the membrane channel and <code>x[1, :, :, :]</code> contains the nuclear channel).</p> <p> TYPE: <code>list[int]</code> </p> <code>normalize</code> <p>By default, data is normalized so 0.0=1st percentile and 1.0=99th percentile of image intensities in each channel. This automatic normalization can lead to issues when the image to be segmented is very sparse. You can turn off the default rescaling. With the \"custom\" option, you can either provide your own rescaling percentiles or fixed rescaling upper and lower bound integers.</p> <p> TYPE: <code>CellposeCustomNormalizer</code> </p> <code>normalize2</code> <p>Normalization options for channel 2. If one channel is normalized with default settings, both channels need to be normalized with default settings.</p> <p> TYPE: <code>CellposeCustomNormalizer</code> </p> Source code in <code>fractal_tasks_core/tasks/cellpose_utils.py</code> <pre><code>def _normalize_cellpose_channels(\n    x: np.ndarray,\n    channels: list[int],\n    normalize: CellposeCustomNormalizer,\n    normalize2: CellposeCustomNormalizer,\n) -&gt; np.ndarray:\n\"\"\"\n    Normalize a cellpose input array by channel.\n\n    Args:\n        x: 4D numpy array.\n        channels: Which channels to use. If only one channel is provided, `[0,\n            0]` should be used. If two channels are provided (the first\n            dimension of `x` has length of 2), `[1, 2]` should be used\n            (`x[0, :, :,:]` contains the membrane channel and\n            `x[1, :, :, :]` contains the nuclear channel).\n        normalize: By default, data is normalized so 0.0=1st percentile and\n            1.0=99th percentile of image intensities in each channel.\n            This automatic normalization can lead to issues when the image to\n            be segmented is very sparse. You can turn off the default\n            rescaling. With the \"custom\" option, you can either provide your\n            own rescaling percentiles or fixed rescaling upper and lower\n            bound integers.\n        normalize2: Normalization options for channel 2. If one channel is\n            normalized with default settings, both channels need to be\n            normalized with default settings.\n\n    \"\"\"\n    # Optionally perform custom normalization\n    # normalize channels separately, if normalize2 is provided:\n    if channels == [1, 2]:\n        # If run in single channel mode, fails (specified as channel = [0, 0])\n        if (normalize.type == \"default\") != (normalize2.type == \"default\"):\n            raise ValueError(\n                \"ERROR in normalization:\"\n                f\" {normalize.type=} and {normalize2.type=}.\"\n                \" Either both need to be 'default', or none of them.\"\n            )\n        if normalize.type == \"custom\":\n            x[channels[0] - 1 : channels[0]] = normalized_img(\n                x[channels[0] - 1 : channels[0]],\n                lower_p=normalize.lower_percentile,\n                upper_p=normalize.upper_percentile,\n                lower_bound=normalize.lower_bound,\n                upper_bound=normalize.upper_bound,\n            )\n        if normalize2.type == \"custom\":\n            x[channels[1] - 1 : channels[1]] = normalized_img(\n                x[channels[1] - 1 : channels[1]],\n                lower_p=normalize2.lower_percentile,\n                upper_p=normalize2.upper_percentile,\n                lower_bound=normalize2.lower_bound,\n                upper_bound=normalize2.upper_bound,\n            )\n\n    # otherwise, use first normalize to normalize all channels:\n    else:\n        if normalize.type == \"custom\":\n            x = normalized_img(\n                x,\n                lower_p=normalize.lower_percentile,\n                upper_p=normalize.upper_percentile,\n                lower_bound=normalize.lower_bound,\n                upper_bound=normalize.upper_bound,\n            )\n\n    return x\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_utils/#fractal_tasks_core.tasks.cellpose_utils.normalize_bounds","title":"<code>normalize_bounds(Y, lower=0, upper=65535)</code>","text":"<p>normalize image so 0.0 is lower value and 1.0 is upper value</p> PARAMETER DESCRIPTION <code>Y</code> <p>The image to be normalized</p> <p> TYPE: <code>ndarray</code> </p> <code>lower</code> <p>Lower normalization value</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>upper</code> <p>Upper normalization value</p> <p> TYPE: <code>int</code> DEFAULT: <code>65535</code> </p> Source code in <code>fractal_tasks_core/tasks/cellpose_utils.py</code> <pre><code>def normalize_bounds(Y: np.ndarray, lower: int = 0, upper: int = 65535):\n\"\"\"normalize image so 0.0 is lower value and 1.0 is upper value\n\n    Args:\n        Y: The image to be normalized\n        lower: Lower normalization value\n        upper: Upper normalization value\n\n    \"\"\"\n    X = Y.copy()\n    X = (X - lower) / (upper - lower)\n    return X\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_utils/#fractal_tasks_core.tasks.cellpose_utils.normalize_percentile","title":"<code>normalize_percentile(Y, lower=1, upper=99)</code>","text":"<p>normalize image so 0.0 is lower percentile and 1.0 is upper percentile Percentiles are passed as floats (must be between 0 and 100)</p> PARAMETER DESCRIPTION <code>Y</code> <p>The image to be normalized</p> <p> TYPE: <code>ndarray</code> </p> <code>lower</code> <p>Lower percentile</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> <code>upper</code> <p>Upper percentile</p> <p> TYPE: <code>float</code> DEFAULT: <code>99</code> </p> Source code in <code>fractal_tasks_core/tasks/cellpose_utils.py</code> <pre><code>def normalize_percentile(Y: np.ndarray, lower: float = 1, upper: float = 99):\n\"\"\"normalize image so 0.0 is lower percentile and 1.0 is upper percentile\n    Percentiles are passed as floats (must be between 0 and 100)\n\n    Args:\n        Y: The image to be normalized\n        lower: Lower percentile\n        upper: Upper percentile\n\n    \"\"\"\n    X = Y.copy()\n    x01 = np.percentile(X, lower)\n    x99 = np.percentile(X, upper)\n    X = (X - x01) / (x99 - x01)\n    return X\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_utils/#fractal_tasks_core.tasks.cellpose_utils.normalized_img","title":"<code>normalized_img(img, axis=-1, invert=False, lower_p=1.0, upper_p=99.0, lower_bound=None, upper_bound=None)</code>","text":"<p>normalize each channel of the image so that so that 0.0=lower percentile or lower bound and 1.0=upper percentile or upper bound of image intensities.</p> <p>The normalization can result in values &lt; 0 or &gt; 1 (no clipping).</p> <p>Based on https://github.com/MouseLand/cellpose/blob/4f5661983c3787efa443bbbd3f60256f4fd8bf53/cellpose/transforms.py#L375 # noqa E501</p> <p>optional inversion</p>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_utils/#fractal_tasks_core.tasks.cellpose_utils.normalized_img--parameters","title":"Parameters","text":"<p>img: ND-array (at least 3 dimensions)</p> <p>axis: channel axis to loop over for normalization</p> <p>invert: invert image (useful if cells are dark instead of bright)</p> <p>lower_p: Lower percentile for rescaling</p> <p>upper_p: Upper percentile for rescaling</p> <p>lower_bound: Lower fixed-value used for rescaling</p> <p>upper_bound: Upper fixed-value used for rescaling</p>"},{"location":"reference/fractal_tasks_core/tasks/cellpose_utils/#fractal_tasks_core.tasks.cellpose_utils.normalized_img--returns","title":"Returns","text":"ND-array, float32 <p>normalized image of same size</p> Source code in <code>fractal_tasks_core/tasks/cellpose_utils.py</code> <pre><code>def normalized_img(\n    img: np.ndarray,\n    axis: int = -1,\n    invert: bool = False,\n    lower_p: float = 1.0,\n    upper_p: float = 99.0,\n    lower_bound: Optional[int] = None,\n    upper_bound: Optional[int] = None,\n):\n\"\"\"normalize each channel of the image so that so that 0.0=lower percentile\n    or lower bound and 1.0=upper percentile or upper bound of image intensities.\n\n    The normalization can result in values &lt; 0 or &gt; 1 (no clipping).\n\n    Based on https://github.com/MouseLand/cellpose/blob/4f5661983c3787efa443bbbd3f60256f4fd8bf53/cellpose/transforms.py#L375 # noqa E501\n\n    optional inversion\n\n    Parameters\n    ------------\n\n    img: ND-array (at least 3 dimensions)\n\n    axis: channel axis to loop over for normalization\n\n    invert: invert image (useful if cells are dark instead of bright)\n\n    lower_p: Lower percentile for rescaling\n\n    upper_p: Upper percentile for rescaling\n\n    lower_bound: Lower fixed-value used for rescaling\n\n    upper_bound: Upper fixed-value used for rescaling\n\n    Returns\n    ---------------\n\n    img: ND-array, float32\n        normalized image of same size\n\n    \"\"\"\n    if img.ndim &lt; 3:\n        error_message = \"Image needs to have at least 3 dimensions\"\n        logger.critical(error_message)\n        raise ValueError(error_message)\n\n    img = img.astype(np.float32)\n    img = np.moveaxis(img, axis, 0)\n    for k in range(img.shape[0]):\n        if lower_p is not None:\n            # ptp can still give nan's with weird images\n            i99 = np.percentile(img[k], upper_p)\n            i1 = np.percentile(img[k], lower_p)\n            if i99 - i1 &gt; +1e-3:  # np.ptp(img[k]) &gt; 1e-3:\n                img[k] = normalize_percentile(\n                    img[k], lower=lower_p, upper=upper_p\n                )\n                if invert:\n                    img[k] = -1 * img[k] + 1\n            else:\n                img[k] = 0\n        elif lower_bound is not None:\n            if upper_bound - lower_bound &gt; +1e-3:\n                img[k] = normalize_bounds(\n                    img[k], lower=lower_bound, upper=upper_bound\n                )\n                if invert:\n                    img[k] = -1 * img[k] + 1\n            else:\n                img[k] = 0\n        else:\n            raise ValueError(\"No normalization method specified\")\n    img = np.moveaxis(img, 0, axis)\n    return img\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/cellvoyager_to_ome_zarr_compute/","title":"cellvoyager_to_ome_zarr_compute","text":"<p>Task that writes image data to an existing OME-NGFF zarr array.</p>"},{"location":"reference/fractal_tasks_core/tasks/cellvoyager_to_ome_zarr_compute/#fractal_tasks_core.tasks.cellvoyager_to_ome_zarr_compute.cellvoyager_to_ome_zarr_compute","title":"<code>cellvoyager_to_ome_zarr_compute(*, zarr_url, init_args, chunk_sizes=Field(default_factory=ChunkSizes))</code>","text":"<p>Convert Yokogawa output (png, tif) to zarr file.</p> <p>This task is run after an init task (typically <code>cellvoyager_to_ome_zarr_init</code> or <code>cellvoyager_to_ome_zarr_init_multiplex</code>), and it populates the empty OME-Zarr files that were prepared.</p> <p>Note that the current task always overwrites existing data. To avoid this behavior, set the <code>overwrite</code> argument of the init task to <code>False</code>.</p> PARAMETER DESCRIPTION <code>zarr_url</code> <p>Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>init_args</code> <p>Intialization arguments provided by <code>create_cellvoyager_ome_zarr_init</code>.</p> <p> TYPE: <code>InitArgsCellVoyager</code> </p> <code>chunk_sizes</code> <p>Used to overwrite the default chunk sizes for the OME-Zarr. By default, the task will chunk the same as the microscope field of view size, with 10 z planes per chunk. For example, that can mean c: 1, z: 10, y: 2160, x:2560</p> <p> TYPE: <code>ChunkSizes</code> DEFAULT: <code>Field(default_factory=ChunkSizes)</code> </p> Source code in <code>fractal_tasks_core/tasks/cellvoyager_to_ome_zarr_compute.py</code> <pre><code>@validate_call\ndef cellvoyager_to_ome_zarr_compute(\n    *,\n    # Fractal parameters\n    zarr_url: str,\n    init_args: InitArgsCellVoyager,\n    chunk_sizes: ChunkSizes = Field(default_factory=ChunkSizes),\n):\n\"\"\"\n    Convert Yokogawa output (png, tif) to zarr file.\n\n    This task is run after an init task (typically\n    `cellvoyager_to_ome_zarr_init` or\n    `cellvoyager_to_ome_zarr_init_multiplex`), and it populates the empty\n    OME-Zarr files that were prepared.\n\n    Note that the current task always overwrites existing data. To avoid this\n    behavior, set the `overwrite` argument of the init task to `False`.\n\n    Args:\n        zarr_url: Path or url to the individual OME-Zarr image to be processed.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        init_args: Intialization arguments provided by\n            `create_cellvoyager_ome_zarr_init`.\n        chunk_sizes: Used to overwrite the default chunk sizes for the\n            OME-Zarr. By default, the task will chunk the same as the\n            microscope field of view size, with 10 z planes per chunk.\n            For example, that can mean c: 1, z: 10, y: 2160, x:2560\n    \"\"\"\n    zarr_url = zarr_url.rstrip(\"/\")\n    # Read attributes from NGFF metadata\n    ngff_image_meta = load_NgffImageMeta(zarr_url)\n    num_levels = ngff_image_meta.num_levels\n    coarsening_xy = ngff_image_meta.coarsening_xy\n    full_res_pxl_sizes_zyx = ngff_image_meta.get_pixel_sizes_zyx(level=0)\n    logger.info(f\"NGFF image has {num_levels=}\")\n    logger.info(f\"NGFF image has {coarsening_xy=}\")\n    logger.info(\n        f\"NGFF image has full-res pixel sizes {full_res_pxl_sizes_zyx}\"\n    )\n\n    channels: list[OmeroChannel] = get_omero_channel_list(\n        image_zarr_path=zarr_url\n    )\n    wavelength_ids = [c.wavelength_id for c in channels]\n\n    # Read useful information from ROI table\n    adata = read_zarr(f\"{zarr_url}/tables/FOV_ROI_table\")\n    fov_indices = convert_ROI_table_to_indices(\n        adata,\n        full_res_pxl_sizes_zyx=full_res_pxl_sizes_zyx,\n    )\n    check_valid_ROI_indices(fov_indices, \"FOV_ROI_table\")\n    adata_well = read_zarr(f\"{zarr_url}/tables/well_ROI_table\")\n    well_indices = convert_ROI_table_to_indices(\n        adata_well,\n        full_res_pxl_sizes_zyx=full_res_pxl_sizes_zyx,\n    )\n    check_valid_ROI_indices(well_indices, \"well_ROI_table\")\n    if len(well_indices) &gt; 1:\n        raise ValueError(f\"Something wrong with {well_indices=}\")\n\n    max_z = well_indices[0][1]\n    max_y = well_indices[0][3]\n    max_x = well_indices[0][5]\n\n    # Load a single image, to retrieve useful information\n    include_patterns = [\n        f\"{init_args.plate_prefix}_{init_args.well_ID}_*.\"\n        f\"{init_args.image_extension}\"\n    ]\n    if init_args.include_glob_patterns:\n        include_patterns.extend(init_args.include_glob_patterns)\n\n    exclude_patterns = []\n    if init_args.exclude_glob_patterns:\n        exclude_patterns.extend(init_args.exclude_glob_patterns)\n\n    tmp_images = glob_with_multiple_patterns(\n        folder=init_args.image_dir,\n        include_patterns=include_patterns,\n        exclude_patterns=exclude_patterns,\n    )\n    sample = imread(tmp_images.pop())\n\n    # Initialize zarr\n    chunksize_default = {\n        \"c\": 1,\n        \"z\": 10,\n        \"y\": sample.shape[1],\n        \"x\": sample.shape[2],\n    }\n    chunksize = chunk_sizes.get_chunksize(chunksize_default=chunksize_default)\n    # chunksize[\"z\"] =\n    canvas_zarr = zarr.create(\n        shape=(len(wavelength_ids), max_z, max_y, max_x),\n        chunks=chunksize,\n        dtype=sample.dtype,\n        store=zarr.storage.FSStore(zarr_url + \"/0\"),\n        overwrite=True,\n        dimension_separator=\"/\",\n    )\n\n    # Loop over channels\n    for i_c, wavelength_id in enumerate(wavelength_ids):\n        A, C = wavelength_id.split(\"_\")\n\n        include_patterns = [\n            f\"{init_args.plate_prefix}_{init_args.well_ID}_*{A}*{C}*.\"\n            f\"{init_args.image_extension}\"\n        ]\n        if init_args.include_glob_patterns:\n            include_patterns.extend(init_args.include_glob_patterns)\n        filenames_set = glob_with_multiple_patterns(\n            folder=init_args.image_dir,\n            include_patterns=include_patterns,\n            exclude_patterns=exclude_patterns,\n        )\n        filenames = sorted(list(filenames_set), key=sort_fun)\n        if len(filenames) == 0:\n            raise ValueError(\n                \"Error in yokogawa_to_ome_zarr: len(filenames)=0.\\n\"\n                f\"  image_dir: {init_args.image_dir}\\n\"\n                f\"  wavelength_id: {wavelength_id},\\n\"\n                f\"  patterns: {include_patterns}\\n\"\n                f\"  exclusion patterns: {exclude_patterns}\\n\"\n            )\n        # Loop over 3D FOV ROIs\n        for indices in fov_indices:\n            s_z, e_z, s_y, e_y, s_x, e_x = indices[:]\n            region = (\n                slice(i_c, i_c + 1),\n                slice(s_z, e_z),\n                slice(s_y, e_y),\n                slice(s_x, e_x),\n            )\n            FOV_3D = da.concatenate(\n                [imread(img) for img in filenames[:e_z]],\n            )\n            FOV_4D = da.expand_dims(FOV_3D, axis=0)\n            filenames = filenames[e_z:]\n            da.array(FOV_4D).to_zarr(\n                url=canvas_zarr,\n                region=region,\n                compute=True,\n            )\n\n    # Starting from on-disk highest-resolution data, build and write to disk a\n    # pyramid of coarser levels\n    build_pyramid(\n        zarrurl=zarr_url,\n        overwrite=True,\n        num_levels=num_levels,\n        coarsening_xy=coarsening_xy,\n        chunksize=chunksize,\n    )\n\n    # Generate image list updates\n    # TODO: Can we check for dimensionality more robustly? Just checks for the\n    # last FOV of the last wavelength now\n    if FOV_4D.shape[-3] &gt; 1:\n        is_3D = True\n    else:\n        is_3D = False\n    # FIXME: Get plate name from zarr_url =&gt; works for duplicate plate names\n    # with suffixes\n    print(zarr_url)\n    plate_name = zarr_url.split(\"/\")[-4]\n    attributes = {\n        \"plate\": plate_name,\n        \"well\": init_args.well_ID,\n    }\n    if init_args.acquisition is not None:\n        attributes[\"acquisition\"] = init_args.acquisition\n\n    image_list_updates = dict(\n        image_list_updates=[\n            dict(\n                zarr_url=zarr_url,\n                attributes=attributes,\n                types={\"is_3D\": is_3D},\n            )\n        ]\n    )\n\n    return image_list_updates\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/cellvoyager_to_ome_zarr_compute/#fractal_tasks_core.tasks.cellvoyager_to_ome_zarr_compute.sort_fun","title":"<code>sort_fun(filename)</code>","text":"<p>Takes a string (filename of a Yokogawa image), extract site and z-index metadata and returns them as a list of integers.</p> PARAMETER DESCRIPTION <code>filename</code> <p>Name of the image file.</p> <p> TYPE: <code>str</code> </p> Source code in <code>fractal_tasks_core/tasks/cellvoyager_to_ome_zarr_compute.py</code> <pre><code>def sort_fun(filename: str) -&gt; list[int]:\n\"\"\"\n    Takes a string (filename of a Yokogawa image), extract site and\n    z-index metadata and returns them as a list of integers.\n\n    Args:\n        filename: Name of the image file.\n    \"\"\"\n\n    filename_metadata = parse_filename(filename)\n    site = int(filename_metadata[\"F\"])\n    z_index = int(filename_metadata[\"Z\"])\n    return [site, z_index]\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/cellvoyager_to_ome_zarr_init/","title":"cellvoyager_to_ome_zarr_init","text":"<p>Create structure for OME-NGFF zarr array.</p>"},{"location":"reference/fractal_tasks_core/tasks/cellvoyager_to_ome_zarr_init/#fractal_tasks_core.tasks.cellvoyager_to_ome_zarr_init.cellvoyager_to_ome_zarr_init","title":"<code>cellvoyager_to_ome_zarr_init(*, zarr_dir, image_dirs, allowed_channels, include_glob_patterns=None, exclude_glob_patterns=None, num_levels=5, coarsening_xy=2, image_extension='tif', metadata_table_file=None, overwrite=False)</code>","text":"<p>Create a OME-NGFF zarr folder, without reading/writing image data.</p> <p>Find plates (for each folder in input_paths):</p> <ul> <li>glob image files,</li> <li>parse metadata from image filename to identify plates,</li> <li>identify populated channels.</li> </ul> <p>Create a zarr folder (for each plate):</p> <ul> <li>parse mlf metadata,</li> <li>identify wells and field of view (FOV),</li> <li>create FOV ZARR,</li> <li>verify that channels are uniform (i.e., same channels).</li> </ul> PARAMETER DESCRIPTION <code>zarr_dir</code> <p>path of the directory where the new OME-Zarrs will be created. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>image_dirs</code> <p>list of paths to the folders that contains the Cellvoyager image files. Each entry is a path to a folder that contains the image files themselves for a multiwell plate and the MeasurementData &amp; MeasurementDetail metadata files.</p> <p> TYPE: <code>list[str]</code> </p> <code>allowed_channels</code> <p>A list of <code>OmeroChannel</code> s, where each channel must include the <code>wavelength_id</code> attribute and where the <code>wavelength_id</code> values must be unique across the list.</p> <p> TYPE: <code>list[OmeroChannel]</code> </p> <code>include_glob_patterns</code> <p>If specified, only parse images with filenames that match with all these patterns. Patterns must be defined as in https://docs.python.org/3/library/fnmatch.html, Example: <code>image_glob_pattern=[\"*_B03_*\"]</code> =&gt; only process well B03 <code>image_glob_pattern=[\"*_C09_*\", \"*F016*\", \"*Z[0-5][0-9]C*\"]</code> =&gt; only process well C09, field of view 16 and Z planes 0-59. Can interact with exclude_glob_patterns: All included images - all excluded images gives the final list of images to process</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> <code>exclude_glob_patterns</code> <p>If specified, exclude any image where the filename matches any of the exclusion patterns. Patterns are specified the same as for include_glob_patterns.</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> <code>num_levels</code> <p>Number of resolution-pyramid levels. If set to <code>5</code>, there will be the full-resolution level and 4 levels of downsampled images.</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> <code>coarsening_xy</code> <p>Linear coarsening factor between subsequent levels. If set to <code>2</code>, level 1 is 2x downsampled, level 2 is 4x downsampled etc.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>image_extension</code> <p>Filename extension of images (e.g. <code>\"tif\"</code> or <code>\"png\"</code>)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'tif'</code> </p> <code>metadata_table_file</code> <p>If <code>None</code>, parse Yokogawa metadata from mrf/mlf files in the input_path folder; else, the full path to a csv file containing the parsed metadata table.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>overwrite</code> <p>If <code>True</code>, overwrite the task output.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>A metadata dictionary containing important metadata about the OME-Zarr plate, the images and some parameters required by downstream tasks (like <code>num_levels</code>).</p> Source code in <code>fractal_tasks_core/tasks/cellvoyager_to_ome_zarr_init.py</code> <pre><code>@validate_call\ndef cellvoyager_to_ome_zarr_init(\n    *,\n    # Fractal parameters\n    zarr_dir: str,\n    # Core parameters\n    image_dirs: list[str],\n    allowed_channels: list[OmeroChannel],\n    # Advanced parameters\n    include_glob_patterns: Optional[list[str]] = None,\n    exclude_glob_patterns: Optional[list[str]] = None,\n    num_levels: int = 5,\n    coarsening_xy: int = 2,\n    image_extension: str = \"tif\",\n    metadata_table_file: Optional[str] = None,\n    overwrite: bool = False,\n) -&gt; dict[str, Any]:\n\"\"\"\n    Create a OME-NGFF zarr folder, without reading/writing image data.\n\n    Find plates (for each folder in input_paths):\n\n    - glob image files,\n    - parse metadata from image filename to identify plates,\n    - identify populated channels.\n\n    Create a zarr folder (for each plate):\n\n    - parse mlf metadata,\n    - identify wells and field of view (FOV),\n    - create FOV ZARR,\n    - verify that channels are uniform (i.e., same channels).\n\n    Args:\n        zarr_dir: path of the directory where the new OME-Zarrs will be\n            created.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        image_dirs: list of paths to the folders that contains the Cellvoyager\n            image files. Each entry is a path to a folder that contains the\n            image files themselves for a multiwell plate and the\n            MeasurementData &amp; MeasurementDetail metadata files.\n        allowed_channels: A list of `OmeroChannel` s, where each channel must\n            include the `wavelength_id` attribute and where the\n            `wavelength_id` values must be unique across the list.\n        include_glob_patterns: If specified, only parse images with filenames\n            that match with all these patterns. Patterns must be defined as in\n            https://docs.python.org/3/library/fnmatch.html, Example:\n            `image_glob_pattern=[\"*_B03_*\"]` =&gt; only process well B03\n            `image_glob_pattern=[\"*_C09_*\", \"*F016*\", \"*Z[0-5][0-9]C*\"]` =&gt;\n            only process well C09, field of view 16 and Z planes 0-59.\n            Can interact with exclude_glob_patterns: All included images - all\n            excluded images gives the final list of images to process\n        exclude_glob_patterns: If specified, exclude any image where the\n            filename matches any of the exclusion patterns. Patterns are\n            specified the same as for include_glob_patterns.\n        num_levels: Number of resolution-pyramid levels. If set to `5`, there\n            will be the full-resolution level and 4 levels of\n            downsampled images.\n        coarsening_xy: Linear coarsening factor between subsequent levels.\n            If set to `2`, level 1 is 2x downsampled, level 2 is\n            4x downsampled etc.\n        image_extension: Filename extension of images (e.g. `\"tif\"` or `\"png\"`)\n        metadata_table_file: If `None`, parse Yokogawa metadata from mrf/mlf\n            files in the input_path folder; else, the full path to a csv file\n            containing the parsed metadata table.\n        overwrite: If `True`, overwrite the task output.\n\n    Returns:\n        A metadata dictionary containing important metadata about the OME-Zarr\n            plate, the images and some parameters required by downstream tasks\n            (like `num_levels`).\n    \"\"\"\n\n    # Preliminary checks on metadata_table_file\n    if metadata_table_file:\n        if not metadata_table_file.endswith(\".csv\"):\n            raise ValueError(f\"{metadata_table_file=} is not a csv file\")\n        if not os.path.isfile(metadata_table_file):\n            raise FileNotFoundError(f\"{metadata_table_file=} does not exist\")\n\n    # Identify all plates and all channels, across all input folders\n    plates = []\n    actual_wavelength_ids = None\n    dict_plate_paths = {}\n    dict_plate_prefixes: dict[str, Any] = {}\n\n    # Preliminary checks on allowed_channels argument\n    check_unique_wavelength_ids(allowed_channels)\n\n    for image_dir in image_dirs:\n        # Glob image filenames\n        include_patterns = [f\"*.{image_extension}\"]\n        exclude_patterns = []\n        if include_glob_patterns:\n            include_patterns.extend(include_glob_patterns)\n        if exclude_glob_patterns:\n            exclude_patterns.extend(exclude_glob_patterns)\n        input_filenames = glob_with_multiple_patterns(\n            folder=image_dir,\n            include_patterns=include_patterns,\n            exclude_patterns=exclude_patterns,\n        )\n\n        tmp_wavelength_ids = []\n        tmp_plates = []\n        for fn in input_filenames:\n            try:\n                filename_metadata = parse_filename(Path(fn).name)\n                plate_prefix = filename_metadata[\"plate_prefix\"]\n                plate = filename_metadata[\"plate\"]\n                if plate not in dict_plate_prefixes.keys():\n                    dict_plate_prefixes[plate] = plate_prefix\n                tmp_plates.append(plate)\n                A = filename_metadata[\"A\"]\n                C = filename_metadata[\"C\"]\n                tmp_wavelength_ids.append(f\"A{A}_C{C}\")\n            except ValueError as e:\n                logger.warning(\n                    f'Skipping \"{Path(fn).name}\". Original error: ' + str(e)\n                )\n        tmp_plates = sorted(list(set(tmp_plates)))\n        tmp_wavelength_ids = sorted(list(set(tmp_wavelength_ids)))\n\n        info = (\n            \"Listing plates/channels:\\n\"\n            f\"Folder:   {image_dir}\\n\"\n            f\"Include Patterns: {include_patterns}\\n\"\n            f\"Exclude Patterns: {exclude_patterns}\\n\"\n            f\"Plates:   {tmp_plates}\\n\"\n            f\"Channels: {tmp_wavelength_ids}\\n\"\n        )\n\n        # Check that only one plate is found\n        if len(tmp_plates) &gt; 1:\n            raise ValueError(f\"{info}ERROR: {len(tmp_plates)} plates detected\")\n        elif len(tmp_plates) == 0:\n            raise ValueError(f\"{info}ERROR: No plates detected\")\n        plate = tmp_plates[0]\n\n        # If plate already exists in other folder, add suffix\n        if plate in plates:\n            ind = 1\n            new_plate = f\"{plate}_{ind}\"\n            while new_plate in plates:\n                new_plate = f\"{plate}_{ind}\"\n                ind += 1\n            logger.info(\n                f\"WARNING: {plate} already exists, renaming it as {new_plate}\"\n            )\n            plates.append(new_plate)\n            dict_plate_prefixes[new_plate] = dict_plate_prefixes[plate]\n            plate = new_plate\n        else:\n            plates.append(plate)\n\n        # Check that channels are the same as in previous plates\n        if actual_wavelength_ids is None:\n            actual_wavelength_ids = tmp_wavelength_ids[:]\n        else:\n            if actual_wavelength_ids != tmp_wavelength_ids:\n                raise ValueError(\n                    f\"ERROR\\n{info}\\nERROR:\"\n                    f\" expected channels {actual_wavelength_ids}\"\n                )\n\n        # Update dict_plate_paths\n        dict_plate_paths[plate] = image_dir\n\n    # Check that all channels are in the allowed_channels\n    allowed_wavelength_ids = [\n        channel.wavelength_id for channel in allowed_channels\n    ]\n    if not set(actual_wavelength_ids).issubset(set(allowed_wavelength_ids)):\n        msg = \"ERROR in create_ome_zarr\\n\"\n        msg += f\"actual_wavelength_ids: {actual_wavelength_ids}\\n\"\n        msg += f\"allowed_wavelength_ids: {allowed_wavelength_ids}\\n\"\n        raise ValueError(msg)\n\n    # Create actual_channels, i.e. a list of the channel dictionaries which are\n    # present\n    actual_channels = [\n        channel\n        for channel in allowed_channels\n        if channel.wavelength_id in actual_wavelength_ids\n    ]\n\n    ################################################################\n    # Create well/image OME-Zarr folders on disk, and prepare output\n    # metadata\n    parallelization_list = []\n\n    for plate in plates:\n        plate_name = sanitize_string(plate)\n        # Define plate zarr\n        relative_zarrurl = f\"{plate_name}.zarr\"\n        in_path = dict_plate_paths[plate]\n        logger.info(f\"Creating {relative_zarrurl}\")\n        # Call zarr.open_group wrapper, which handles overwrite=True/False\n        group_plate = open_zarr_group_with_overwrite(\n            str(Path(zarr_dir) / relative_zarrurl),\n            overwrite=overwrite,\n        )\n\n        # Obtain FOV-metadata dataframe\n        if metadata_table_file is None:\n            mrf_path = f\"{in_path}/MeasurementDetail.mrf\"\n            mlf_path = f\"{in_path}/MeasurementData.mlf\"\n\n            site_metadata, number_images_mlf = parse_yokogawa_metadata(\n                mrf_path,\n                mlf_path,\n                include_patterns=include_glob_patterns,\n                exclude_patterns=exclude_glob_patterns,\n            )\n            site_metadata = remove_FOV_overlaps(site_metadata)\n\n        # If a metadata table was passed, load it and use it directly\n        else:\n            logger.warning(\n                \"Since a custom metadata table was provided, there will \"\n                \"be no additional check on the number of image files.\"\n            )\n            site_metadata = pd.read_csv(metadata_table_file)\n            site_metadata.set_index([\"well_id\", \"FieldIndex\"], inplace=True)\n\n        # Extract pixel sizes and bit_depth\n        pixel_size_z = site_metadata[\"pixel_size_z\"].iloc[0]\n        pixel_size_y = site_metadata[\"pixel_size_y\"].iloc[0]\n        pixel_size_x = site_metadata[\"pixel_size_x\"].iloc[0]\n        bit_depth = site_metadata[\"bit_depth\"].iloc[0]\n\n        if min(pixel_size_z, pixel_size_y, pixel_size_x) &lt; 1e-9:\n            raise ValueError(pixel_size_z, pixel_size_y, pixel_size_x)\n\n        # Identify all wells\n        plate_prefix = dict_plate_prefixes[plate]\n\n        include_patterns = [f\"{plate_prefix}_*.{image_extension}\"]\n        if include_glob_patterns:\n            include_patterns.extend(include_glob_patterns)\n        plate_images = glob_with_multiple_patterns(\n            folder=str(in_path),\n            include_patterns=include_patterns,\n            exclude_patterns=exclude_patterns,\n        )\n\n        wells = [\n            parse_filename(os.path.basename(fn))[\"well\"] for fn in plate_images\n        ]\n        wells = sorted(list(set(wells)))\n\n        # Verify that all wells have all channels\n        for well in wells:\n            include_patterns = [f\"{plate_prefix}_{well}_*.{image_extension}\"]\n            if include_glob_patterns:\n                include_patterns.extend(include_glob_patterns)\n            well_images = glob_with_multiple_patterns(\n                folder=str(in_path),\n                include_patterns=include_patterns,\n                exclude_patterns=exclude_patterns,\n            )\n\n            # Check number of images matches with expected one\n            if metadata_table_file is None:\n                num_images_glob = len(well_images)\n                num_images_expected = number_images_mlf[well]\n                if num_images_glob != num_images_expected:\n                    raise ValueError(\n                        f\"Wrong number of images for {well=}\\n\"\n                        f\"Expected {num_images_expected} (from mlf file)\\n\"\n                        f\"Found {num_images_glob} files\\n\"\n                        \"Other parameters:\\n\"\n                        f\"  {image_extension=}\\n\"\n                        f\"  {include_glob_patterns=}\\n\"\n                        f\"  {exclude_glob_patterns=}\\n\"\n                    )\n\n            well_wavelength_ids = []\n            for fpath in well_images:\n                try:\n                    filename_metadata = parse_filename(os.path.basename(fpath))\n                    well_wavelength_ids.append(\n                        f\"A{filename_metadata['A']}_C{filename_metadata['C']}\"\n                    )\n                except IndexError:\n                    logger.info(f\"Skipping {fpath}\")\n            well_wavelength_ids = sorted(list(set(well_wavelength_ids)))\n            if well_wavelength_ids != actual_wavelength_ids:\n                raise ValueError(\n                    f\"ERROR: well {well} in plate {plate_name} (prefix: \"\n                    f\"{plate_prefix}) has missing channels.\\n\"\n                    f\"Expected: {actual_channels}\\n\"\n                    f\"Found: {well_wavelength_ids}.\\n\"\n                )\n\n        well_rows_columns = generate_row_col_split(wells)\n\n        row_list = [\n            well_row_column[0] for well_row_column in well_rows_columns\n        ]\n        col_list = [\n            well_row_column[1] for well_row_column in well_rows_columns\n        ]\n        row_list = sorted(list(set(row_list)))\n        col_list = sorted(list(set(col_list)))\n\n        plate_attrs = {\n            \"acquisitions\": [{\"id\": 0, \"name\": plate_name}],\n            \"columns\": [{\"name\": col} for col in col_list],\n            \"rows\": [{\"name\": row} for row in row_list],\n            \"version\": __OME_NGFF_VERSION__,\n            \"wells\": [\n                {\n                    \"path\": well_row_column[0] + \"/\" + well_row_column[1],\n                    \"rowIndex\": row_list.index(well_row_column[0]),\n                    \"columnIndex\": col_list.index(well_row_column[1]),\n                }\n                for well_row_column in well_rows_columns\n            ],\n        }\n\n        # Validate plate attrs:\n        Plate(**plate_attrs)\n\n        group_plate.attrs[\"plate\"] = plate_attrs\n\n        for row, column in well_rows_columns:\n            parallelization_list.append(\n                {\n                    \"zarr_url\": (\n                        f\"{zarr_dir}/{plate_name}.zarr/{row}/{column}/0\"\n                    ),\n                    \"init_args\": InitArgsCellVoyager(\n                        image_dir=in_path,\n                        plate_prefix=plate_prefix,\n                        well_ID=get_filename_well_id(row, column),\n                        image_extension=image_extension,\n                        include_glob_patterns=include_glob_patterns,\n                        exclude_glob_patterns=exclude_glob_patterns,\n                    ).model_dump(),\n                }\n            )\n            group_well = group_plate.create_group(f\"{row}/{column}/\")\n\n            well_attrs = {\n                \"images\": [{\"path\": \"0\"}],\n                \"version\": __OME_NGFF_VERSION__,\n            }\n\n            # Validate well attrs:\n            Well(**well_attrs)\n            group_well.attrs[\"well\"] = well_attrs\n\n            group_image = group_well.create_group(\"0\")  # noqa: F841\n            group_image.attrs[\"multiscales\"] = [\n                {\n                    \"version\": __OME_NGFF_VERSION__,\n                    \"axes\": [\n                        {\"name\": \"c\", \"type\": \"channel\"},\n                        {\n                            \"name\": \"z\",\n                            \"type\": \"space\",\n                            \"unit\": \"micrometer\",\n                        },\n                        {\n                            \"name\": \"y\",\n                            \"type\": \"space\",\n                            \"unit\": \"micrometer\",\n                        },\n                        {\n                            \"name\": \"x\",\n                            \"type\": \"space\",\n                            \"unit\": \"micrometer\",\n                        },\n                    ],\n                    \"datasets\": [\n                        {\n                            \"path\": f\"{ind_level}\",\n                            \"coordinateTransformations\": [\n                                {\n                                    \"type\": \"scale\",\n                                    \"scale\": [\n                                        1,\n                                        pixel_size_z,\n                                        pixel_size_y\n                                        * coarsening_xy**ind_level,\n                                        pixel_size_x\n                                        * coarsening_xy**ind_level,\n                                    ],\n                                }\n                            ],\n                        }\n                        for ind_level in range(num_levels)\n                    ],\n                }\n            ]\n\n            group_image.attrs[\"omero\"] = {\n                \"id\": 1,  # TODO does this depend on the plate number?\n                \"name\": \"TBD\",\n                \"version\": __OME_NGFF_VERSION__,\n                \"channels\": define_omero_channels(\n                    channels=actual_channels, bit_depth=bit_depth\n                ),\n            }\n\n            # Validate Image attrs\n            NgffImageMeta(**group_image.attrs)\n\n            # Prepare AnnData tables for FOV/well ROIs\n            well_id = get_filename_well_id(row, column)\n            FOV_ROIs_table = prepare_FOV_ROI_table(site_metadata.loc[well_id])\n            well_ROIs_table = prepare_well_ROI_table(\n                site_metadata.loc[well_id]\n            )\n\n            # Write AnnData tables into the `tables` zarr group\n            write_table(\n                group_image,\n                \"FOV_ROI_table\",\n                FOV_ROIs_table,\n                overwrite=overwrite,\n                table_attrs={\"type\": \"roi_table\"},\n            )\n            write_table(\n                group_image,\n                \"well_ROI_table\",\n                well_ROIs_table,\n                overwrite=overwrite,\n                table_attrs={\"type\": \"roi_table\"},\n            )\n\n    return dict(parallelization_list=parallelization_list)\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/cellvoyager_to_ome_zarr_init_multiplex/","title":"cellvoyager_to_ome_zarr_init_multiplex","text":"<p>Create OME-NGFF zarr group, for multiplexing dataset.</p>"},{"location":"reference/fractal_tasks_core/tasks/cellvoyager_to_ome_zarr_init_multiplex/#fractal_tasks_core.tasks.cellvoyager_to_ome_zarr_init_multiplex.cellvoyager_to_ome_zarr_init_multiplex","title":"<code>cellvoyager_to_ome_zarr_init_multiplex(*, zarr_dir, acquisitions, include_glob_patterns=None, exclude_glob_patterns=None, num_levels=5, coarsening_xy=2, image_extension='tif', metadata_table_files=None, overwrite=False)</code>","text":"<p>Create OME-NGFF structure and metadata to host a multiplexing dataset.</p> <p>This task takes a set of image folders (i.e. different multiplexing acquisitions) and build the internal structure and metadata of a OME-NGFF zarr group, without actually loading/writing the image data.</p> <p>Each element in input_paths should be treated as a different acquisition.</p> PARAMETER DESCRIPTION <code>zarr_dir</code> <p>path of the directory where the new OME-Zarrs will be created. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>acquisitions</code> <p>dictionary of acquisitions. Each key is the acquisition identifier (normally 0, 1, 2, 3 etc.). Each item defines the acquisition by providing the image_dir and the allowed_channels.</p> <p> TYPE: <code>dict[str, MultiplexingAcquisition]</code> </p> <code>include_glob_patterns</code> <p>If specified, only parse images with filenames that match with all these patterns. Patterns must be defined as in https://docs.python.org/3/library/fnmatch.html, Example: <code>image_glob_pattern=[\"*_B03_*\"]</code> =&gt; only process well B03 <code>image_glob_pattern=[\"*_C09_*\", \"*F016*\", \"*Z[0-5][0-9]C*\"]</code> =&gt; only process well C09, field of view 16 and Z planes 0-59. Can interact with exclude_glob_patterns: All included images - all excluded images gives the final list of images to process</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> <code>exclude_glob_patterns</code> <p>If specified, exclude any image where the filename matches any of the exclusion patterns. Patterns are specified the same as for include_glob_patterns.</p> <p> TYPE: <code>Optional[list[str]]</code> DEFAULT: <code>None</code> </p> <code>num_levels</code> <p>Number of resolution-pyramid levels. If set to <code>5</code>, there will be the full-resolution level and 4 levels of downsampled images.</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> <code>coarsening_xy</code> <p>Linear coarsening factor between subsequent levels. If set to <code>2</code>, level 1 is 2x downsampled, level 2 is 4x downsampled etc.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>image_extension</code> <p>Filename extension of images (e.g. <code>\"tif\"</code> or <code>\"png\"</code>).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'tif'</code> </p> <code>metadata_table_files</code> <p>If <code>None</code>, parse Yokogawa metadata from mrf/mlf files in the input_path folder; else, a dictionary of key-value pairs like <code>(acquisition, path)</code> with <code>acquisition</code> a string like the key of the <code>acquisitions</code> dict and <code>path</code> pointing to a csv file containing the parsed metadata table.</p> <p> TYPE: <code>Optional[dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>overwrite</code> <p>If <code>True</code>, overwrite the task output.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>A metadata dictionary containing important metadata about the OME-Zarr plate, the images and some parameters required by downstream tasks (like <code>num_levels</code>).</p> Source code in <code>fractal_tasks_core/tasks/cellvoyager_to_ome_zarr_init_multiplex.py</code> <pre><code>@validate_call\ndef cellvoyager_to_ome_zarr_init_multiplex(\n    *,\n    # Fractal parameters\n    zarr_dir: str,\n    # Core parameters\n    acquisitions: dict[str, MultiplexingAcquisition],\n    # Advanced parameters\n    include_glob_patterns: Optional[list[str]] = None,\n    exclude_glob_patterns: Optional[list[str]] = None,\n    num_levels: int = 5,\n    coarsening_xy: int = 2,\n    image_extension: str = \"tif\",\n    metadata_table_files: Optional[dict[str, str]] = None,\n    overwrite: bool = False,\n) -&gt; dict[str, Any]:\n\"\"\"\n    Create OME-NGFF structure and metadata to host a multiplexing dataset.\n\n    This task takes a set of image folders (i.e. different multiplexing\n    acquisitions) and build the internal structure and metadata of a OME-NGFF\n    zarr group, without actually loading/writing the image data.\n\n    Each element in input_paths should be treated as a different acquisition.\n\n    Args:\n        zarr_dir: path of the directory where the new OME-Zarrs will be\n            created.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        acquisitions: dictionary of acquisitions. Each key is the acquisition\n            identifier (normally 0, 1, 2, 3 etc.). Each item defines the\n            acquisition by providing the image_dir and the allowed_channels.\n        include_glob_patterns: If specified, only parse images with filenames\n            that match with all these patterns. Patterns must be defined as in\n            https://docs.python.org/3/library/fnmatch.html, Example:\n            `image_glob_pattern=[\"*_B03_*\"]` =&gt; only process well B03\n            `image_glob_pattern=[\"*_C09_*\", \"*F016*\", \"*Z[0-5][0-9]C*\"]` =&gt;\n            only process well C09, field of view 16 and Z planes 0-59.\n            Can interact with exclude_glob_patterns: All included images - all\n            excluded images gives the final list of images to process\n        exclude_glob_patterns: If specified, exclude any image where the\n            filename matches any of the exclusion patterns. Patterns are\n            specified the same as for include_glob_patterns.\n        num_levels: Number of resolution-pyramid levels. If set to `5`, there\n            will be the full-resolution level and 4 levels of downsampled\n            images.\n        coarsening_xy: Linear coarsening factor between subsequent levels.\n            If set to `2`, level 1 is 2x downsampled, level 2 is 4x downsampled\n            etc.\n        image_extension: Filename extension of images\n            (e.g. `\"tif\"` or `\"png\"`).\n        metadata_table_files: If `None`, parse Yokogawa metadata from mrf/mlf\n            files in the input_path folder; else, a dictionary of key-value\n            pairs like `(acquisition, path)` with `acquisition` a string like\n            the key of the `acquisitions` dict and `path` pointing to a csv\n            file containing the parsed metadata table.\n        overwrite: If `True`, overwrite the task output.\n\n    Returns:\n        A metadata dictionary containing important metadata about the OME-Zarr\n            plate, the images and some parameters required by downstream tasks\n            (like `num_levels`).\n    \"\"\"\n\n    if metadata_table_files:\n        # Checks on the dict:\n        # 1. Acquisitions in acquisitions dict and metadata_table_files match\n        # 2. Files end with \".csv\"\n        # 3. Files exist.\n        if set(acquisitions.keys()) != set(metadata_table_files.keys()):\n            raise ValueError(\n                \"Mismatch in acquisition keys between \"\n                f\"{acquisitions.keys()=} and \"\n                f\"{metadata_table_files.keys()=}\"\n            )\n        for f in metadata_table_files.values():\n            if not f.endswith(\".csv\"):\n                raise ValueError(\n                    f\"{f} (in metadata_table_file) is not a csv file.\"\n                )\n            if not os.path.isfile(f):\n                raise ValueError(\n                    f\"{f} (in metadata_table_file) does not exist.\"\n                )\n\n    # Preliminary checks on acquisitions\n    # Note that in metadata the keys of dictionary arguments should be\n    # strings (and not integers), so that they can be read from a JSON file\n    for key, values in acquisitions.items():\n        if not isinstance(key, str):\n            raise ValueError(f\"{acquisitions=} has non-string keys\")\n        check_unique_wavelength_ids(values.allowed_channels)\n        try:\n            int(key)\n        except ValueError:\n            raise ValueError(\"Acquisition dictionary keys need to be integers\")\n\n    # Identify all plates and all channels, per input folders\n    dict_acquisitions: dict = {}\n    acquisitions_sorted = sorted(acquisitions.keys(), key=lambda x: int(x))\n    for acquisition in acquisitions_sorted:\n        acq_input = acquisitions[acquisition]\n        dict_acquisitions[acquisition] = {}\n\n        actual_wavelength_ids = []\n        plates = []\n        plate_prefixes = []\n\n        # Loop over all images\n        include_patterns = [f\"*.{image_extension}\"]\n        exclude_patterns = []\n        if include_glob_patterns:\n            include_patterns.extend(include_glob_patterns)\n        if exclude_glob_patterns:\n            exclude_patterns.extend(exclude_glob_patterns)\n        input_filenames = glob_with_multiple_patterns(\n            folder=acq_input.image_dir,\n            include_patterns=include_patterns,\n            exclude_patterns=exclude_patterns,\n        )\n        for fn in input_filenames:\n            try:\n                filename_metadata = parse_filename(Path(fn).name)\n                plate = filename_metadata[\"plate\"]\n                plates.append(plate)\n                plate_prefix = filename_metadata[\"plate_prefix\"]\n                plate_prefixes.append(plate_prefix)\n                A = filename_metadata[\"A\"]\n                C = filename_metadata[\"C\"]\n                actual_wavelength_ids.append(f\"A{A}_C{C}\")\n            except ValueError as e:\n                logger.warning(\n                    f'Skipping \"{Path(fn).name}\". Original error: ' + str(e)\n                )\n        plates = sorted(list(set(plates)))\n        actual_wavelength_ids = sorted(list(set(actual_wavelength_ids)))\n\n        info = (\n            \"Listing all plates/channels:\\n\"\n            f\"Folder:   {acq_input.image_dir}\\n\"\n            f\"Include patterns: {include_patterns}\\n\"\n            f\"Exclude patterns: {exclude_patterns}\\n\"\n            f\"Plates:   {plates}\\n\"\n            f\"Actual wavelength IDs: {actual_wavelength_ids}\\n\"\n        )\n\n        # Check that a folder includes a single plate\n        if len(plates) &gt; 1:\n            raise ValueError(f\"{info}ERROR: {len(plates)} plates detected\")\n        elif len(plates) == 0:\n            raise ValueError(f\"{info}ERROR: No plates detected\")\n        original_plate = plates[0]\n        plate_prefix = plate_prefixes[0]\n\n        # Replace plate with the one of the first acquisition\n        if acquisition != acquisitions_sorted[0]:\n            plate = dict_acquisitions[acquisitions_sorted[0]][\"plate\"]\n            logger.warning(\n                f\"For {acquisition=}, we replace {original_plate=} with \"\n                f\"{plate=} (the one for acquisition {acquisitions_sorted[0]})\"\n            )\n\n        # Check that all channels are in the allowed_channels\n        allowed_wavelength_ids = [\n            c.wavelength_id for c in acq_input.allowed_channels\n        ]\n        if not set(actual_wavelength_ids).issubset(\n            set(allowed_wavelength_ids)\n        ):\n            msg = \"ERROR in create_ome_zarr\\n\"\n            msg += f\"actual_wavelength_ids: {actual_wavelength_ids}\\n\"\n            msg += f\"allowed_wavelength_ids: {allowed_wavelength_ids}\\n\"\n            raise ValueError(msg)\n\n        # Create actual_channels, i.e. a list of the channel dictionaries which\n        # are present\n        actual_channels = [\n            channel\n            for channel in acq_input.allowed_channels\n            if channel.wavelength_id in actual_wavelength_ids\n        ]\n\n        logger.info(f\"plate: {plate}\")\n        logger.info(f\"actual_channels: {actual_channels}\")\n\n        dict_acquisitions[acquisition] = {}\n        dict_acquisitions[acquisition][\"plate\"] = plate\n        dict_acquisitions[acquisition][\"original_plate\"] = original_plate\n        dict_acquisitions[acquisition][\"plate_prefix\"] = plate_prefix\n        dict_acquisitions[acquisition][\"image_folder\"] = acq_input.image_dir\n        dict_acquisitions[acquisition][\"original_paths\"] = [\n            acq_input.image_dir\n        ]\n        dict_acquisitions[acquisition][\"actual_channels\"] = actual_channels\n        dict_acquisitions[acquisition][\n            \"actual_wavelength_ids\"\n        ] = actual_wavelength_ids\n\n    parallelization_list = []\n    current_plates = [item[\"plate\"] for item in dict_acquisitions.values()]\n    if len(set(current_plates)) &gt; 1:\n        raise ValueError(f\"{current_plates=}\")\n    plate = sanitize_string(current_plates[0])\n\n    zarrurl = (\n        sanitize_string(dict_acquisitions[acquisitions_sorted[0]][\"plate\"])\n        + \".zarr\"\n    )\n    full_zarrurl = str(Path(zarr_dir) / zarrurl)\n    logger.info(f\"Creating {full_zarrurl=}\")\n    # Call zarr.open_group wrapper, which handles overwrite=True/False\n    group_plate = open_zarr_group_with_overwrite(\n        full_zarrurl, overwrite=overwrite\n    )\n    group_plate.attrs[\"plate\"] = {\n        \"acquisitions\": [\n            {\n                \"id\": int(acquisition),\n                \"name\": dict_acquisitions[acquisition][\"original_plate\"],\n            }\n            for acquisition in acquisitions_sorted\n        ]\n    }\n\n    zarrurls: dict[str, list[str]] = {\"well\": [], \"image\": []}\n    zarrurls[\"plate\"] = [f\"{plate}.zarr\"]\n\n    ################################################################\n    logging.info(f\"{acquisitions_sorted=}\")\n\n    for i, acquisition in enumerate(acquisitions_sorted):\n        # Define plate zarr\n        image_folder = dict_acquisitions[acquisition][\"image_folder\"]\n        logger.info(f\"Looking at {image_folder=}\")\n\n        # Obtain FOV-metadata dataframe\n        if metadata_table_files is None:\n            mrf_path = f\"{image_folder}/MeasurementDetail.mrf\"\n            mlf_path = f\"{image_folder}/MeasurementData.mlf\"\n            site_metadata, _ = parse_yokogawa_metadata(\n                mrf_path,\n                mlf_path,\n                include_patterns=include_glob_patterns,\n                exclude_patterns=exclude_glob_patterns,\n            )\n            site_metadata = remove_FOV_overlaps(site_metadata)\n        else:\n            site_metadata = pd.read_csv(metadata_table_files[acquisition])\n            site_metadata.set_index([\"well_id\", \"FieldIndex\"], inplace=True)\n\n        # Extract pixel sizes and bit_depth\n        pixel_size_z = site_metadata[\"pixel_size_z\"].iloc[0]\n        pixel_size_y = site_metadata[\"pixel_size_y\"].iloc[0]\n        pixel_size_x = site_metadata[\"pixel_size_x\"].iloc[0]\n        bit_depth = site_metadata[\"bit_depth\"].iloc[0]\n\n        if min(pixel_size_z, pixel_size_y, pixel_size_x) &lt; 1e-9:\n            raise ValueError(pixel_size_z, pixel_size_y, pixel_size_x)\n\n        # Identify all wells\n        plate_prefix = dict_acquisitions[acquisition][\"plate_prefix\"]\n        include_patterns = [f\"{plate_prefix}_*.{image_extension}\"]\n        if include_glob_patterns:\n            include_patterns.extend(include_glob_patterns)\n        plate_images = glob_with_multiple_patterns(\n            folder=str(image_folder),\n            include_patterns=include_patterns,\n            exclude_patterns=exclude_patterns,\n        )\n\n        wells = [\n            parse_filename(os.path.basename(fn))[\"well\"] for fn in plate_images\n        ]\n        wells = sorted(list(set(wells)))\n        logger.info(f\"{wells=}\")\n\n        # Verify that all wells have all channels\n        actual_channels = dict_acquisitions[acquisition][\"actual_channels\"]\n        for well in wells:\n            include_patterns = [f\"{plate_prefix}_{well}_*.{image_extension}\"]\n            if include_glob_patterns:\n                include_patterns.extend(include_glob_patterns)\n            well_images = glob_with_multiple_patterns(\n                folder=str(image_folder),\n                include_patterns=include_patterns,\n                exclude_patterns=exclude_patterns,\n            )\n\n            well_wavelength_ids = []\n            for fpath in well_images:\n                try:\n                    filename_metadata = parse_filename(os.path.basename(fpath))\n                    A = filename_metadata[\"A\"]\n                    C = filename_metadata[\"C\"]\n                    well_wavelength_ids.append(f\"A{A}_C{C}\")\n                except IndexError:\n                    logger.info(f\"Skipping {fpath}\")\n            well_wavelength_ids = sorted(list(set(well_wavelength_ids)))\n            actual_wavelength_ids = dict_acquisitions[acquisition][\n                \"actual_wavelength_ids\"\n            ]\n            if well_wavelength_ids != actual_wavelength_ids:\n                raise ValueError(\n                    f\"ERROR: well {well} in plate {plate} (prefix: \"\n                    f\"{plate_prefix}) has missing channels.\\n\"\n                    f\"Expected: {actual_wavelength_ids}\\n\"\n                    f\"Found: {well_wavelength_ids}.\\n\"\n                )\n\n        well_rows_columns = generate_row_col_split(wells)\n        row_list = [\n            well_row_column[0] for well_row_column in well_rows_columns\n        ]\n        col_list = [\n            well_row_column[1] for well_row_column in well_rows_columns\n        ]\n        row_list = sorted(list(set(row_list)))\n        col_list = sorted(list(set(col_list)))\n\n        plate_attrs = group_plate.attrs[\"plate\"]\n        plate_attrs[\"columns\"] = [{\"name\": col} for col in col_list]\n        plate_attrs[\"rows\"] = [{\"name\": row} for row in row_list]\n        plate_attrs[\"wells\"] = [\n            {\n                \"path\": well_row_column[0] + \"/\" + well_row_column[1],\n                \"rowIndex\": row_list.index(well_row_column[0]),\n                \"columnIndex\": col_list.index(well_row_column[1]),\n            }\n            for well_row_column in well_rows_columns\n        ]\n        plate_attrs[\"version\"] = __OME_NGFF_VERSION__\n        # Validate plate attrs\n        Plate(**plate_attrs)\n        group_plate.attrs[\"plate\"] = plate_attrs\n\n        for row, column in well_rows_columns:\n            parallelization_list.append(\n                {\n                    \"zarr_url\": (\n                        f\"{zarr_dir}/{plate}.zarr/{row}/{column}/\" f\"{i}\"\n                    ),\n                    \"init_args\": InitArgsCellVoyager(\n                        image_dir=acquisitions[acquisition].image_dir,\n                        plate_prefix=plate_prefix,\n                        well_ID=get_filename_well_id(row, column),\n                        image_extension=image_extension,\n                        include_glob_patterns=include_glob_patterns,\n                        exclude_glob_patterns=exclude_glob_patterns,\n                        acquisition=acquisition,\n                    ).model_dump(),\n                }\n            )\n            try:\n                group_well = group_plate.create_group(f\"{row}/{column}/\")\n                logging.info(f\"Created new group_well at {row}/{column}/\")\n                well_attrs = {\n                    \"images\": [\n                        {\n                            \"path\": f\"{i}\",\n                            \"acquisition\": int(acquisition),\n                        }\n                    ],\n                    \"version\": __OME_NGFF_VERSION__,\n                }\n                # Validate well attrs:\n                Well(**well_attrs)\n                group_well.attrs[\"well\"] = well_attrs\n                zarrurls[\"well\"].append(f\"{plate}.zarr/{row}/{column}\")\n                print(plate)\n                print(zarrurls[\"well\"])\n            except ContainsGroupError:\n                group_well = zarr.open_group(\n                    f\"{full_zarrurl}/{row}/{column}/\", mode=\"r+\"\n                )\n                logging.info(\n                    f\"Loaded group_well from {full_zarrurl}/{row}/{column}\"\n                )\n                current_images = group_well.attrs[\"well\"][\"images\"] + [\n                    {\"path\": f\"{i}\", \"acquisition\": int(acquisition)}\n                ]\n                well_attrs = dict(\n                    images=current_images,\n                    version=group_well.attrs[\"well\"][\"version\"],\n                )\n                # Validate well attrs:\n                Well(**well_attrs)\n                group_well.attrs[\"well\"] = well_attrs\n\n            group_image = group_well.create_group(f\"{i}/\")  # noqa: F841\n            logging.info(f\"Created image group {row}/{column}/{i}\")\n            image = f\"{plate}.zarr/{row}/{column}/{i}\"\n            zarrurls[\"image\"].append(image)\n\n            group_image.attrs[\"multiscales\"] = [\n                {\n                    \"version\": __OME_NGFF_VERSION__,\n                    \"axes\": [\n                        {\"name\": \"c\", \"type\": \"channel\"},\n                        {\n                            \"name\": \"z\",\n                            \"type\": \"space\",\n                            \"unit\": \"micrometer\",\n                        },\n                        {\n                            \"name\": \"y\",\n                            \"type\": \"space\",\n                            \"unit\": \"micrometer\",\n                        },\n                        {\n                            \"name\": \"x\",\n                            \"type\": \"space\",\n                            \"unit\": \"micrometer\",\n                        },\n                    ],\n                    \"datasets\": [\n                        {\n                            \"path\": f\"{ind_level}\",\n                            \"coordinateTransformations\": [\n                                {\n                                    \"type\": \"scale\",\n                                    \"scale\": [\n                                        1,\n                                        pixel_size_z,\n                                        pixel_size_y\n                                        * coarsening_xy**ind_level,\n                                        pixel_size_x\n                                        * coarsening_xy**ind_level,\n                                    ],\n                                }\n                            ],\n                        }\n                        for ind_level in range(num_levels)\n                    ],\n                }\n            ]\n\n            group_image.attrs[\"omero\"] = {\n                \"id\": 1,  # FIXME does this depend on the plate number?\n                \"name\": \"TBD\",\n                \"version\": __OME_NGFF_VERSION__,\n                \"channels\": define_omero_channels(\n                    channels=actual_channels,\n                    bit_depth=bit_depth,\n                    label_prefix=i,\n                ),\n            }\n            # Validate Image attrs\n            NgffImageMeta(**group_image.attrs)\n\n            # Prepare AnnData tables for FOV/well ROIs\n            well_id = get_filename_well_id(row, column)\n            FOV_ROIs_table = prepare_FOV_ROI_table(site_metadata.loc[well_id])\n            well_ROIs_table = prepare_well_ROI_table(\n                site_metadata.loc[well_id]\n            )\n\n            # Write AnnData tables into the `tables` zarr group\n            write_table(\n                group_image,\n                \"FOV_ROI_table\",\n                FOV_ROIs_table,\n                overwrite=overwrite,\n                table_attrs={\"type\": \"roi_table\"},\n            )\n            write_table(\n                group_image,\n                \"well_ROI_table\",\n                well_ROIs_table,\n                overwrite=overwrite,\n                table_attrs={\"type\": \"roi_table\"},\n            )\n\n    # Check that the different images (e.g. different acquisitions) in the each\n    # well have unique labels\n    for well_path in zarrurls[\"well\"]:\n        check_well_channel_labels(\n            well_zarr_path=str(Path(zarr_dir) / well_path)\n        )\n\n    return dict(parallelization_list=parallelization_list)\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/copy_ome_zarr_hcs_plate/","title":"copy_ome_zarr_hcs_plate","text":"<p>Task that copies the structure of an OME-NGFF zarr array to a new one.</p>"},{"location":"reference/fractal_tasks_core/tasks/copy_ome_zarr_hcs_plate/#fractal_tasks_core.tasks.copy_ome_zarr_hcs_plate._get_plate","title":"<code>_get_plate(current_plate_url, proj_plate_url, re_initialize_plate=False)</code>","text":"<p>Given the absolute <code>plate_url</code> for an OME-Zarr plate,     return the plate object.</p> <p>If the plate already exists, return it. If it does not exist, or if <code>re_initialize_plate</code> is True,     create a proj plate and return it.</p> Source code in <code>fractal_tasks_core/tasks/copy_ome_zarr_hcs_plate.py</code> <pre><code>def _get_plate(\n    current_plate_url: str,\n    proj_plate_url: str,\n    re_initialize_plate: bool = False,\n) -&gt; OmeZarrPlate:\n\"\"\"\n    Given the absolute `plate_url` for an OME-Zarr plate,\n        return the plate object.\n\n    If the plate already exists, return it.\n    If it does not exist, or if `re_initialize_plate` is True,\n        create a proj plate and return it.\n    \"\"\"\n    if re_initialize_plate or not Path(proj_plate_url).exists():\n        logger.info(f\"Creating proj plate: {proj_plate_url}\")\n        proj_plate_name = proj_plate_url.split(\"/\")[-1]\n\n        plate = open_ome_zarr_plate(current_plate_url).derive_plate(\n            proj_plate_url,\n            plate_name=proj_plate_name,\n            overwrite=re_initialize_plate,\n            keep_acquisitions=True,\n            parallel_safe=False,\n        )\n        logger.info(f\"proj plate created: {plate}\")\n        return plate\n\n    plate = open_ome_zarr_plate(proj_plate_url, parallel_safe=False)\n    logger.info(f\"Plate already exists: {plate}\")\n    return plate\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/copy_ome_zarr_hcs_plate/#fractal_tasks_core.tasks.copy_ome_zarr_hcs_plate._open_well","title":"<code>_open_well(well_path)</code>  <code>cached</code>","text":"<p>Given the absolute <code>well_url</code> for an OME-Zarr plate,     return the well object.</p> Source code in <code>fractal_tasks_core/tasks/copy_ome_zarr_hcs_plate.py</code> <pre><code>@cache\ndef _open_well(well_path) -&gt; OmeZarrWell:\n\"\"\"\n    Given the absolute `well_url` for an OME-Zarr plate,\n        return the well object.\n    \"\"\"\n    try:\n        well = open_ome_zarr_well(\n            well_path, mode=\"r\", cache=True, parallel_safe=False\n        )\n    except NgioFileNotFoundError:\n        raise NgioFileNotFoundError(\n            f\"Could not open well {well_path}. \"\n            \"Ensure that the path is correct and the file exists.\"\n        )\n    return well\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/copy_ome_zarr_hcs_plate/#fractal_tasks_core.tasks.copy_ome_zarr_hcs_plate.copy_ome_zarr_hcs_plate","title":"<code>copy_ome_zarr_hcs_plate(*, zarr_urls, zarr_dir, method=DaskProjectionMethod.MIP, overwrite=False, re_initialize_plate=False)</code>","text":"<p>Duplicate the OME-Zarr HCS structure for a set of zarr_urls.</p> <p>This task only processes the zarr images in the zarr_urls, not all the images in the plate. It copies all the  plate &amp; well structure, but none of the image metadata or the actual image data:</p> <ul> <li>For each plate, create a new OME-Zarr HCS plate with the attributes for     all the images in zarr_urls</li> <li>For each well (in each plate), create a new zarr subgroup with the    same attributes as the original one.</li> </ul> <p>Note: this task makes use of methods from the <code>Attributes</code> class, see https://zarr.readthedocs.io/en/stable/api/attrs.html.</p> PARAMETER DESCRIPTION <code>zarr_urls</code> <p>List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>list[str]</code> </p> <code>zarr_dir</code> <p>path of the directory where the new OME-Zarrs will be created. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>method</code> <p>Choose which method to use for intensity projection along the Z axis. mip is the default and performs a maximum intensity projection. minip performs a minimum intensity projection, meanip a mean intensity projection and sumip a sum intensity projection.</p> <p> TYPE: <code>DaskProjectionMethod</code> DEFAULT: <code>MIP</code> </p> <code>overwrite</code> <p>If <code>True</code>, overwrite the MIP images if they are already present in the new OME-Zarr Plate.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>re_initialize_plate</code> <p>If <code>True</code>, re-initialize the plate, deleting all existing wells and images. If <code>False</code>, the task will only incrementally add new wells and images to the plate.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>A parallelization list to be used in a compute task to fill the wells</p> <code>dict[str, Any]</code> <p>with OME-Zarr images.</p> Source code in <code>fractal_tasks_core/tasks/copy_ome_zarr_hcs_plate.py</code> <pre><code>@validate_call\ndef copy_ome_zarr_hcs_plate(\n    *,\n    # Fractal parameters\n    zarr_urls: list[str],\n    zarr_dir: str,\n    method: DaskProjectionMethod = DaskProjectionMethod.MIP,\n    # Advanced parameters\n    overwrite: bool = False,\n    re_initialize_plate: bool = False,\n) -&gt; dict[str, Any]:\n\"\"\"\n    Duplicate the OME-Zarr HCS structure for a set of zarr_urls.\n\n    This task only processes the zarr images in the zarr_urls, not all the\n    images in the plate. It copies all the  plate &amp; well structure, but none\n    of the image metadata or the actual image data:\n\n    - For each plate, create a new OME-Zarr HCS plate with the attributes for\n        all the images in zarr_urls\n    - For each well (in each plate), create a new zarr subgroup with the\n       same attributes as the original one.\n\n    Note: this task makes use of methods from the `Attributes` class, see\n    https://zarr.readthedocs.io/en/stable/api/attrs.html.\n\n    Args:\n        zarr_urls: List of paths or urls to the individual OME-Zarr image to\n            be processed.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        zarr_dir: path of the directory where the new OME-Zarrs will be\n            created.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        method: Choose which method to use for intensity projection along the\n            Z axis. mip is the default and performs a maximum intensity\n            projection. minip performs a minimum intensity projection, meanip\n            a mean intensity projection and sumip a sum intensity projection.\n        overwrite: If `True`, overwrite the MIP images if they are\n            already present in the new OME-Zarr Plate.\n        re_initialize_plate: If `True`, re-initialize the plate, deleting all\n            existing wells and images. If `False`, the task will only\n            incrementally add new wells and images to the plate.\n\n    Returns:\n        A parallelization list to be used in a compute task to fill the wells\n        with OME-Zarr images.\n    \"\"\"\n    parallelization_list = []\n\n    # A dictionary to store the plates and avoid re-initializing them multiple\n    # times\n    proj_plates: dict[str, OmeZarrPlate] = {}\n    # A dictionary to store the images and avoid re-initializing querying all\n    # wells multiple times\n    proj_plates_images_paths: dict[str, list[str]] = {}\n\n    # Generate parallelization list\n    for zarr_url in zarr_urls:\n        # Check if the zarr_url is valid\n        if len(zarr_url.rstrip(\"/\").split(\"/\")) &lt; 4:\n            raise ValueError(\n                f\"Invalid zarr_url: {zarr_url}. \"\n                \"The zarr_url of an image in a plate should be of the form \"\n                \"`/path/to/plate_name/row/column/image_path`. \"\n                \"The zarr_url given is too short to be valid.\"\n            )\n        *base, plate_name, row, column, image_path = zarr_url.rstrip(\n            \"/\"\n        ).split(\"/\")\n        base_dir = \"/\".join(base)\n\n        plate_url = f\"{base_dir}/{plate_name}\"\n        proj_plate_name = (\n            f\"{plate_name}\".rstrip(\".zarr\") + f\"_{method.value}.zarr\"\n        )\n        proj_plate_url = f\"{zarr_dir}/{proj_plate_name}\"\n\n        if proj_plate_url not in proj_plates:\n            _proj_plate = _get_plate(\n                current_plate_url=plate_url,\n                proj_plate_url=proj_plate_url,\n                re_initialize_plate=re_initialize_plate,\n            )\n            proj_plates[proj_plate_url] = _proj_plate\n            proj_plates_images_paths[\n                proj_plate_url\n            ] = _proj_plate.images_paths()\n\n        proj_plate = proj_plates[proj_plate_url]\n        proj_plate_images_paths = proj_plates_images_paths[proj_plate_url]\n\n        well_path = f\"{plate_url}/{row}/{column}\"\n        well = _open_well(well_path)\n        acquisition_id = well.get_image_acquisition_id(image_path)\n\n        proj_image_path = f\"{row}/{column}/{image_path}\"\n\n        if proj_image_path in proj_plate_images_paths:\n            if not overwrite:\n                raise NgioFileExistsError(\n                    f\"Image {proj_image_path} already exists in \"\n                    f\"{proj_plate_url}. Set `overwrite=True` \"\n                    \"to overwrite it.\"\n                )\n            logger.info(\n                f\"Image {proj_image_path} already exists in {proj_plate_url}. \"\n                \"Overwriting it.\"\n            )\n\n        else:\n            proj_plate.add_image(\n                row=row,\n                column=column,\n                image_path=image_path,\n                acquisition_id=acquisition_id,\n            )\n            proj_plates_images_paths[proj_plate_url].append(proj_image_path)\n\n        proj_zarr_url = f\"{proj_plate_url}/{proj_image_path}\"\n        proj_init = InitArgsMIP(\n            origin_url=zarr_url,\n            method=method.value,\n            # Since we checked for existence above,\n            # we can safely set this to True\n            overwrite=True,\n            new_plate_name=proj_plate_name,\n        )\n        parallelization_item = {\n            \"zarr_url\": proj_zarr_url,\n            \"init_args\": proj_init.model_dump(),\n        }\n        parallelization_list.append(parallelization_item)\n\n    _open_well.cache_clear()\n    return dict(parallelization_list=parallelization_list)\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/find_registration_consensus/","title":"find_registration_consensus","text":"<p>Applies the multiplexing translation to all ROI tables</p>"},{"location":"reference/fractal_tasks_core/tasks/find_registration_consensus/#fractal_tasks_core.tasks.find_registration_consensus.find_registration_consensus","title":"<code>find_registration_consensus(*, zarr_url, init_args, roi_table='FOV_ROI_table', new_roi_table=None)</code>","text":"<p>Applies pre-calculated registration to ROI tables.</p> <p>Apply pre-calculated registration such that resulting ROIs contain the consensus align region between all acquisitions.</p> <p>Parallelization level: well</p> PARAMETER DESCRIPTION <code>zarr_url</code> <p>Path or url to the individual OME-Zarr image to be processed. Refers to the zarr_url of the reference acquisition. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>init_args</code> <p>Intialization arguments provided by <code>init_group_by_well_for_multiplexing</code>. It contains the zarr_url_list listing all the zarr_urls in the same well as the zarr_url of the reference acquisition that are being processed. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>InitArgsRegistrationConsensus</code> </p> <code>roi_table</code> <p>Name of the ROI table over which the task loops to calculate the registration. Examples: <code>FOV_ROI_table</code> =&gt; loop over the field of views, <code>well_ROI_table</code> =&gt; process the whole well as one image.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'FOV_ROI_table'</code> </p> <code>new_roi_table</code> <p>Optional name for the new, registered ROI table. If no name is given, it will default to \"registered_\" + <code>roi_table</code></p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>fractal_tasks_core/tasks/find_registration_consensus.py</code> <pre><code>@validate_call\ndef find_registration_consensus(\n    *,\n    # Fractal parameters\n    zarr_url: str,\n    init_args: InitArgsRegistrationConsensus,\n    # Core parameters\n    roi_table: str = \"FOV_ROI_table\",\n    # Advanced parameters\n    new_roi_table: Optional[str] = None,\n):\n\"\"\"\n    Applies pre-calculated registration to ROI tables.\n\n    Apply pre-calculated registration such that resulting ROIs contain\n    the consensus align region between all acquisitions.\n\n    Parallelization level: well\n\n    Args:\n        zarr_url: Path or url to the individual OME-Zarr image to be processed.\n            Refers to the zarr_url of the reference acquisition.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        init_args: Intialization arguments provided by\n            `init_group_by_well_for_multiplexing`. It contains the\n            zarr_url_list listing all the zarr_urls in the same well as the\n            zarr_url of the reference acquisition that are being processed.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        roi_table: Name of the ROI table over which the task loops to\n            calculate the registration. Examples: `FOV_ROI_table` =&gt; loop over\n            the field of views, `well_ROI_table` =&gt; process the whole well as\n            one image.\n        new_roi_table: Optional name for the new, registered ROI table. If no\n            name is given, it will default to \"registered_\" + `roi_table`\n\n    \"\"\"\n    if not new_roi_table:\n        new_roi_table = \"registered_\" + roi_table\n    logger.info(\n        f\"Running for {zarr_url=} &amp; the other acquisitions in that well. \\n\"\n        f\"Applying translation registration to {roi_table=} and storing it as \"\n        f\"{new_roi_table=}.\"\n    )\n\n    # Collect all the ROI tables\n    roi_tables = {}\n    roi_tables_attrs = {}\n    for acq_zarr_url in init_args.zarr_url_list:\n        curr_ROI_table = ad.read_zarr(f\"{acq_zarr_url}/tables/{roi_table}\")\n        curr_ROI_table_group = zarr.open_group(\n            f\"{acq_zarr_url}/tables/{roi_table}\", mode=\"r\"\n        )\n        curr_ROI_table_attrs = curr_ROI_table_group.attrs.asdict()\n\n        # For reference_acquisition, handle the fact that it doesn't\n        # have the shifts\n        if acq_zarr_url == zarr_url:\n            curr_ROI_table = add_zero_translation_columns(curr_ROI_table)\n        # Check for valid ROI tables\n        are_ROI_table_columns_valid(table=curr_ROI_table)\n        translation_columns = [\n            \"translation_z\",\n            \"translation_y\",\n            \"translation_x\",\n        ]\n        if curr_ROI_table.var.index.isin(translation_columns).sum() != 3:\n            raise ValueError(\n                f\"{roi_table=} in {acq_zarr_url} does not contain the \"\n                f\"translation columns {translation_columns} necessary to use \"\n                \"this task.\"\n            )\n        roi_tables[acq_zarr_url] = curr_ROI_table\n        roi_tables_attrs[acq_zarr_url] = curr_ROI_table_attrs\n\n    # Check that all acquisitions have the same ROIs\n    rois = roi_tables[list(roi_tables.keys())[0]].obs.index\n    for acq_zarr_url, acq_roi_table in roi_tables.items():\n        if not (acq_roi_table.obs.index == rois).all():\n            raise ValueError(\n                f\"Acquisition {acq_zarr_url} does not contain the same ROIs \"\n                f\"as the reference acquisition {zarr_url}:\\n\"\n                f\"{acq_zarr_url}: {acq_roi_table.obs.index}\\n\"\n                f\"{zarr_url}: {rois}\"\n            )\n\n    roi_table_dfs = [\n        roi_table.to_df().loc[:, translation_columns]\n        for roi_table in roi_tables.values()\n    ]\n    logger.info(\"Calculating min &amp; max translation across acquisitions.\")\n    max_df, min_df = calculate_min_max_across_dfs(roi_table_dfs)\n    shifted_rois = {}\n\n    # Loop over acquisitions\n    for acq_zarr_url in init_args.zarr_url_list:\n        shifted_rois[acq_zarr_url] = apply_registration_to_single_ROI_table(\n            roi_tables[acq_zarr_url], max_df, min_df\n        )\n\n        # TODO: Drop translation columns from this table?\n\n        logger.info(\n            f\"Write the registered ROI table {new_roi_table} for \"\n            \"{acq_zarr_url=}\"\n        )\n        # Save the shifted ROI table as a new table\n        image_group = zarr.group(acq_zarr_url)\n        write_table(\n            image_group,\n            new_roi_table,\n            shifted_rois[acq_zarr_url],\n            table_attrs=roi_tables_attrs[acq_zarr_url],\n            overwrite=True,\n        )\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/illumination_correction/","title":"illumination_correction","text":"<p>Apply illumination correction to all fields of view.</p>"},{"location":"reference/fractal_tasks_core/tasks/illumination_correction/#fractal_tasks_core.tasks.illumination_correction.correct","title":"<code>correct(img_stack, corr_img, background=110)</code>","text":"<p>Corrects a stack of images, using a given illumination profile (e.g. bright in the center of the image, dim outside).</p> PARAMETER DESCRIPTION <code>img_stack</code> <p>4D numpy array (czyx), with dummy size along c.</p> <p> TYPE: <code>ndarray</code> </p> <code>corr_img</code> <p>2D numpy array (yx)</p> <p> TYPE: <code>ndarray</code> </p> <code>background</code> <p>Background value that is subtracted from the image before the illumination correction is applied.</p> <p> TYPE: <code>int</code> DEFAULT: <code>110</code> </p> Source code in <code>fractal_tasks_core/tasks/illumination_correction.py</code> <pre><code>def correct(\n    img_stack: np.ndarray,\n    corr_img: np.ndarray,\n    background: int = 110,\n):\n\"\"\"\n    Corrects a stack of images, using a given illumination profile (e.g. bright\n    in the center of the image, dim outside).\n\n    Args:\n        img_stack: 4D numpy array (czyx), with dummy size along c.\n        corr_img: 2D numpy array (yx)\n        background: Background value that is subtracted from the image before\n            the illumination correction is applied.\n    \"\"\"\n\n    logger.info(f\"Start correct, {img_stack.shape}\")\n\n    # Check shapes\n    if corr_img.shape != img_stack.shape[2:] or img_stack.shape[0] != 1:\n        raise ValueError(\n            \"Error in illumination_correction:\\n\"\n            f\"{img_stack.shape=}\\n{corr_img.shape=}\"\n        )\n\n    # Store info about dtype\n    dtype = img_stack.dtype\n    dtype_max = np.iinfo(dtype).max\n\n    # Background subtraction\n    img_stack[img_stack &lt;= background] = 0\n    img_stack[img_stack &gt; background] -= background\n\n    #  Apply the normalized correction matrix (requires a float array)\n    # img_stack = img_stack.astype(np.float64)\n    new_img_stack = img_stack / (corr_img / np.max(corr_img))[None, None, :, :]\n\n    # Handle edge case: corrected image may have values beyond the limit of\n    # the encoding, e.g. beyond 65535 for 16bit images. This clips values\n    # that surpass this limit and triggers a warning\n    if np.sum(new_img_stack &gt; dtype_max) &gt; 0:\n        warnings.warn(\n            \"Illumination correction created values beyond the max range of \"\n            f\"the current image type. These have been clipped to {dtype_max=}.\"\n        )\n        new_img_stack[new_img_stack &gt; dtype_max] = dtype_max\n\n    logger.info(\"End correct\")\n\n    # Cast back to original dtype and return\n    return new_img_stack.astype(dtype)\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/illumination_correction/#fractal_tasks_core.tasks.illumination_correction.illumination_correction","title":"<code>illumination_correction(*, zarr_url, illumination_profiles_folder, illumination_profiles, background=0, input_ROI_table='FOV_ROI_table', overwrite_input=True, suffix='_illum_corr')</code>","text":"<p>Applies illumination correction to the images in the OME-Zarr.</p> <p>Assumes that the illumination correction profiles were generated before separately and that the same background subtraction was used during calculation of the illumination correction (otherwise, it will not work well &amp; the correction may only be partial).</p> PARAMETER DESCRIPTION <code>zarr_url</code> <p>Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>illumination_profiles_folder</code> <p>Path of folder of illumination profiles.</p> <p> TYPE: <code>str</code> </p> <code>illumination_profiles</code> <p>Dictionary where keys match the <code>wavelength_id</code> attributes of existing channels (e.g.  <code>A01_C01</code> ) and values are the filenames of the corresponding illumination profiles.</p> <p> TYPE: <code>dict[str, str]</code> </p> <code>background</code> <p>Background value that is subtracted from the image before the illumination correction is applied. Set it to <code>0</code> if you don't want any background subtraction.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>input_ROI_table</code> <p>Name of the ROI table that contains the information about the location of the individual field of views (FOVs) to which the illumination correction shall be applied. Defaults to \"FOV_ROI_table\", the default name Fractal converters give the ROI tables that list all FOVs separately. If you generated your OME-Zarr with a different converter and used Import OME-Zarr to generate the ROI tables, <code>image_ROI_table</code> is the right choice if you only have 1 FOV per Zarr image and <code>grid_ROI_table</code> if you have multiple FOVs per Zarr image and set the right grid options during import.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'FOV_ROI_table'</code> </p> <code>overwrite_input</code> <p>If <code>True</code>, the results of this task will overwrite the input image data. If false, a new image is generated and the illumination corrected data is saved there.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>suffix</code> <p>What suffix to append to the illumination corrected images. Only relevant if <code>overwrite_input=False</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'_illum_corr'</code> </p> Source code in <code>fractal_tasks_core/tasks/illumination_correction.py</code> <pre><code>@validate_call\ndef illumination_correction(\n    *,\n    # Fractal parameters\n    zarr_url: str,\n    # Core parameters\n    illumination_profiles_folder: str,\n    illumination_profiles: dict[str, str],\n    background: int = 0,\n    input_ROI_table: str = \"FOV_ROI_table\",\n    overwrite_input: bool = True,\n    # Advanced parameters\n    suffix: str = \"_illum_corr\",\n) -&gt; dict[str, Any]:\n\"\"\"\n    Applies illumination correction to the images in the OME-Zarr.\n\n    Assumes that the illumination correction profiles were generated before\n    separately and that the same background subtraction was used during\n    calculation of the illumination correction (otherwise, it will not work\n    well &amp; the correction may only be partial).\n\n    Args:\n        zarr_url: Path or url to the individual OME-Zarr image to be processed.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        illumination_profiles_folder: Path of folder of illumination profiles.\n        illumination_profiles: Dictionary where keys match the `wavelength_id`\n            attributes of existing channels (e.g.  `A01_C01` ) and values are\n            the filenames of the corresponding illumination profiles.\n        background: Background value that is subtracted from the image before\n            the illumination correction is applied. Set it to `0` if you don't\n            want any background subtraction.\n        input_ROI_table: Name of the ROI table that contains the information\n            about the location of the individual field of views (FOVs) to\n            which the illumination correction shall be applied. Defaults to\n            \"FOV_ROI_table\", the default name Fractal converters give the ROI\n            tables that list all FOVs separately. If you generated your\n            OME-Zarr with a different converter and used Import OME-Zarr to\n            generate the ROI tables, `image_ROI_table` is the right choice if\n            you only have 1 FOV per Zarr image and `grid_ROI_table` if you\n            have multiple FOVs per Zarr image and set the right grid options\n            during import.\n        overwrite_input: If `True`, the results of this task will overwrite\n            the input image data. If false, a new image is generated and the\n            illumination corrected data is saved there.\n        suffix: What suffix to append to the illumination corrected images.\n            Only relevant if `overwrite_input=False`.\n    \"\"\"\n\n    # Defione old/new zarrurls\n    if overwrite_input:\n        zarr_url_new = zarr_url.rstrip(\"/\")\n    else:\n        zarr_url_new = zarr_url.rstrip(\"/\") + suffix\n\n    t_start = time.perf_counter()\n    logger.info(\"Start illumination_correction\")\n    logger.info(f\"  {overwrite_input=}\")\n    logger.info(f\"  {zarr_url=}\")\n    logger.info(f\"  {zarr_url_new=}\")\n\n    # Read attributes from NGFF metadata\n    ngff_image_meta = load_NgffImageMeta(zarr_url)\n    num_levels = ngff_image_meta.num_levels\n    coarsening_xy = ngff_image_meta.coarsening_xy\n    full_res_pxl_sizes_zyx = ngff_image_meta.get_pixel_sizes_zyx(level=0)\n    logger.info(f\"NGFF image has {num_levels=}\")\n    logger.info(f\"NGFF image has {coarsening_xy=}\")\n    logger.info(\n        f\"NGFF image has full-res pixel sizes {full_res_pxl_sizes_zyx}\"\n    )\n\n    # Read channels from .zattrs\n    channels: list[OmeroChannel] = get_omero_channel_list(\n        image_zarr_path=zarr_url\n    )\n    num_channels = len(channels)\n\n    # Read FOV ROIs\n    FOV_ROI_table = ad.read_zarr(f\"{zarr_url}/tables/{input_ROI_table}\")\n\n    # Create list of indices for 3D FOVs spanning the entire Z direction\n    list_indices = convert_ROI_table_to_indices(\n        FOV_ROI_table,\n        level=0,\n        coarsening_xy=coarsening_xy,\n        full_res_pxl_sizes_zyx=full_res_pxl_sizes_zyx,\n    )\n    check_valid_ROI_indices(list_indices, input_ROI_table)\n\n    # Extract image size from FOV-ROI indices. Note: this works at level=0,\n    # where FOVs should all be of the exact same size (in pixels)\n    ref_img_size = None\n    for indices in list_indices:\n        img_size = (indices[3] - indices[2], indices[5] - indices[4])\n        if ref_img_size is None:\n            ref_img_size = img_size\n        else:\n            if img_size != ref_img_size:\n                raise ValueError(\n                    \"ERROR: inconsistent image sizes in list_indices\"\n                )\n    img_size_y, img_size_x = img_size[:]\n\n    # Assemble dictionary of matrices and check their shapes\n    corrections = {}\n    for channel in channels:\n        wavelength_id = channel.wavelength_id\n        corrections[wavelength_id] = imread(\n            (\n                Path(illumination_profiles_folder)\n                / illumination_profiles[wavelength_id]\n            ).as_posix()\n        )\n        if corrections[wavelength_id].shape != (img_size_y, img_size_x):\n            raise ValueError(\n                \"Error in illumination_correction, \"\n                \"correction matrix has wrong shape.\"\n            )\n\n    # Lazily load highest-res level from original zarr array\n    data_czyx = da.from_zarr(f\"{zarr_url}/0\")\n\n    # Create zarr for output\n    if overwrite_input:\n        new_zarr = zarr.open(f\"{zarr_url_new}/0\")\n    else:\n        new_zarr = zarr.create(\n            shape=data_czyx.shape,\n            chunks=data_czyx.chunksize,\n            dtype=data_czyx.dtype,\n            store=zarr.storage.FSStore(f\"{zarr_url_new}/0\"),\n            overwrite=False,\n            dimension_separator=\"/\",\n        )\n        _copy_hcs_ome_zarr_metadata(zarr_url, zarr_url_new)\n        # Copy ROI tables from the old zarr_url to keep ROI tables and other\n        # tables available in the new Zarr\n        _copy_tables_from_zarr_url(zarr_url, zarr_url_new)\n\n    # Iterate over FOV ROIs\n    num_ROIs = len(list_indices)\n    for i_c, channel in enumerate(channels):\n        for i_ROI, indices in enumerate(list_indices):\n            # Define region\n            s_z, e_z, s_y, e_y, s_x, e_x = indices[:]\n            region = (\n                slice(i_c, i_c + 1),\n                slice(s_z, e_z),\n                slice(s_y, e_y),\n                slice(s_x, e_x),\n            )\n            logger.info(\n                f\"Now processing ROI {i_ROI+1}/{num_ROIs} \"\n                f\"for channel {i_c+1}/{num_channels}\"\n            )\n            # Execute illumination correction\n            corrected_fov = correct(\n                data_czyx[region].compute(),\n                corrections[channel.wavelength_id],\n                background=background,\n            )\n            # Write to disk\n            da.array(corrected_fov).to_zarr(\n                url=new_zarr,\n                region=region,\n                compute=True,\n            )\n\n    # Starting from on-disk highest-resolution data, build and write to disk a\n    # pyramid of coarser levels\n    build_pyramid(\n        zarrurl=zarr_url_new,\n        overwrite=True,\n        num_levels=num_levels,\n        coarsening_xy=coarsening_xy,\n        chunksize=data_czyx.chunksize,\n    )\n\n    t_end = time.perf_counter()\n    logger.info(f\"End illumination_correction, elapsed: {t_end-t_start}\")\n\n    if overwrite_input:\n        image_list_updates = dict(image_list_updates=[dict(zarr_url=zarr_url)])\n    else:\n        image_list_updates = dict(\n            image_list_updates=[dict(zarr_url=zarr_url_new, origin=zarr_url)]\n        )\n    return image_list_updates\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/image_based_registration_hcs_init/","title":"image_based_registration_hcs_init","text":"<p>Initializes the parallelization list for registration in HCS plates.</p>"},{"location":"reference/fractal_tasks_core/tasks/image_based_registration_hcs_init/#fractal_tasks_core.tasks.image_based_registration_hcs_init.image_based_registration_hcs_init","title":"<code>image_based_registration_hcs_init(*, zarr_urls, zarr_dir, reference_acquisition=0)</code>","text":"<p>Initialized calculate registration task</p> <p>This task prepares a parallelization list of all zarr_urls that need to be used to calculate the registration between acquisitions (all zarr_urls except the reference acquisition vs. the reference acquisition). This task only works for HCS OME-Zarrs for 2 reasons: Only HCS OME-Zarrs currently have defined acquisition metadata to determine reference acquisitions. And we have only implemented the grouping of images for HCS OME-Zarrs by well (with the assumption that every well just has 1 image per acqusition).</p> PARAMETER DESCRIPTION <code>zarr_urls</code> <p>List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>list[str]</code> </p> <code>zarr_dir</code> <p>path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>reference_acquisition</code> <p>Which acquisition to register against. Needs to match the acquisition metadata in the OME-Zarr image.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>task_output</code> <p>Dictionary for Fractal server that contains a parallelization list.</p> <p> TYPE: <code>dict[str, list[dict[str, Any]]]</code> </p> Source code in <code>fractal_tasks_core/tasks/image_based_registration_hcs_init.py</code> <pre><code>@validate_call\ndef image_based_registration_hcs_init(\n    *,\n    # Fractal parameters\n    zarr_urls: list[str],\n    zarr_dir: str,\n    # Core parameters\n    reference_acquisition: int = 0,\n) -&gt; dict[str, list[dict[str, Any]]]:\n\"\"\"\n    Initialized calculate registration task\n\n    This task prepares a parallelization list of all zarr_urls that need to be\n    used to calculate the registration between acquisitions (all zarr_urls\n    except the reference acquisition vs. the reference acquisition).\n    This task only works for HCS OME-Zarrs for 2 reasons: Only HCS OME-Zarrs\n    currently have defined acquisition metadata to determine reference\n    acquisitions. And we have only implemented the grouping of images for\n    HCS OME-Zarrs by well (with the assumption that every well just has 1\n    image per acqusition).\n\n    Args:\n        zarr_urls: List of paths or urls to the individual OME-Zarr image to\n            be processed.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        zarr_dir: path of the directory where the new OME-Zarrs will be\n            created. Not used by this task.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        reference_acquisition: Which acquisition to register against. Needs to\n            match the acquisition metadata in the OME-Zarr image.\n\n    Returns:\n        task_output: Dictionary for Fractal server that contains a\n            parallelization list.\n    \"\"\"\n    logger.info(\n        f\"Running `image_based_registration_hcs_init` for {zarr_urls=}\"\n    )\n    image_groups = create_well_acquisition_dict(zarr_urls)\n\n    # Create the parallelization list\n    parallelization_list = []\n    for key, image_group in image_groups.items():\n        # Assert that all image groups have the reference acquisition present\n        if reference_acquisition not in image_group.keys():\n            raise ValueError(\n                f\"Registration with {reference_acquisition=} can only work if \"\n                \"all wells have the reference acquisition present. It was not \"\n                f\"found for well {key}.\"\n            )\n        # Add all zarr_urls except the reference acquisition to the\n        # parallelization list\n        for acquisition, zarr_url in image_group.items():\n            if acquisition != reference_acquisition:\n                reference_zarr_url = image_group[reference_acquisition]\n                parallelization_list.append(\n                    dict(\n                        zarr_url=zarr_url,\n                        init_args=dict(reference_zarr_url=reference_zarr_url),\n                    )\n                )\n\n    return dict(parallelization_list=parallelization_list)\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/import_ome_zarr/","title":"import_ome_zarr","text":"<p>Task to import an existing OME-Zarr.</p>"},{"location":"reference/fractal_tasks_core/tasks/import_ome_zarr/#fractal_tasks_core.tasks.import_ome_zarr._process_single_image","title":"<code>_process_single_image(image_path, add_image_ROI_table, add_grid_ROI_table, update_omero_metadata, *, grid_YX_shape=None, overwrite=False)</code>","text":"<p>Validate OME-NGFF metadata and optionally generate ROI tables.</p> <p>This task:</p> <ol> <li>Validates OME-NGFF image metadata, via <code>NgffImageMeta</code>;</li> <li>Optionally generates and writes two ROI tables;</li> <li>Optionally update OME-NGFF omero metadata.</li> <li>Returns dataset types</li> </ol> PARAMETER DESCRIPTION <code>image_path</code> <p>Absolute path to the image Zarr group.</p> <p> TYPE: <code>str</code> </p> <code>add_image_ROI_table</code> <p>Whether to add a <code>image_ROI_table</code> table (argument propagated from <code>import_ome_zarr</code>).</p> <p> TYPE: <code>bool</code> </p> <code>add_grid_ROI_table</code> <p>Whether to add a <code>grid_ROI_table</code> table (argument propagated from <code>import_ome_zarr</code>).</p> <p> TYPE: <code>bool</code> </p> <code>update_omero_metadata</code> <p>Whether to update Omero-channels metadata (argument propagated from <code>import_ome_zarr</code>).</p> <p> TYPE: <code>bool</code> </p> <code>grid_YX_shape</code> <p>YX shape of the ROI grid (it must be not <code>None</code>, if <code>add_grid_ROI_table=True</code>.</p> <p> TYPE: <code>Optional[tuple[int, int]]</code> DEFAULT: <code>None</code> </p> Source code in <code>fractal_tasks_core/tasks/import_ome_zarr.py</code> <pre><code>def _process_single_image(\n    image_path: str,\n    add_image_ROI_table: bool,\n    add_grid_ROI_table: bool,\n    update_omero_metadata: bool,\n    *,\n    grid_YX_shape: Optional[tuple[int, int]] = None,\n    overwrite: bool = False,\n) -&gt; dict[str, str]:\n\"\"\"\n    Validate OME-NGFF metadata and optionally generate ROI tables.\n\n    This task:\n\n    1. Validates OME-NGFF image metadata, via `NgffImageMeta`;\n    2. Optionally generates and writes two ROI tables;\n    3. Optionally update OME-NGFF omero metadata.\n    4. Returns dataset types\n\n    Args:\n        image_path: Absolute path to the image Zarr group.\n        add_image_ROI_table: Whether to add a `image_ROI_table` table\n            (argument propagated from `import_ome_zarr`).\n        add_grid_ROI_table: Whether to add a `grid_ROI_table` table (argument\n            propagated from `import_ome_zarr`).\n        update_omero_metadata: Whether to update Omero-channels metadata\n            (argument propagated from `import_ome_zarr`).\n        grid_YX_shape: YX shape of the ROI grid (it must be not `None`, if\n            `add_grid_ROI_table=True`.\n    \"\"\"\n\n    # Note from zarr docs: `r+` means read/write (must exist)\n    image_group = zarr.open_group(image_path, mode=\"r+\")\n    image_meta = NgffImageMeta(**image_group.attrs.asdict())\n\n    # Preliminary checks\n    if add_grid_ROI_table and (grid_YX_shape is None):\n        raise ValueError(\n            f\"_process_single_image called with {add_grid_ROI_table=}, \"\n            f\"but {grid_YX_shape=}.\"\n        )\n\n    pixels_ZYX = image_meta.get_pixel_sizes_zyx(level=0)\n\n    # Read zarr array\n    dataset_subpath = image_meta.datasets[0].path\n    array = da.from_zarr(f\"{image_path}/{dataset_subpath}\")\n\n    # Prepare image_ROI_table and write it into the zarr group\n    if add_image_ROI_table:\n        image_ROI_table = get_single_image_ROI(array.shape, pixels_ZYX)\n        write_table(\n            image_group,\n            \"image_ROI_table\",\n            image_ROI_table,\n            overwrite=overwrite,\n            table_attrs={\"type\": \"roi_table\"},\n        )\n\n    # Prepare grid_ROI_table and write it into the zarr group\n    if add_grid_ROI_table:\n        grid_ROI_table = get_image_grid_ROIs(\n            array.shape,\n            pixels_ZYX,\n            grid_YX_shape,\n        )\n        write_table(\n            image_group,\n            \"grid_ROI_table\",\n            grid_ROI_table,\n            overwrite=overwrite,\n            table_attrs={\"type\": \"roi_table\"},\n        )\n\n    # Update Omero-channels metadata\n    if update_omero_metadata:\n        # Extract number of channels from zarr array\n        try:\n            channel_axis_index = image_meta.axes_names.index(\"c\")\n        except ValueError:\n            logger.error(f\"Existing axes: {image_meta.axes_names}\")\n            msg = (\n                \"OME-Zarrs with no channel axis are not currently \"\n                \"supported in fractal-tasks-core. Upcoming flexibility \"\n                \"improvements are tracked in https://github.com/\"\n                \"fractal-analytics-platform/fractal-tasks-core/issues/150.\"\n            )\n            logger.error(msg)\n            raise NotImplementedError(msg)\n        logger.info(f\"Existing axes: {image_meta.axes_names}\")\n        logger.info(f\"Channel-axis index: {channel_axis_index}\")\n        num_channels_zarr = array.shape[channel_axis_index]\n        logger.info(\n            f\"{num_channels_zarr} channel(s) found in Zarr array \"\n            f\"at {image_path}/{dataset_subpath}\"\n        )\n        # Update or create omero channels metadata\n        old_omero = image_group.attrs.get(\"omero\", {})\n        old_channels = old_omero.get(\"channels\", [])\n        if len(old_channels) &gt; 0:\n            logger.info(\n                f\"{len(old_channels)} channel(s) found in NGFF omero metadata\"\n            )\n            if len(old_channels) != num_channels_zarr:\n                error_msg = (\n                    \"Channels-number mismatch: Number of channels in the \"\n                    f\"zarr array ({num_channels_zarr}) differs from number \"\n                    \"of channels listed in NGFF omero metadata \"\n                    f\"({len(old_channels)}).\"\n                )\n                logging.error(error_msg)\n                raise ValueError(error_msg)\n        else:\n            old_channels = [{} for ind in range(num_channels_zarr)]\n        new_channels = update_omero_channels(old_channels)\n        new_omero = old_omero.copy()\n        new_omero[\"channels\"] = new_channels\n        image_group.attrs.update(omero=new_omero)\n\n    # Determine image types:\n    # Later: also provide a has_T flag.\n    # TODO: Potentially also load acquisition metadata if available in a Zarr\n    is_3D = False\n    if \"z\" in image_meta.axes_names:\n        if array.shape[-3] &gt; 1:\n            is_3D = True\n    types = dict(is_3D=is_3D)\n    return types\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/import_ome_zarr/#fractal_tasks_core.tasks.import_ome_zarr.import_ome_zarr","title":"<code>import_ome_zarr(*, zarr_dir, zarr_name, update_omero_metadata=True, add_image_ROI_table=True, add_grid_ROI_table=True, grid_y_shape=2, grid_x_shape=2, overwrite=False)</code>","text":"<p>Import a single OME-Zarr into Fractal.</p> <p>The single OME-Zarr can be a full OME-Zarr HCS plate or an individual OME-Zarr image. The image needs to be in the zarr_dir as specified by the dataset. The current version of this task:</p> <ol> <li>Creates the appropriate components-related metadata, needed for    processing an existing OME-Zarr through Fractal.</li> <li>Optionally adds new ROI tables to the existing OME-Zarr.</li> </ol> PARAMETER DESCRIPTION <code>zarr_dir</code> <p>path of the directory where the new OME-Zarrs will be created. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>zarr_name</code> <p>The OME-Zarr name, without its parent folder. The parent folder is provided by zarr_dir; e.g. <code>zarr_name=\"array.zarr\"</code>, if the OME-Zarr path is in <code>/zarr_dir/array.zarr</code>.</p> <p> TYPE: <code>str</code> </p> <code>add_image_ROI_table</code> <p>Whether to add a <code>image_ROI_table</code> table to each image, with a single ROI covering the whole image.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>add_grid_ROI_table</code> <p>Whether to add a <code>grid_ROI_table</code> table to each image, with the image split into a rectangular grid of ROIs.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>grid_y_shape</code> <p>Y shape of the ROI grid in <code>grid_ROI_table</code>.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>grid_x_shape</code> <p>X shape of the ROI grid in <code>grid_ROI_table</code>.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>update_omero_metadata</code> <p>Whether to update Omero-channels metadata, to make them Fractal-compatible.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>overwrite</code> <p>Whether new ROI tables (added when <code>add_image_ROI_table</code> and/or <code>add_grid_ROI_table</code> are <code>True</code>) can overwite existing ones.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>fractal_tasks_core/tasks/import_ome_zarr.py</code> <pre><code>@validate_call\ndef import_ome_zarr(\n    *,\n    # Fractal parameters\n    zarr_dir: str,\n    # Core parameters\n    zarr_name: str,\n    update_omero_metadata: bool = True,\n    add_image_ROI_table: bool = True,\n    add_grid_ROI_table: bool = True,\n    # Advanced parameters\n    grid_y_shape: int = 2,\n    grid_x_shape: int = 2,\n    overwrite: bool = False,\n) -&gt; dict[str, Any]:\n\"\"\"\n    Import a single OME-Zarr into Fractal.\n\n    The single OME-Zarr can be a full OME-Zarr HCS plate or an individual\n    OME-Zarr image. The image needs to be in the zarr_dir as specified by the\n    dataset. The current version of this task:\n\n    1. Creates the appropriate components-related metadata, needed for\n       processing an existing OME-Zarr through Fractal.\n    2. Optionally adds new ROI tables to the existing OME-Zarr.\n\n    Args:\n        zarr_dir: path of the directory where the new OME-Zarrs will be\n            created.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        zarr_name: The OME-Zarr name, without its parent folder. The parent\n            folder is provided by zarr_dir; e.g. `zarr_name=\"array.zarr\"`,\n            if the OME-Zarr path is in `/zarr_dir/array.zarr`.\n        add_image_ROI_table: Whether to add a `image_ROI_table` table to each\n            image, with a single ROI covering the whole image.\n        add_grid_ROI_table: Whether to add a `grid_ROI_table` table to each\n            image, with the image split into a rectangular grid of ROIs.\n        grid_y_shape: Y shape of the ROI grid in `grid_ROI_table`.\n        grid_x_shape: X shape of the ROI grid in `grid_ROI_table`.\n        update_omero_metadata: Whether to update Omero-channels metadata, to\n            make them Fractal-compatible.\n        overwrite: Whether new ROI tables (added when `add_image_ROI_table`\n            and/or `add_grid_ROI_table` are `True`) can overwite existing ones.\n    \"\"\"\n\n    zarr_path = f\"{zarr_dir.rstrip('/')}/{zarr_name}\"\n    logger.info(f\"Zarr path: {zarr_path}\")\n\n    root_group = zarr.open_group(zarr_path, mode=\"r\")\n    ngff_type = detect_ome_ngff_type(root_group)\n    grid_YX_shape = (grid_y_shape, grid_x_shape)\n\n    image_list_updates = []\n    if ngff_type == \"plate\":\n        for well in root_group.attrs[\"plate\"][\"wells\"]:\n            well_path = well[\"path\"]\n\n            well_group = zarr.open_group(zarr_path, path=well_path, mode=\"r\")\n            for image in well_group.attrs[\"well\"][\"images\"]:\n                image_path = image[\"path\"]\n                zarr_url = f\"{zarr_path}/{well_path}/{image_path}\"\n                types = _process_single_image(\n                    zarr_url,\n                    add_image_ROI_table,\n                    add_grid_ROI_table,\n                    update_omero_metadata,\n                    grid_YX_shape=grid_YX_shape,\n                    overwrite=overwrite,\n                )\n                image_list_updates.append(\n                    dict(\n                        zarr_url=zarr_url,\n                        attributes=dict(\n                            plate=zarr_name,\n                            well=well_path.replace(\"/\", \"\"),\n                        ),\n                        types=types,\n                    )\n                )\n    elif ngff_type == \"well\":\n        logger.warning(\n            \"Only OME-Zarr for plates are fully supported in Fractal; \"\n            f\"e.g. the current one ({ngff_type=}) cannot be \"\n            \"processed via the `maximum_intensity_projection` task.\"\n        )\n        for image in root_group.attrs[\"well\"][\"images\"]:\n            image_path = image[\"path\"]\n            zarr_url = f\"{zarr_path}/{image_path}\"\n            well_name = \"\".join(zarr_path.split(\"/\")[-2:])\n            types = _process_single_image(\n                zarr_url,\n                add_image_ROI_table,\n                add_grid_ROI_table,\n                update_omero_metadata,\n                grid_YX_shape=grid_YX_shape,\n                overwrite=overwrite,\n            )\n            image_list_updates.append(\n                dict(\n                    zarr_url=zarr_url,\n                    attributes=dict(\n                        well=well_name,\n                    ),\n                    types=types,\n                )\n            )\n    elif ngff_type == \"image\":\n        logger.warning(\n            \"Only OME-Zarr for plates are fully supported in Fractal; \"\n            f\"e.g. the current one ({ngff_type=}) cannot be \"\n            \"processed via the `maximum_intensity_projection` task.\"\n        )\n        zarr_url = zarr_path\n        types = _process_single_image(\n            zarr_url,\n            add_image_ROI_table,\n            add_grid_ROI_table,\n            update_omero_metadata,\n            grid_YX_shape=grid_YX_shape,\n            overwrite=overwrite,\n        )\n        image_list_updates.append(\n            dict(\n                zarr_url=zarr_url,\n                types=types,\n            )\n        )\n\n    image_list_changes = dict(image_list_updates=image_list_updates)\n    return image_list_changes\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/init_group_by_well_for_multiplexing/","title":"init_group_by_well_for_multiplexing","text":"<p>Applies the multiplexing translation to all ROI tables</p>"},{"location":"reference/fractal_tasks_core/tasks/init_group_by_well_for_multiplexing/#fractal_tasks_core.tasks.init_group_by_well_for_multiplexing.init_group_by_well_for_multiplexing","title":"<code>init_group_by_well_for_multiplexing(*, zarr_urls, zarr_dir, reference_acquisition=0)</code>","text":"<p>Finds images for all acquisitions per well.</p> <p>Returns the parallelization_list to run <code>find_registration_consensus</code>.</p> PARAMETER DESCRIPTION <code>zarr_urls</code> <p>List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>list[str]</code> </p> <code>zarr_dir</code> <p>path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>reference_acquisition</code> <p>Which acquisition to register against. Uses the OME-NGFF HCS well metadata acquisition keys to find the reference acquisition.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>fractal_tasks_core/tasks/init_group_by_well_for_multiplexing.py</code> <pre><code>@validate_call\ndef init_group_by_well_for_multiplexing(\n    *,\n    # Fractal parameters\n    zarr_urls: list[str],\n    zarr_dir: str,\n    # Core parameters\n    reference_acquisition: int = 0,\n) -&gt; dict[str, list[str]]:\n\"\"\"\n    Finds images for all acquisitions per well.\n\n    Returns the parallelization_list to run `find_registration_consensus`.\n\n    Args:\n        zarr_urls: List of paths or urls to the individual OME-Zarr image to\n            be processed.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        zarr_dir: path of the directory where the new OME-Zarrs will be\n            created. Not used by this task.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        reference_acquisition: Which acquisition to register against. Uses the\n            OME-NGFF HCS well metadata acquisition keys to find the reference\n            acquisition.\n    \"\"\"\n    logger.info(\n        f\"Running `init_group_by_well_for_multiplexing` for {zarr_urls=}\"\n    )\n    image_groups = create_well_acquisition_dict(zarr_urls)\n\n    # Create the parallelization list\n    parallelization_list = []\n    for key, image_group in image_groups.items():\n        # Assert that all image groups have the reference acquisition present\n        if reference_acquisition not in image_group.keys():\n            raise ValueError(\n                f\"Registration with {reference_acquisition=} can only work if \"\n                \"all wells have the reference acquisition present. It was not \"\n                f\"found for well {key}.\"\n            )\n\n        # Create a parallelization list entry for each image group\n        zarr_url_list = []\n        for acquisition, zarr_url in image_group.items():\n            if acquisition == reference_acquisition:\n                reference_zarr_url = zarr_url\n\n            zarr_url_list.append(zarr_url)\n\n        parallelization_list.append(\n            dict(\n                zarr_url=reference_zarr_url,\n                init_args=dict(zarr_url_list=zarr_url_list),\n            )\n        )\n\n    return dict(parallelization_list=parallelization_list)\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/io_models/","title":"io_models","text":""},{"location":"reference/fractal_tasks_core/tasks/io_models/#fractal_tasks_core.tasks.io_models.ChunkSizes","title":"<code>ChunkSizes</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Chunk size settings for OME-Zarrs.</p> ATTRIBUTE DESCRIPTION <code>t</code> <p>Chunk size of time axis.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>c</code> <p>Chunk size of channel axis.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>z</code> <p>Chunk size of Z axis.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>y</code> <p>Chunk size of y axis.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>x</code> <p>Chunk size of x axis.</p> <p> TYPE: <code>Optional[int]</code> </p> Source code in <code>fractal_tasks_core/tasks/io_models.py</code> <pre><code>class ChunkSizes(BaseModel):\n\"\"\"\n    Chunk size settings for OME-Zarrs.\n\n    Attributes:\n        t: Chunk size of time axis.\n        c: Chunk size of channel axis.\n        z: Chunk size of Z axis.\n        y: Chunk size of y axis.\n        x: Chunk size of x axis.\n    \"\"\"\n\n    t: Optional[int] = None\n    c: Optional[int] = 1\n    z: Optional[int] = 10\n    y: Optional[int] = None\n    x: Optional[int] = None\n\n    def get_chunksize(\n        self, chunksize_default: Optional[Dict[str, int]] = None\n    ) -&gt; Tuple[int, ...]:\n        # Define the valid keys\n        valid_keys = {\"t\", \"c\", \"z\", \"y\", \"x\"}\n\n        # If chunksize_default is not None, check for invalid keys\n        if chunksize_default:\n            invalid_keys = set(chunksize_default.keys()) - valid_keys\n            if invalid_keys:\n                raise ValueError(\n                    f\"Invalid keys in chunksize_default: {invalid_keys}. \"\n                    f\"Only {valid_keys} are allowed.\"\n                )\n\n        # Filter and use only valid keys from chunksize_default\n        chunksize = {\n            key: chunksize_default[key]\n            for key in valid_keys\n            if chunksize_default and key in chunksize_default\n        }\n\n        # Overwrite with the values from the ChunkSizes instance if they are\n        # not None\n        for key in valid_keys:\n            if getattr(self, key) is not None:\n                chunksize[key] = getattr(self, key)\n\n        # Ensure the output tuple is ordered and matches the tczyx structure\n        ordered_keys = [\"t\", \"c\", \"z\", \"y\", \"x\"]\n        return tuple(\n            chunksize[key] for key in ordered_keys if key in chunksize\n        )\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/io_models/#fractal_tasks_core.tasks.io_models.InitArgsCellVoyager","title":"<code>InitArgsCellVoyager</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Arguments to be passed from cellvoyager converter init to compute</p> ATTRIBUTE DESCRIPTION <code>image_dir</code> <p>Directory where the raw images are found</p> <p> TYPE: <code>str</code> </p> <code>plate_prefix</code> <p>part of the image filename needed for finding the right subset of image files</p> <p> TYPE: <code>str</code> </p> <code>well_ID</code> <p>part of the image filename needed for finding the right subset of image files</p> <p> TYPE: <code>str</code> </p> <code>image_extension</code> <p>part of the image filename needed for finding the right subset of image files</p> <p> TYPE: <code>str</code> </p> <code>include_glob_patterns</code> <p>Additional glob patterns to filter the available images with.</p> <p> TYPE: <code>Optional[list[str]]</code> </p> <code>exclude_glob_patterns</code> <p>Glob patterns to exclude.</p> <p> TYPE: <code>Optional[list[str]]</code> </p> <code>acquisition</code> <p>Acquisition metadata needed for multiplexing</p> <p> TYPE: <code>Optional[int]</code> </p> Source code in <code>fractal_tasks_core/tasks/io_models.py</code> <pre><code>class InitArgsCellVoyager(BaseModel):\n\"\"\"\n    Arguments to be passed from cellvoyager converter init to compute\n\n    Attributes:\n        image_dir: Directory where the raw images are found\n        plate_prefix: part of the image filename needed for finding the\n            right subset of image files\n        well_ID: part of the image filename needed for finding the\n            right subset of image files\n        image_extension: part of the image filename needed for finding the\n            right subset of image files\n        include_glob_patterns: Additional glob patterns to filter the available\n            images with.\n        exclude_glob_patterns: Glob patterns to exclude.\n        acquisition: Acquisition metadata needed for multiplexing\n    \"\"\"\n\n    image_dir: str\n    plate_prefix: str\n    well_ID: str\n    image_extension: str\n    include_glob_patterns: Optional[list[str]] = None\n    exclude_glob_patterns: Optional[list[str]] = None\n    acquisition: Optional[int] = None\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/io_models/#fractal_tasks_core.tasks.io_models.InitArgsIllumination","title":"<code>InitArgsIllumination</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Dummy model description.</p> ATTRIBUTE DESCRIPTION <code>raw_path</code> <p>dummy attribute description.</p> <p> TYPE: <code>str</code> </p> <code>subsets</code> <p>dummy attribute description.</p> <p> TYPE: <code>dict[Literal['C_index'], int]</code> </p> Source code in <code>fractal_tasks_core/tasks/io_models.py</code> <pre><code>class InitArgsIllumination(BaseModel):\n\"\"\"\n    Dummy model description.\n\n    Attributes:\n        raw_path: dummy attribute description.\n        subsets: dummy attribute description.\n    \"\"\"\n\n    raw_path: str\n    subsets: dict[Literal[\"C_index\"], int] = Field(default_factory=dict)\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/io_models/#fractal_tasks_core.tasks.io_models.InitArgsMIP","title":"<code>InitArgsMIP</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Init Args for MIP task.</p> ATTRIBUTE DESCRIPTION <code>origin_url</code> <p>Path to the zarr_url with the 3D data</p> <p> TYPE: <code>str</code> </p> <code>method</code> <p>Projection method to be used. See <code>DaskProjectionMethod</code></p> <p> TYPE: <code>str</code> </p> <code>overwrite</code> <p>If <code>True</code>, overwrite the task output.</p> <p> TYPE: <code>bool</code> </p> <code>new_plate_name</code> <p>Name of the new OME-Zarr HCS plate</p> <p> TYPE: <code>str</code> </p> Source code in <code>fractal_tasks_core/tasks/io_models.py</code> <pre><code>class InitArgsMIP(BaseModel):\n\"\"\"\n    Init Args for MIP task.\n\n    Attributes:\n        origin_url: Path to the zarr_url with the 3D data\n        method: Projection method to be used. See `DaskProjectionMethod`\n        overwrite: If `True`, overwrite the task output.\n        new_plate_name: Name of the new OME-Zarr HCS plate\n    \"\"\"\n\n    origin_url: str\n    method: str\n    overwrite: bool\n    new_plate_name: str\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/io_models/#fractal_tasks_core.tasks.io_models.InitArgsRegistration","title":"<code>InitArgsRegistration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Registration init args.</p> <p>Passed from <code>image_based_registration_hcs_init</code> to <code>calculate_registration_image_based</code>.</p> ATTRIBUTE DESCRIPTION <code>reference_zarr_url</code> <p>zarr_url for the reference image</p> <p> TYPE: <code>str</code> </p> Source code in <code>fractal_tasks_core/tasks/io_models.py</code> <pre><code>class InitArgsRegistration(BaseModel):\n\"\"\"\n    Registration init args.\n\n    Passed from `image_based_registration_hcs_init` to\n    `calculate_registration_image_based`.\n\n    Attributes:\n        reference_zarr_url: zarr_url for the reference image\n    \"\"\"\n\n    reference_zarr_url: str\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/io_models/#fractal_tasks_core.tasks.io_models.InitArgsRegistrationConsensus","title":"<code>InitArgsRegistrationConsensus</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Registration consensus init args.</p> <p>Provides the list of zarr_urls for all acquisitions for a given well</p> ATTRIBUTE DESCRIPTION <code>zarr_url_list</code> <p>List of zarr_urls for all the OME-Zarr images in the well.</p> <p> TYPE: <code>list[str]</code> </p> Source code in <code>fractal_tasks_core/tasks/io_models.py</code> <pre><code>class InitArgsRegistrationConsensus(BaseModel):\n\"\"\"\n    Registration consensus init args.\n\n    Provides the list of zarr_urls for all acquisitions for a given well\n\n    Attributes:\n        zarr_url_list: List of zarr_urls for all the OME-Zarr images in the\n            well.\n    \"\"\"\n\n    zarr_url_list: list[str]\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/io_models/#fractal_tasks_core.tasks.io_models.MultiplexingAcquisition","title":"<code>MultiplexingAcquisition</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Input class for Multiplexing Cellvoyager converter</p> ATTRIBUTE DESCRIPTION <code>image_dir</code> <p>Path to the folder that contains the Cellvoyager image files for that acquisition and the MeasurementData &amp; MeasurementDetail metadata files.</p> <p> TYPE: <code>str</code> </p> <code>allowed_channels</code> <p>A list of <code>OmeroChannel</code> objects, where each channel must include the <code>wavelength_id</code> attribute and where the <code>wavelength_id</code> values must be unique across the list.</p> <p> TYPE: <code>list[OmeroChannel]</code> </p> Source code in <code>fractal_tasks_core/tasks/io_models.py</code> <pre><code>class MultiplexingAcquisition(BaseModel):\n\"\"\"\n    Input class for Multiplexing Cellvoyager converter\n\n    Attributes:\n        image_dir: Path to the folder that contains the Cellvoyager image\n            files for that acquisition and the MeasurementData &amp;\n            MeasurementDetail metadata files.\n        allowed_channels: A list of `OmeroChannel` objects, where each channel\n            must include the `wavelength_id` attribute and where the\n            `wavelength_id` values must be unique across the list.\n    \"\"\"\n\n    image_dir: str\n    allowed_channels: list[OmeroChannel]\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/io_models/#fractal_tasks_core.tasks.io_models.NapariWorkflowsInput","title":"<code>NapariWorkflowsInput</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A value of the <code>input_specs</code> argument in <code>napari_workflows_wrapper</code>.</p> ATTRIBUTE DESCRIPTION <code>type</code> <p>Input type (either <code>image</code> or <code>label</code>).</p> <p> TYPE: <code>Literal['image', 'label']</code> </p> <code>label_name</code> <p>Label name (for label inputs only).</p> <p> TYPE: <code>Optional[str]</code> </p> <code>channel</code> <p><code>ChannelInputModel</code> object (for image inputs only).</p> <p> TYPE: <code>Optional[ChannelInputModel]</code> </p> Source code in <code>fractal_tasks_core/tasks/io_models.py</code> <pre><code>class NapariWorkflowsInput(BaseModel):\n\"\"\"\n    A value of the `input_specs` argument in `napari_workflows_wrapper`.\n\n    Attributes:\n        type: Input type (either `image` or `label`).\n        label_name: Label name (for label inputs only).\n        channel: `ChannelInputModel` object (for image inputs only).\n    \"\"\"\n\n    type: Literal[\"image\", \"label\"]\n    label_name: Optional[str] = None\n    channel: Optional[ChannelInputModel] = None\n\n    @model_validator(mode=\"after\")\n    def label_name_is_present(self: Self) -&gt; Self:\n\"\"\"\n        Check that label inputs have `label_name` set.\n        \"\"\"\n        label_name = self.label_name\n        _type = self.type\n        if _type == \"label\" and label_name is None:\n            raise ValueError(\n                f\"Input item has type={_type} but label_name={label_name}.\"\n            )\n        return self\n\n    @model_validator(mode=\"after\")\n    def channel_is_present(self: Self) -&gt; Self:\n\"\"\"\n        Check that image inputs have `channel` set.\n        \"\"\"\n        _type = self.type\n        channel = self.channel\n        if _type == \"image\" and channel is None:\n            raise ValueError(\n                f\"Input item has type={_type} but channel={channel}.\"\n            )\n        return self\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/io_models/#fractal_tasks_core.tasks.io_models.NapariWorkflowsInput.channel_is_present","title":"<code>channel_is_present()</code>","text":"<p>Check that image inputs have <code>channel</code> set.</p> Source code in <code>fractal_tasks_core/tasks/io_models.py</code> <pre><code>@model_validator(mode=\"after\")\ndef channel_is_present(self: Self) -&gt; Self:\n\"\"\"\n    Check that image inputs have `channel` set.\n    \"\"\"\n    _type = self.type\n    channel = self.channel\n    if _type == \"image\" and channel is None:\n        raise ValueError(\n            f\"Input item has type={_type} but channel={channel}.\"\n        )\n    return self\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/io_models/#fractal_tasks_core.tasks.io_models.NapariWorkflowsInput.label_name_is_present","title":"<code>label_name_is_present()</code>","text":"<p>Check that label inputs have <code>label_name</code> set.</p> Source code in <code>fractal_tasks_core/tasks/io_models.py</code> <pre><code>@model_validator(mode=\"after\")\ndef label_name_is_present(self: Self) -&gt; Self:\n\"\"\"\n    Check that label inputs have `label_name` set.\n    \"\"\"\n    label_name = self.label_name\n    _type = self.type\n    if _type == \"label\" and label_name is None:\n        raise ValueError(\n            f\"Input item has type={_type} but label_name={label_name}.\"\n        )\n    return self\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/io_models/#fractal_tasks_core.tasks.io_models.NapariWorkflowsOutput","title":"<code>NapariWorkflowsOutput</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A value of the <code>output_specs</code> argument in <code>napari_workflows_wrapper</code>.</p> ATTRIBUTE DESCRIPTION <code>type</code> <p>Output type (either <code>label</code> or <code>dataframe</code>).</p> <p> TYPE: <code>Literal['label', 'dataframe']</code> </p> <code>label_name</code> <p>Label name (for label outputs, it is used as the name of the label; for dataframe outputs, it is used to fill the <code>region[\"path\"]</code> field).</p> <p> TYPE: <code>str</code> </p> <code>table_name</code> <p>Table name (for dataframe outputs only).</p> <p> TYPE: <code>Optional[str]</code> </p> Source code in <code>fractal_tasks_core/tasks/io_models.py</code> <pre><code>class NapariWorkflowsOutput(BaseModel):\n\"\"\"\n    A value of the `output_specs` argument in `napari_workflows_wrapper`.\n\n    Attributes:\n        type: Output type (either `label` or `dataframe`).\n        label_name: Label name (for label outputs, it is used as the name of\n            the label; for dataframe outputs, it is used to fill the\n            `region[\"path\"]` field).\n        table_name: Table name (for dataframe outputs only).\n    \"\"\"\n\n    type: Literal[\"label\", \"dataframe\"]\n    label_name: str\n    table_name: Optional[str] = None\n\n    @model_validator(mode=\"after\")\n    def table_name_only_for_dataframe_type(self: Self) -&gt; Self:\n\"\"\"\n        Check that table_name is set only for dataframe outputs.\n        \"\"\"\n        _type = self.type\n        _table_name = self.table_name\n        if (_type == \"dataframe\" and (not _table_name)) or (\n            _type != \"dataframe\" and _table_name\n        ):\n            raise ValueError(\n                f\"Output item has type={_type} but table_name={_table_name}.\"\n            )\n        return self\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/io_models/#fractal_tasks_core.tasks.io_models.NapariWorkflowsOutput.table_name_only_for_dataframe_type","title":"<code>table_name_only_for_dataframe_type()</code>","text":"<p>Check that table_name is set only for dataframe outputs.</p> Source code in <code>fractal_tasks_core/tasks/io_models.py</code> <pre><code>@model_validator(mode=\"after\")\ndef table_name_only_for_dataframe_type(self: Self) -&gt; Self:\n\"\"\"\n    Check that table_name is set only for dataframe outputs.\n    \"\"\"\n    _type = self.type\n    _table_name = self.table_name\n    if (_type == \"dataframe\" and (not _table_name)) or (\n        _type != \"dataframe\" and _table_name\n    ):\n        raise ValueError(\n            f\"Output item has type={_type} but table_name={_table_name}.\"\n        )\n    return self\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/napari_workflows_wrapper/","title":"napari_workflows_wrapper","text":"<p>Wrapper of napari-workflows.</p>"},{"location":"reference/fractal_tasks_core/tasks/napari_workflows_wrapper/#fractal_tasks_core.tasks.napari_workflows_wrapper.OutOfTaskScopeError","title":"<code>OutOfTaskScopeError</code>","text":"<p>               Bases: <code>NotImplementedError</code></p> <p>Encapsulates features that are out-of-scope for the current wrapper task.</p> Source code in <code>fractal_tasks_core/tasks/napari_workflows_wrapper.py</code> <pre><code>class OutOfTaskScopeError(NotImplementedError):\n\"\"\"\n    Encapsulates features that are out-of-scope for the current wrapper task.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/napari_workflows_wrapper/#fractal_tasks_core.tasks.napari_workflows_wrapper.napari_workflows_wrapper","title":"<code>napari_workflows_wrapper(*, zarr_url, workflow_file, input_specs, output_specs, input_ROI_table='FOV_ROI_table', level=0, relabeling=True, expected_dimensions=3, overwrite=True)</code>","text":"<p>Run a napari-workflow on the ROIs of a single OME-NGFF image.</p> <p>This task takes images and labels and runs a napari-workflow on them that can produce a label and tables as output.</p> <p>Examples of allowed entries for <code>input_specs</code> and <code>output_specs</code>:</p> <pre><code>input_specs = {\n    \"in_1\": {\"type\": \"image\", \"channel\": {\"wavelength_id\": \"A01_C02\"}},\n    \"in_2\": {\"type\": \"image\", \"channel\": {\"label\": \"DAPI\"}},\n    \"in_3\": {\"type\": \"label\", \"label_name\": \"label_DAPI\"},\n}\n\noutput_specs = {\n    \"out_1\": {\"type\": \"label\", \"label_name\": \"label_DAPI_new\"},\n    \"out_2\": {\"type\": \"dataframe\", \"table_name\": \"measurements\"},\n}\n</code></pre> PARAMETER DESCRIPTION <code>zarr_url</code> <p>Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>workflow_file</code> <p>Absolute path to napari-workflows YAML file</p> <p> TYPE: <code>str</code> </p> <code>input_specs</code> <p>A dictionary of <code>NapariWorkflowsInput</code> values.</p> <p> TYPE: <code>dict[str, NapariWorkflowsInput]</code> </p> <code>output_specs</code> <p>A dictionary of <code>NapariWorkflowsOutput</code> values.</p> <p> TYPE: <code>dict[str, NapariWorkflowsOutput]</code> </p> <code>input_ROI_table</code> <p>Name of the ROI table over which the task loops to apply napari workflows. Examples: <code>FOV_ROI_table</code> =&gt; loop over the field of views; <code>organoid_ROI_table</code> =&gt; loop over the organoid ROI table (generated by another task); <code>well_ROI_table</code> =&gt; process the whole well as one image.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'FOV_ROI_table'</code> </p> <code>level</code> <p>Pyramid level of the image to be used as input for napari-workflows. Choose <code>0</code> to process at full resolution. Levels &gt; 0 are currently only supported for workflows that only have intensity images as input and only produce a label images as output.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>relabeling</code> <p>If <code>True</code>, apply relabeling so that label values are unique across all ROIs in the well.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>expected_dimensions</code> <p>Expected dimensions (either <code>2</code> or <code>3</code>). Useful when loading 2D images that are stored in a 3D array with shape <code>(1, size_x, size_y)</code> [which is the default way Fractal stores 2D images], but you want to make sure the napari workflow gets a 2D array to process. Also useful to set to <code>2</code> when loading a 2D OME-Zarr that is saved as <code>(size_x, size_y)</code>.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> <code>overwrite</code> <p>If <code>True</code>, overwrite the task output.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>fractal_tasks_core/tasks/napari_workflows_wrapper.py</code> <pre><code>@validate_call\ndef napari_workflows_wrapper(\n    *,\n    # Fractal parameters\n    zarr_url: str,\n    # Core parameters\n    workflow_file: str,\n    input_specs: dict[str, NapariWorkflowsInput],\n    output_specs: dict[str, NapariWorkflowsOutput],\n    input_ROI_table: str = \"FOV_ROI_table\",\n    level: int = 0,\n    # Advanced parameters\n    relabeling: bool = True,\n    expected_dimensions: int = 3,\n    overwrite: bool = True,\n):\n\"\"\"\n    Run a napari-workflow on the ROIs of a single OME-NGFF image.\n\n    This task takes images and labels and runs a napari-workflow on them that\n    can produce a label and tables as output.\n\n    Examples of allowed entries for `input_specs` and `output_specs`:\n\n    ```\n    input_specs = {\n        \"in_1\": {\"type\": \"image\", \"channel\": {\"wavelength_id\": \"A01_C02\"}},\n        \"in_2\": {\"type\": \"image\", \"channel\": {\"label\": \"DAPI\"}},\n        \"in_3\": {\"type\": \"label\", \"label_name\": \"label_DAPI\"},\n    }\n\n    output_specs = {\n        \"out_1\": {\"type\": \"label\", \"label_name\": \"label_DAPI_new\"},\n        \"out_2\": {\"type\": \"dataframe\", \"table_name\": \"measurements\"},\n    }\n    ```\n\n    Args:\n        zarr_url: Path or url to the individual OME-Zarr image to be processed.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        workflow_file: Absolute path to napari-workflows YAML file\n        input_specs: A dictionary of `NapariWorkflowsInput` values.\n        output_specs: A dictionary of `NapariWorkflowsOutput` values.\n        input_ROI_table: Name of the ROI table over which the task loops to\n            apply napari workflows.\n            Examples:\n            `FOV_ROI_table`\n            =&gt; loop over the field of views;\n            `organoid_ROI_table`\n            =&gt; loop over the organoid ROI table (generated by another task);\n            `well_ROI_table`\n            =&gt; process the whole well as one image.\n        level: Pyramid level of the image to be used as input for\n            napari-workflows. Choose `0` to process at full resolution.\n            Levels &gt; 0 are currently only supported for workflows that only\n            have intensity images as input and only produce a label images as\n            output.\n        relabeling: If `True`, apply relabeling so that label values are\n            unique across all ROIs in the well.\n        expected_dimensions: Expected dimensions (either `2` or `3`). Useful\n            when loading 2D images that are stored in a 3D array with shape\n            `(1, size_x, size_y)` [which is the default way Fractal stores 2D\n            images], but you want to make sure the napari workflow gets a 2D\n            array to process. Also useful to set to `2` when loading a 2D\n            OME-Zarr that is saved as `(size_x, size_y)`.\n        overwrite: If `True`, overwrite the task output.\n    \"\"\"\n    wf: napari_workflows.Worfklow = load_workflow(workflow_file)\n    logger.info(f\"Loaded workflow from {workflow_file}\")\n\n    # Validation of input/output specs\n    if not (set(wf.leafs()) &lt;= set(output_specs.keys())):\n        msg = f\"Some item of {wf.leafs()=} is not part of {output_specs=}.\"\n        logger.warning(msg)\n    if not (set(wf.roots()) &lt;= set(input_specs.keys())):\n        msg = f\"Some item of {wf.roots()=} is not part of {input_specs=}.\"\n        logger.error(msg)\n        raise ValueError(msg)\n    list_outputs = sorted(output_specs.keys())\n\n    # Characterization of workflow and scope restriction\n    input_types = [in_params.type for (name, in_params) in input_specs.items()]\n    output_types = [\n        out_params.type for (name, out_params) in output_specs.items()\n    ]\n    are_inputs_all_images = set(input_types) == {\"image\"}\n    are_outputs_all_labels = set(output_types) == {\"label\"}\n    are_outputs_all_dataframes = set(output_types) == {\"dataframe\"}\n    is_labeling_workflow = are_inputs_all_images and are_outputs_all_labels\n    is_measurement_only_workflow = are_outputs_all_dataframes\n    # Level-related constraint\n    logger.info(f\"This workflow acts at {level=}\")\n    logger.info(\n        f\"Is the current workflow a labeling one? {is_labeling_workflow}\"\n    )\n    if level &gt; 0 and not is_labeling_workflow:\n        msg = (\n            f\"{level=}&gt;0 is currently only accepted for labeling workflows, \"\n            \"i.e. those going from image(s) to label(s)\"\n        )\n        logger.error(msg)\n        raise OutOfTaskScopeError(msg)\n    # Relabeling-related (soft) constraint\n    if is_measurement_only_workflow and relabeling:\n        logger.warning(\n            \"This is a measurement-output-only workflow, setting \"\n            \"relabeling=False.\"\n        )\n        relabeling = False\n    if relabeling:\n        max_label_for_relabeling = 0\n\n    label_dtype = np.uint32\n\n    # Read ROI table\n    ROI_table = ad.read_zarr(f\"{zarr_url}/tables/{input_ROI_table}\")\n\n    # Load image metadata\n    ngff_image_meta = load_NgffImageMeta(zarr_url)\n    num_levels = ngff_image_meta.num_levels\n    coarsening_xy = ngff_image_meta.coarsening_xy\n\n    # Read pixel sizes from zattrs file\n    full_res_pxl_sizes_zyx = ngff_image_meta.get_pixel_sizes_zyx(level=0)\n\n    # Create list of indices for 3D FOVs spanning the entire Z direction\n    list_indices = convert_ROI_table_to_indices(\n        ROI_table,\n        level=level,\n        coarsening_xy=coarsening_xy,\n        full_res_pxl_sizes_zyx=full_res_pxl_sizes_zyx,\n    )\n    check_valid_ROI_indices(list_indices, input_ROI_table)\n    num_ROIs = len(list_indices)\n    logger.info(\n        f\"Completed reading ROI table {input_ROI_table},\"\n        f\" found {num_ROIs} ROIs.\"\n    )\n\n    # Input preparation: \"image\" type\n    image_inputs = [\n        (name, in_params)\n        for (name, in_params) in input_specs.items()\n        if in_params.type == \"image\"\n    ]\n    input_image_arrays = {}\n    if image_inputs:\n        img_array = da.from_zarr(f\"{zarr_url}/{level}\")\n        # Loop over image inputs and assign corresponding channel of the image\n        for name, params in image_inputs:\n            channel = get_channel_from_image_zarr(\n                image_zarr_path=zarr_url,\n                wavelength_id=params.channel.wavelength_id,\n                label=params.channel.label,\n            )\n            channel_index = channel.index\n            input_image_arrays[name] = img_array[channel_index]\n\n            # Handle dimensions\n            shape = input_image_arrays[name].shape\n            if expected_dimensions == 3 and shape[0] == 1:\n                logger.warning(\n                    f\"Input {name} has shape {shape} \"\n                    f\"but {expected_dimensions=}\"\n                )\n            if expected_dimensions == 2:\n                if len(shape) == 2:\n                    # We already load the data as a 2D array\n                    pass\n                elif shape[0] == 1:\n                    input_image_arrays[name] = input_image_arrays[name][\n                        0, :, :\n                    ]\n                else:\n                    msg = (\n                        f\"Input {name} has shape {shape} \"\n                        f\"but {expected_dimensions=}\"\n                    )\n                    logger.error(msg)\n                    raise ValueError(msg)\n            logger.info(f\"Prepared input with {name=} and {params=}\")\n        logger.info(f\"{input_image_arrays=}\")\n\n    # Input preparation: \"label\" type\n    label_inputs = [\n        (name, in_params)\n        for (name, in_params) in input_specs.items()\n        if in_params.type == \"label\"\n    ]\n    if label_inputs:\n        # Set target_shape for upscaling labels\n        if not image_inputs:\n            logger.warning(\n                f\"{len(label_inputs)=} but num_image_inputs=0. \"\n                \"Label array(s) will not be upscaled.\"\n            )\n            upscale_labels = False\n        else:\n            target_shape = list(input_image_arrays.values())[0].shape\n            upscale_labels = True\n        # Loop over label inputs and load corresponding (upscaled) image\n        input_label_arrays = {}\n        for name, params in label_inputs:\n            label_name = params.label_name\n            label_array_raw = da.from_zarr(\n                f\"{zarr_url}/labels/{label_name}/{level}\"\n            )\n            input_label_arrays[name] = label_array_raw\n\n            # Handle dimensions\n            shape = input_label_arrays[name].shape\n            if expected_dimensions == 3 and shape[0] == 1:\n                logger.warning(\n                    f\"Input {name} has shape {shape} \"\n                    f\"but {expected_dimensions=}\"\n                )\n            if expected_dimensions == 2:\n                if len(shape) == 2:\n                    # We already load the data as a 2D array\n                    pass\n                elif shape[0] == 1:\n                    input_label_arrays[name] = input_label_arrays[name][\n                        0, :, :\n                    ]\n                else:\n                    msg = (\n                        f\"Input {name} has shape {shape} \"\n                        f\"but {expected_dimensions=}\"\n                    )\n                    logger.error(msg)\n                    raise ValueError(msg)\n\n            if upscale_labels:\n                # Check that dimensionality matches the image\n                if len(input_label_arrays[name].shape) != len(target_shape):\n                    raise ValueError(\n                        f\"Label {name} has shape \"\n                        f\"{input_label_arrays[name].shape}. \"\n                        \"But the corresponding image has shape \"\n                        f\"{target_shape}. Those dimensionalities do not \"\n                        f\"match. Is {expected_dimensions=} the correct \"\n                        \"setting?\"\n                    )\n                if expected_dimensions == 3:\n                    upscaling_axes = [1, 2]\n                else:\n                    upscaling_axes = [0, 1]\n                input_label_arrays[name] = upscale_array(\n                    array=input_label_arrays[name],\n                    target_shape=target_shape,\n                    axis=upscaling_axes,\n                    pad_with_zeros=True,\n                )\n\n            logger.info(f\"Prepared input with {name=} and {params=}\")\n        logger.info(f\"{input_label_arrays=}\")\n\n    # Output preparation: \"label\" type\n    label_outputs = [\n        (name, out_params)\n        for (name, out_params) in output_specs.items()\n        if out_params.type == \"label\"\n    ]\n    if label_outputs:\n        # Preliminary scope checks\n        if len(label_outputs) &gt; 1:\n            raise OutOfTaskScopeError(\n                \"Multiple label outputs would break label-inputs-only \"\n                f\"workflows (found {len(label_outputs)=}).\"\n            )\n        if len(label_outputs) &gt; 1 and relabeling:\n            raise OutOfTaskScopeError(\n                \"Multiple label outputs would break relabeling in labeling+\"\n                f\"measurement workflows (found {len(label_outputs)=}).\"\n            )\n\n        # We only support two cases:\n        # 1. If there exist some input images, then use the first one to\n        #    determine output-label array properties\n        # 2. If there are no input images, but there are input labels, then (A)\n        #    re-load the pixel sizes and re-build ROI indices, and (B) use the\n        #    first input label to determine output-label array properties\n        if image_inputs:\n            reference_array = list(input_image_arrays.values())[0]\n        elif label_inputs:\n            reference_array = list(input_label_arrays.values())[0]\n            # Re-load pixel size, matching to the correct level\n            input_label_name = label_inputs[0][1].label_name\n            ngff_label_image_meta = load_NgffImageMeta(\n                f\"{zarr_url}/labels/{input_label_name}\"\n            )\n            full_res_pxl_sizes_zyx = ngff_label_image_meta.get_pixel_sizes_zyx(\n                level=0\n            )\n            # Create list of indices for 3D FOVs spanning the whole Z direction\n            list_indices = convert_ROI_table_to_indices(\n                ROI_table,\n                level=level,\n                coarsening_xy=coarsening_xy,\n                full_res_pxl_sizes_zyx=full_res_pxl_sizes_zyx,\n            )\n            check_valid_ROI_indices(list_indices, input_ROI_table)\n            num_ROIs = len(list_indices)\n            logger.info(\n                f\"Re-create ROI indices from ROI table {input_ROI_table}, \"\n                f\"using {full_res_pxl_sizes_zyx=}. \"\n                \"This is necessary because label-input-only workflows may \"\n                \"have label inputs that are at a different resolution and \"\n                \"are not upscaled.\"\n            )\n        else:\n            msg = (\n                \"Missing image_inputs and label_inputs, we cannot assign\"\n                \" label output properties\"\n            )\n            raise OutOfTaskScopeError(msg)\n\n        # Extract label properties from reference_array, and make sure they are\n        # for three dimensions\n        label_shape = reference_array.shape\n        label_chunksize = reference_array.chunksize\n        if len(label_shape) == 2 and len(label_chunksize) == 2:\n            if expected_dimensions == 3:\n                raise ValueError(\n                    f\"Something wrong: {label_shape=} but \"\n                    f\"{expected_dimensions=}\"\n                )\n            label_shape = (1, label_shape[0], label_shape[1])\n            label_chunksize = (1, label_chunksize[0], label_chunksize[1])\n        logger.info(f\"{label_shape=}\")\n        logger.info(f\"{label_chunksize=}\")\n\n        # Loop over label outputs and (1) set zattrs, (2) create zarr group\n        output_label_zarr_groups: dict[str, Any] = {}\n        for name, out_params in label_outputs:\n            # (1a) Rescale OME-NGFF datasets (relevant for level&gt;0)\n            if not ngff_image_meta.multiscale.axes[0].name == \"c\":\n                raise ValueError(\n                    \"Cannot set `remove_channel_axis=True` for multiscale \"\n                    f\"metadata with axes={ngff_image_meta.multiscale.axes}. \"\n                    'First axis should have name \"c\".'\n                )\n            new_datasets = rescale_datasets(\n                datasets=[\n                    ds.model_dump()\n                    for ds in ngff_image_meta.multiscale.datasets\n                ],\n                coarsening_xy=coarsening_xy,\n                reference_level=level,\n                remove_channel_axis=True,\n            )\n\n            # (1b) Prepare attrs for label group\n            label_name = out_params.label_name\n            label_attrs = {\n                \"image-label\": {\n                    \"version\": __OME_NGFF_VERSION__,\n                    \"source\": {\"image\": \"../../\"},\n                },\n                \"multiscales\": [\n                    {\n                        \"name\": label_name,\n                        \"version\": __OME_NGFF_VERSION__,\n                        \"axes\": [\n                            ax.model_dump()\n                            for ax in ngff_image_meta.multiscale.axes\n                            if ax.type != \"channel\"\n                        ],\n                        \"datasets\": new_datasets,\n                    }\n                ],\n            }\n\n            # (2) Prepare label group\n            image_group = zarr.group(zarr_url)\n            label_group = prepare_label_group(\n                image_group,\n                label_name,\n                overwrite=overwrite,\n                label_attrs=label_attrs,\n                logger=logger,\n            )\n            logger.info(\n                \"Helper function `prepare_label_group` returned \"\n                f\"{label_group=}\"\n            )\n\n            # (3) Create zarr group at level=0\n            store = zarr.storage.FSStore(f\"{zarr_url}/labels/{label_name}/0\")\n            mask_zarr = zarr.create(\n                shape=label_shape,\n                chunks=label_chunksize,\n                dtype=label_dtype,\n                store=store,\n                overwrite=overwrite,\n                dimension_separator=\"/\",\n            )\n            output_label_zarr_groups[name] = mask_zarr\n            logger.info(f\"Prepared output with {name=} and {out_params=}\")\n        logger.info(f\"{output_label_zarr_groups=}\")\n\n    # Output preparation: \"dataframe\" type\n    dataframe_outputs = [\n        (name, out_params)\n        for (name, out_params) in output_specs.items()\n        if out_params.type == \"dataframe\"\n    ]\n    output_dataframe_lists: dict[str, list] = {}\n    for name, out_params in dataframe_outputs:\n        output_dataframe_lists[name] = []\n        logger.info(f\"Prepared output with {name=} and {out_params=}\")\n        logger.info(f\"{output_dataframe_lists=}\")\n\n    #####\n\n    for i_ROI, indices in enumerate(list_indices):\n        s_z, e_z, s_y, e_y, s_x, e_x = indices[:]\n        region = (slice(s_z, e_z), slice(s_y, e_y), slice(s_x, e_x))\n\n        logger.info(f\"ROI {i_ROI+1}/{num_ROIs}: {region=}\")\n\n        # Always re-load napari worfklow\n        wf = load_workflow(workflow_file)\n\n        # Set inputs\n        for input_name in input_specs.keys():\n            input_type = input_specs[input_name].type\n\n            if input_type == \"image\":\n                wf.set(\n                    input_name,\n                    load_region(\n                        input_image_arrays[input_name],\n                        region,\n                        compute=True,\n                        return_as_3D=False,\n                    ),\n                )\n            elif input_type == \"label\":\n                wf.set(\n                    input_name,\n                    load_region(\n                        input_label_arrays[input_name],\n                        region,\n                        compute=True,\n                        return_as_3D=False,\n                    ),\n                )\n\n        # Get outputs\n        outputs = wf.get(list_outputs)\n\n        # Iterate first over dataframe outputs (to use the correct\n        # max_label_for_relabeling, if needed)\n        for ind_output, output_name in enumerate(list_outputs):\n            if output_specs[output_name].type != \"dataframe\":\n                continue\n            df = outputs[ind_output]\n            if relabeling:\n                df[\"label\"] += max_label_for_relabeling\n                logger.info(\n                    f'ROI {i_ROI+1}/{num_ROIs}: Relabeling \"{name}\" dataframe'\n                    \"output, with {max_label_for_relabeling=}\"\n                )\n\n            # Append the new-ROI dataframe to the all-ROIs list\n            output_dataframe_lists[output_name].append(df)\n\n        # After all dataframe outputs, iterate over label outputs (which\n        # actually can be only 0 or 1)\n        for ind_output, output_name in enumerate(list_outputs):\n            if output_specs[output_name].type != \"label\":\n                continue\n            mask = outputs[ind_output]\n\n            # Check dimensions\n            if len(mask.shape) != expected_dimensions:\n                msg = (\n                    f\"Output {output_name} has shape {mask.shape} \"\n                    f\"but {expected_dimensions=}\"\n                )\n                logger.error(msg)\n                raise ValueError(msg)\n            elif expected_dimensions == 2:\n                mask = np.expand_dims(mask, axis=0)\n\n            # Sanity check: issue warning for non-consecutive labels\n            unique_labels = np.unique(mask)\n            num_unique_labels_in_this_ROI = len(unique_labels)\n            if np.min(unique_labels) == 0:\n                num_unique_labels_in_this_ROI -= 1\n            num_labels_in_this_ROI = int(np.max(mask))\n            if num_labels_in_this_ROI != num_unique_labels_in_this_ROI:\n                logger.warning(\n                    f'ROI {i_ROI+1}/{num_ROIs}: \"{name}\" label output has'\n                    f\"non-consecutive labels: {num_labels_in_this_ROI=} but\"\n                    f\"{num_unique_labels_in_this_ROI=}\"\n                )\n\n            if relabeling:\n                mask[mask &gt; 0] += max_label_for_relabeling\n                logger.info(\n                    f'ROI {i_ROI+1}/{num_ROIs}: Relabeling \"{name}\" label '\n                    f\"output, with {max_label_for_relabeling=}\"\n                )\n                max_label_for_relabeling += num_labels_in_this_ROI\n                logger.info(\n                    f\"ROI {i_ROI+1}/{num_ROIs}: label-number update with \"\n                    f\"{num_labels_in_this_ROI=}; \"\n                    f\"new {max_label_for_relabeling=}\"\n                )\n\n            da.array(mask).to_zarr(\n                url=output_label_zarr_groups[output_name],\n                region=region,\n                compute=True,\n                overwrite=overwrite,\n            )\n        logger.info(f\"ROI {i_ROI+1}/{num_ROIs}: output handling complete\")\n\n    # Output handling: \"dataframe\" type (for each output, concatenate ROI\n    # dataframes, clean up, and store in a AnnData table on-disk)\n    for name, out_params in dataframe_outputs:\n        table_name = out_params.table_name\n        # Concatenate all FOV dataframes\n        list_dfs = output_dataframe_lists[name]\n        if len(list_dfs) == 0:\n            measurement_table = ad.AnnData()\n        else:\n            df_well = pd.concat(list_dfs, axis=0, ignore_index=True)\n            # Extract labels and drop them from df_well\n            labels = pd.DataFrame(df_well[\"label\"].astype(str))\n            df_well.drop(labels=[\"label\"], axis=1, inplace=True)\n            # Convert all to float (warning: some would be int, in principle)\n            measurement_dtype = np.float32\n            df_well = df_well.astype(measurement_dtype)\n            df_well.index = df_well.index.map(str)\n            # Convert to anndata\n            measurement_table = ad.AnnData(df_well, dtype=measurement_dtype)\n            measurement_table.obs = labels\n\n        # Write to zarr group\n        image_group = zarr.group(zarr_url)\n        table_attrs = dict(\n            type=\"feature_table\",\n            region=dict(path=f\"../labels/{out_params.label_name}\"),\n            instance_key=\"label\",\n        )\n        write_table(\n            image_group,\n            table_name,\n            measurement_table,\n            overwrite=overwrite,\n            table_attrs=table_attrs,\n        )\n\n    # Output handling: \"label\" type (for each output, build and write to disk\n    # pyramid of coarser levels)\n    for name, out_params in label_outputs:\n        label_name = out_params.label_name\n        build_pyramid(\n            zarrurl=f\"{zarr_url}/labels/{label_name}\",\n            overwrite=overwrite,\n            num_levels=num_levels,\n            coarsening_xy=coarsening_xy,\n            chunksize=label_chunksize,\n            aggregation_function=np.max,\n        )\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/projection/","title":"projection","text":"<p>Task for 3D-&gt;2D maximum-intensity projection.</p>"},{"location":"reference/fractal_tasks_core/tasks/projection/#fractal_tasks_core.tasks.projection._compute_new_shape","title":"<code>_compute_new_shape(source_image)</code>","text":"<p>Compute the new shape of the image after the projection.</p> <p>The new shape is the same as the original one, except for the z-axis, which is set to 1.</p> RETURNS DESCRIPTION <code>tuple[int, ...]</code> <ul> <li>new shape of the image</li> </ul> <code>int</code> <ul> <li>index of the z-axis in the original image</li> </ul> Source code in <code>fractal_tasks_core/tasks/projection.py</code> <pre><code>def _compute_new_shape(source_image: Image) -&gt; tuple[tuple[int, ...], int]:\n\"\"\"Compute the new shape of the image after the projection.\n\n    The new shape is the same as the original one,\n    except for the z-axis, which is set to 1.\n\n    returns:\n        - new shape of the image\n        - index of the z-axis in the original image\n    \"\"\"\n    on_disk_shape = source_image.shape\n    logger.info(f\"Source {on_disk_shape=}\")\n\n    on_disk_z_index = source_image.axes_mapper.get_index(\"z\")\n    if on_disk_z_index is None:\n        raise ValueError(\n            \"The input image does not contain a z-axis, \"\n            \"projection is only supported for 3D images with a z-axis.\"\n        )\n\n    dest_on_disk_shape = list(on_disk_shape)\n    dest_on_disk_shape[on_disk_z_index] = 1\n    logger.info(f\"Destination {dest_on_disk_shape=}\")\n    return tuple(dest_on_disk_shape), on_disk_z_index\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/projection/#fractal_tasks_core.tasks.projection.projection","title":"<code>projection(*, zarr_url, init_args)</code>","text":"<p>Perform intensity projection along Z axis with a chosen method.</p> <p>Note: this task stores the output in a new zarr file.</p> PARAMETER DESCRIPTION <code>zarr_url</code> <p>Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server).</p> <p> TYPE: <code>str</code> </p> <code>init_args</code> <p>Intialization arguments provided by <code>create_cellvoyager_ome_zarr_init</code>.</p> <p> TYPE: <code>InitArgsMIP</code> </p> Source code in <code>fractal_tasks_core/tasks/projection.py</code> <pre><code>@validate_call\ndef projection(\n    *,\n    # Fractal parameters\n    zarr_url: str,\n    init_args: InitArgsMIP,\n) -&gt; dict[str, Any]:\n\"\"\"\n    Perform intensity projection along Z axis with a chosen method.\n\n    Note: this task stores the output in a new zarr file.\n\n    Args:\n        zarr_url: Path or url to the individual OME-Zarr image to be processed.\n            (standard argument for Fractal tasks, managed by Fractal server).\n        init_args: Intialization arguments provided by\n            `create_cellvoyager_ome_zarr_init`.\n    \"\"\"\n    method = DaskProjectionMethod(init_args.method)\n    logger.info(f\"{init_args.origin_url=}\")\n    logger.info(f\"{zarr_url=}\")\n    logger.info(f\"{method=}\")\n\n    # Read image metadata\n    original_ome_zarr = open_ome_zarr_container(init_args.origin_url)\n    orginal_image = original_ome_zarr.get_image()\n\n    if orginal_image.is_2d or orginal_image.is_2d_time_series:\n        raise ValueError(\n            \"The input image is 2D, \"\n            \"projection is only supported for 3D images.\"\n        )\n\n    # Compute the new shape and pixel size\n    dest_on_disk_shape, z_axis_index = _compute_new_shape(orginal_image)\n\n    dest_pixel_size = orginal_image.pixel_size\n    dest_pixel_size.z = 1.0\n    logger.info(f\"New shape: {dest_on_disk_shape=}\")\n\n    # Create the new empty image\n    ome_zarr_mip = original_ome_zarr.derive_image(\n        store=zarr_url,\n        name=\"MIP\",\n        shape=dest_on_disk_shape,\n        pixel_size=dest_pixel_size,\n        overwrite=init_args.overwrite,\n        copy_labels=False,\n        copy_tables=True,\n    )\n    logger.info(f\"New Projection image created - {ome_zarr_mip=}\")\n    proj_image = ome_zarr_mip.get_image()\n\n    # Process the image\n    source_dask = orginal_image.get_array(mode=\"dask\")\n    dest_dask = method.apply(dask_array=source_dask, axis=z_axis_index)\n    dest_dask = da.expand_dims(dest_dask, axis=z_axis_index)\n    proj_image.set_array(dest_dask)\n    proj_image.consolidate()\n    # Ends\n\n    # Edit the roi tables\n    for roi_table_name in ome_zarr_mip.list_roi_tables():\n        table = ome_zarr_mip.get_table(\n            roi_table_name, check_type=\"generic_roi_table\"\n        )\n\n        for roi in table.rois():\n            roi.z = 0.0\n            roi.z_length = 1.0\n            table.add(roi, overwrite=True)\n\n        table.consolidate()\n        logger.info(f\"Table {roi_table_name} Projection done\")\n\n    # Generate image_list_updates\n    image_list_update_dict = dict(\n        image_list_updates=[\n            dict(\n                zarr_url=zarr_url,\n                origin=init_args.origin_url,\n                attributes=dict(plate=init_args.new_plate_name),\n                types=dict(is_3D=False),\n            )\n        ]\n    )\n    return image_list_update_dict\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/projection_utils/","title":"projection_utils","text":""},{"location":"reference/fractal_tasks_core/tasks/projection_utils/#fractal_tasks_core.tasks.projection_utils.DaskProjectionMethod","title":"<code>DaskProjectionMethod</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Registration method selection</p> <p>Choose which method to use for intensity projection along the Z axis.</p> ATTRIBUTE DESCRIPTION <code>MIP</code> <p>Maximum intensity projection</p> <p> </p> <code>MINIP</code> <p>Minimum intensityp projection</p> <p> </p> <code>MEANIP</code> <p>Mean intensity projection</p> <p> </p> <code>SUMIP</code> <p>Sum intensityp projection</p> <p> </p> Source code in <code>fractal_tasks_core/tasks/projection_utils.py</code> <pre><code>class DaskProjectionMethod(Enum):\n\"\"\"\n    Registration method selection\n\n    Choose which method to use for intensity projection along the Z axis.\n\n    Attributes:\n        MIP: Maximum intensity projection\n        MINIP: Minimum intensityp projection\n        MEANIP: Mean intensity projection\n        SUMIP: Sum intensityp projection\n    \"\"\"\n\n    MIP = \"mip\"\n    MINIP = \"minip\"\n    MEANIP = \"meanip\"\n    SUMIP = \"sumip\"\n\n    def apply(\n        self, dask_array: da.Array, axis: int = 0, **kwargs: Dict[str, Any]\n    ) -&gt; da.Array:\n\"\"\"\n        Apply the selected projection method to the given Dask array.\n\n        Args:\n            dask_array (dask.array.Array): The Dask array to project.\n            axis (int): The axis along which to apply the projection.\n            **kwargs: Additional keyword arguments to pass to the projection\n                method.\n\n        Returns:\n            dask.array.Array: The resulting Dask array after applying the\n                projection.\n\n        Example:\n            &gt;&gt;&gt; array = da.random.random((1000, 1000), chunks=(100, 100))\n            &gt;&gt;&gt; method = DaskProjectionMethod.MAX\n            &gt;&gt;&gt; result = method.apply(array, axis=0)\n            &gt;&gt;&gt; computed_result = result.compute()\n            &gt;&gt;&gt; print(computed_result)\n        \"\"\"\n        # Map the Enum values to the actual Dask array methods\n        method_map = {\n            DaskProjectionMethod.MIP: lambda arr, axis, **kw: arr.max(\n                axis=axis, **kw\n            ),\n            DaskProjectionMethod.MINIP: lambda arr, axis, **kw: arr.min(\n                axis=axis, **kw\n            ),\n            DaskProjectionMethod.MEANIP: mean_wrapper,\n            DaskProjectionMethod.SUMIP: safe_sum,\n        }\n        # Call the appropriate method, passing in the dask_array explicitly\n        return method_map[self](dask_array, axis=axis, **kwargs)\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/projection_utils/#fractal_tasks_core.tasks.projection_utils.DaskProjectionMethod.apply","title":"<code>apply(dask_array, axis=0, **kwargs)</code>","text":"<p>Apply the selected projection method to the given Dask array.</p> PARAMETER DESCRIPTION <code>dask_array</code> <p>The Dask array to project.</p> <p> TYPE: <code>Array</code> </p> <code>axis</code> <p>The axis along which to apply the projection.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>**kwargs</code> <p>Additional keyword arguments to pass to the projection method.</p> <p> TYPE: <code>Dict[str, Any]</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Array</code> <p>dask.array.Array: The resulting Dask array after applying the projection.</p> Example <p>array = da.random.random((1000, 1000), chunks=(100, 100)) method = DaskProjectionMethod.MAX result = method.apply(array, axis=0) computed_result = result.compute() print(computed_result)</p> Source code in <code>fractal_tasks_core/tasks/projection_utils.py</code> <pre><code>def apply(\n    self, dask_array: da.Array, axis: int = 0, **kwargs: Dict[str, Any]\n) -&gt; da.Array:\n\"\"\"\n    Apply the selected projection method to the given Dask array.\n\n    Args:\n        dask_array (dask.array.Array): The Dask array to project.\n        axis (int): The axis along which to apply the projection.\n        **kwargs: Additional keyword arguments to pass to the projection\n            method.\n\n    Returns:\n        dask.array.Array: The resulting Dask array after applying the\n            projection.\n\n    Example:\n        &gt;&gt;&gt; array = da.random.random((1000, 1000), chunks=(100, 100))\n        &gt;&gt;&gt; method = DaskProjectionMethod.MAX\n        &gt;&gt;&gt; result = method.apply(array, axis=0)\n        &gt;&gt;&gt; computed_result = result.compute()\n        &gt;&gt;&gt; print(computed_result)\n    \"\"\"\n    # Map the Enum values to the actual Dask array methods\n    method_map = {\n        DaskProjectionMethod.MIP: lambda arr, axis, **kw: arr.max(\n            axis=axis, **kw\n        ),\n        DaskProjectionMethod.MINIP: lambda arr, axis, **kw: arr.min(\n            axis=axis, **kw\n        ),\n        DaskProjectionMethod.MEANIP: mean_wrapper,\n        DaskProjectionMethod.SUMIP: safe_sum,\n    }\n    # Call the appropriate method, passing in the dask_array explicitly\n    return method_map[self](dask_array, axis=axis, **kwargs)\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/projection_utils/#fractal_tasks_core.tasks.projection_utils.mean_wrapper","title":"<code>mean_wrapper(dask_array, axis=0, **kwargs)</code>","text":"<p>Perform a da.mean on the dask_array &amp; cast it to its original dtype.</p> <p>Without casting, the result can change dtype to e.g. float64</p> PARAMETER DESCRIPTION <code>dask_array</code> <p>The input Dask array.</p> <p> TYPE: <code>Array</code> </p> <code>axis</code> <p>The axis along which to mean the array. Defaults to 0.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>**kwargs</code> <p>Additional keyword arguments passed to da.mean.</p> <p> TYPE: <code>Dict[str, Any]</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Array</code> <p>dask.array.Array: The result of the mean, cast back to the original dtype.</p> Source code in <code>fractal_tasks_core/tasks/projection_utils.py</code> <pre><code>def mean_wrapper(\n    dask_array: da.Array, axis: int = 0, **kwargs: Dict[str, Any]\n) -&gt; da.Array:\n\"\"\"\n    Perform a da.mean on the dask_array &amp; cast it to its original dtype.\n\n    Without casting, the result can change dtype to e.g. float64\n\n    Args:\n        dask_array (dask.array.Array): The input Dask array.\n        axis (int, optional): The axis along which to mean the array.\n            Defaults to 0.\n        **kwargs: Additional keyword arguments passed to da.mean.\n\n    Returns:\n        dask.array.Array: The result of the mean, cast back to the original\n            dtype.\n    \"\"\"\n    # Handle empty array\n    if any(dim == 0 for dim in dask_array.shape):\n        return dask_array\n\n    # Determine the original dtype\n    original_dtype = dask_array.dtype\n\n    # Perform the sum\n    result = da.mean(dask_array, axis=axis, **kwargs)\n\n    # Cast back to the original dtype\n    result = result.astype(original_dtype)\n\n    return result\n</code></pre>"},{"location":"reference/fractal_tasks_core/tasks/projection_utils/#fractal_tasks_core.tasks.projection_utils.safe_sum","title":"<code>safe_sum(dask_array, axis=0, **kwargs)</code>","text":"<p>Perform a safe sum on a Dask array to avoid overflow, by clipping the result of da.sum &amp; casting it to its original dtype.</p> <p>Dask.array already correctly handles promotion to uin32 or uint64 when necessary internally, but we want to ensure we clip the result.</p> PARAMETER DESCRIPTION <code>dask_array</code> <p>The input Dask array.</p> <p> TYPE: <code>Array</code> </p> <code>axis</code> <p>The axis along which to sum the array. Defaults to 0.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>**kwargs</code> <p>Additional keyword arguments passed to da.sum.</p> <p> TYPE: <code>Dict[str, Any]</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Array</code> <p>dask.array.Array: The result of the sum, safely clipped and cast back to the original dtype.</p> Source code in <code>fractal_tasks_core/tasks/projection_utils.py</code> <pre><code>def safe_sum(\n    dask_array: da.Array, axis: int = 0, **kwargs: Dict[str, Any]\n) -&gt; da.Array:\n\"\"\"\n    Perform a safe sum on a Dask array to avoid overflow, by clipping the\n    result of da.sum &amp; casting it to its original dtype.\n\n    Dask.array already correctly handles promotion to uin32 or uint64 when\n    necessary internally, but we want to ensure we clip the result.\n\n    Args:\n        dask_array (dask.array.Array): The input Dask array.\n        axis (int, optional): The axis along which to sum the array.\n            Defaults to 0.\n        **kwargs: Additional keyword arguments passed to da.sum.\n\n    Returns:\n        dask.array.Array: The result of the sum, safely clipped and cast\n            back to the original dtype.\n    \"\"\"\n    # Handle empty array\n    if any(dim == 0 for dim in dask_array.shape):\n        return dask_array\n\n    # Determine the original dtype\n    original_dtype = dask_array.dtype\n    max_value = np.iinfo(original_dtype).max\n\n    # Perform the sum\n    result = da.sum(dask_array, axis=axis, **kwargs)\n\n    # Clip the values to the maximum possible value for the original dtype\n    result = da.clip(result, 0, max_value)\n\n    # Cast back to the original dtype\n    result = result.astype(original_dtype)\n\n    return result\n</code></pre>"},{"location":"run_tasks/","title":"Run tasks","text":"<p>There are several ways to run <code>fractal-tasks-core</code> tasks:</p> <ul> <li>Within Fractal;</li> <li>From Python scripts.</li> </ul>"},{"location":"run_tasks/tasks_in_fractal/","title":"Within Fractal","text":"<p>Thanks to the package manifest and to their structure, the tasks in <code>fractal_tasks_core.tasks</code> can be run within the Fractal platform; this consists in a backend server which can be accessed by one of the two available clients (a command-line client and a web-client).</p> <p>The <code>fractal-demos</code> repository lists a set of relevant examples, including:</p> <ul> <li>How to set up a <code>fractal-server</code> instance;</li> <li>How to set up a <code>fractal-client</code> command-line client;</li> <li>How to use the command-line client to submit a series of typical workflows (based on <code>fractal-tasks-core</code> tasks) to Fractal; see folders from 01 to 10 in the <code>examples</code> folder.</li> </ul>"},{"location":"run_tasks/tasks_in_scripts/","title":"From Python scripts","text":"<p>The <code>fractal-tasks-core</code> GitHub repository includes an examples folder, listing a few examples of how to run <code>fractal-tasks-core</code> tasks from a standard Python script (instead of using the Fractal platform).</p> <p>What follows is the content of examples/README.md:</p>"},{"location":"run_tasks/tasks_in_scripts/#examples","title":"Examples","text":"<p>This <code>examples</code> folder offers a few examples of how to run <code>fractal-tasks-core</code> tasks as part of a Python script.</p>"},{"location":"run_tasks/tasks_in_scripts/#notes","title":"Notes","text":"<ul> <li>This folder is not always kept up-to-date. If you encounter any unexpected   problem, please open a new issue on the <code>fractal-tasks-core</code> GitHub repository.</li> <li>Examples from 01 to 09 are currently aligned with fractal-tasks-core 0.10.0.</li> </ul>"},{"location":"run_tasks/tasks_in_scripts/#general-instructions","title":"General instructions","text":"<p>The following instructions are valid for all examples; check the specific <code>README.md</code> files in each folder for more specific details.</p> <ol> <li> <p>Set up the correct environment via <pre><code>pip install fractal-tasks-core[fractal-tasks]\n</code></pre> (note: this can be done e.g. from a venv or from a conda environment).</p> </li> <li> <p>Download the example data from Zenodo, if necessary, via <pre><code>pip install zenodo-get\n./fetch_test_data_from_zenodo.sh\n</code></pre></p> </li> <li> <p>Enter one of the example folders, remove the <code>tmp_out</code> temporary output    folder (if present), and run one of the <code>run_workflow</code> Python scripts.</p> </li> <li> <p>View the output OME-Zarr in the <code>tmp_out</code> folder with    napari, which can be installed via <code>pip install    napari[pyqt5] napari-ome-zarr</code>.</p> </li> </ol>"},{"location":"version_updates/","title":"Release-update details","text":"<ul> <li>From version 0.13.1 to 0.14.0</li> </ul>"},{"location":"version_updates/v0_14_0/","title":"From version 0.13.1 to 0.14.0","text":""},{"location":"version_updates/v0_14_0/#package-structure","title":"Package structure","text":"<p>Version 0.14.0 includes a large refactor of the <code>fractal_tasks_core</code> package, leading to this new structure: <pre><code>fractal_tasks_core/\n\u251c\u2500\u2500 cellvoyager\n\u2502   \u251c\u2500\u2500 filenames.py\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 metadata.py\n\u251c\u2500\u2500 ngff\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 specs.py\n\u2502   \u2514\u2500\u2500 zarr_utils.py\n\u251c\u2500\u2500 roi\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 load_region.py\n\u2502   \u251c\u2500\u2500 _overlaps_common.py\n\u2502   \u251c\u2500\u2500 v1_checks.py\n\u2502   \u251c\u2500\u2500 v1_overlaps.py\n\u2502   \u2514\u2500\u2500 v1.py\n\u251c\u2500\u2500 tables\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 v1.py\n\u251c\u2500\u2500 tasks\n\u2502   \u251c\u2500\u2500 apply_registration_to_image.py\n\u2502   \u251c\u2500\u2500 apply_registration_to_ROI_tables.py\n\u2502   \u251c\u2500\u2500 calculate_registration_image_based.py\n\u2502   \u251c\u2500\u2500 cellpose_segmentation.py\n\u2502   \u251c\u2500\u2500 compress_tif.py\n\u2502   \u251c\u2500\u2500 copy_ome_zarr.py\n\u2502   \u251c\u2500\u2500 create_ome_zarr_multiplex.py\n\u2502   \u251c\u2500\u2500 create_ome_zarr.py\n\u2502   \u251c\u2500\u2500 illumination_correction.py\n\u2502   \u251c\u2500\u2500 import_ome_zarr.py\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 maximum_intensity_projection.py\n\u2502   \u251c\u2500\u2500 napari_workflows_wrapper_models.py\n\u2502   \u251c\u2500\u2500 napari_workflows_wrapper.py\n\u2502   \u251c\u2500\u2500 _utils.py\n\u2502   \u2514\u2500\u2500 yokogawa_to_ome_zarr.py\n\u251c\u2500\u2500 __FRACTAL_MANIFEST__.json\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 channels.py\n\u251c\u2500\u2500 labels.py\n\u251c\u2500\u2500 masked_loading.py\n\u251c\u2500\u2500 pyramids.py\n\u251c\u2500\u2500 upscale_array.py\n\u251c\u2500\u2500 utils.py\n\u2514\u2500\u2500 zarr_utils.py\n</code></pre></p>"},{"location":"version_updates/v0_14_0/#imports","title":"Imports","text":"<p>This refactor changed several <code>import</code> statements; find below a list (grouped by their original paths) of the old/new forms.</p> <p>\u26a0\ufe0f WARNING: This is a manually-curated list, please do open an issue if you spot an error!</p>"},{"location":"version_updates/v0_14_0/#channels","title":"Channels","text":"<pre><code>-from fractal_tasks_core.lib_channels import ChannelNotFoundError\n+from fractal_tasks_core.channels import ChannelNotFoundError\n\n-from fractal_tasks_core.lib_channels import OmeroChannel\n+from fractal_tasks_core.channels import OmeroChannel\n\n-from fractal_tasks_core.lib_channels import check_unique_wavelength_ids\n+from fractal_tasks_core.channels import check_unique_wavelength_ids\n\n-from fractal_tasks_core.lib_channels import check_well_channel_labels\n+from fractal_tasks_core.channels import check_well_channel_labels\n\n-from fractal_tasks_core.lib_channels import define_omero_channels\n+from fractal_tasks_core.channels import define_omero_channels\n\n-from fractal_tasks_core.lib_channels import get_channel_from_image_zarr\n+from fractal_tasks_core.channels import get_channel_from_image_zarr\n\n-from fractal_tasks_core.lib_channels import get_omero_channel_list\n+from fractal_tasks_core.channels import get_omero_channel_list\n\n-from fractal_tasks_core.lib_channels import update_omero_channels\n+from fractal_tasks_core.channels import update_omero_channels\n</code></pre>"},{"location":"version_updates/v0_14_0/#input-models","title":"Input models","text":"<pre><code># \u26a0\ufe0f WARNING: note the new name\n-from fractal_tasks_core.lib_input_models import Channel\n+from fractal_tasks_core.channels import ChannelInputModel\n\n-from fractal_tasks_core.lib_input_models import NapariWorkflowsInput\n+from fractal_tasks_core.tasks.napari_workflows_wrapper_models import NapariWorkflowsInput\n\n-from fractal_tasks_core.lib_input_models import NapariWorkflowsOutput\n+from fractal_tasks_core.tasks.napari_workflows_wrapper_models import NapariWorkflowsOutput\n</code></pre>"},{"location":"version_updates/v0_14_0/#cellvoyager-converter-utils","title":"CellVoyager converter utils","text":"<pre><code>-from fractal_tasks_core.lib_glob import glob_with_multiple_patterns\n+from fractal_tasks_core.cellvoyager.filenames import glob_with_multiple_patterns\n\n-from fractal_tasks_core.lib_parse_filename_metadata import parse_filename\n+from fractal_tasks_core.cellvoyager.filenames import parse_filename\n\n-from fractal_tasks_core.lib_metadata_parsing import parse_yokogawa_metadata\n+from fractal_tasks_core.cellvoyager.metadata import parse_yokogawa_metadata\n</code></pre>"},{"location":"version_updates/v0_14_0/#ngff-specs-and-validation","title":"NGFF specs and validation","text":"<pre><code>-from fractal_tasks_core.lib_ngff import detect_ome_ngff_type\n+from fractal_tasks_core.ngff import detect_ome_ngff_type\n\n-from fractal_tasks_core.lib_ngff import NgffImageMeta\n+from fractal_tasks_core.ngff import NgffImageMeta\n\n-from fractal_tasks_core.lib_ngff import load_NgffImageMeta\n+from fractal_tasks_core.ngff import load_NgffImageMeta\n\n-from fractal_tasks_core.lib_ngff import load_NgffWellMeta\n+from fractal_tasks_core.ngff import load_NgffWellMeta\n</code></pre>"},{"location":"version_updates/v0_14_0/#pyramids","title":"Pyramids","text":"<pre><code>-from fractal_tasks_core.lib_pyramid_creation import build_pyramid\n+from fractal_tasks_core.pyramids import build_pyramid\n</code></pre>"},{"location":"version_updates/v0_14_0/#regions-of-interest","title":"Regions of interest","text":"<pre><code>-from fractal_tasks_core.lib_regions_of_interest import are_ROI_table_columns_valid\n+from fractal_tasks_core.roi import are_ROI_table_columns_valid\n\n-from fractal_tasks_core.lib_regions_of_interest import array_to_bounding_box_table\n+from fractal_tasks_core.roi import array_to_bounding_box_table\n\n-from fractal_tasks_core.lib_regions_of_interest import check_valid_ROI_indices\n+from fractal_tasks_core.roi import check_valid_ROI_indices\n\n-from fractal_tasks_core.lib_regions_of_interest import convert_ROI_table_to_indices\n+from fractal_tasks_core.roi import convert_ROI_table_to_indices\n\n-from fractal_tasks_core.lib_regions_of_interest import convert_ROIs_from_3D_to_2D\n+from fractal_tasks_core.roi import convert_ROIs_from_3D_to_2D\n\n-from fractal_tasks_core.lib_regions_of_interest import convert_indices_to_regions\n+from fractal_tasks_core.roi import convert_indices_to_regions\n\n-from fractal_tasks_core.lib_regions_of_interest import empty_bounding_box_table\n+from fractal_tasks_core.roi import empty_bounding_box_table\n\n-from fractal_tasks_core.lib_ROI_overlaps import find_overlaps_in_ROI_indices\n+from fractal_tasks_core.roi import find_overlaps_in_ROI_indices\n\n-from fractal_tasks_core.lib_regions_of_interest import get_image_grid_ROIs\n+from fractal_tasks_core.roi import get_image_grid_ROIs\n\n-from fractal_tasks_core.lib_ROI_overlaps import get_overlapping_pairs_3D\n+from fractal_tasks_core.roi import get_overlapping_pairs_3D\n\n-from fractal_tasks_core.lib_regions_of_interest import get_single_image_ROI\n+from fractal_tasks_core.roi import get_single_image_ROI\n\n-from fractal_tasks_core.lib_regions_of_interest import is_ROI_table_valid\n+from fractal_tasks_core.roi import is_ROI_table_valid\n\n-from fractal_tasks_core.lib_regions_of_interest import is_standard_roi_table\n+from fractal_tasks_core.roi import is_standard_roi_table\n\n-from fractal_tasks_core.lib_regions_of_interest import load_region\n+from fractal_tasks_core.roi import load_region\n\n-from fractal_tasks_core.lib_regions_of_interest import prepare_FOV_ROI_table\n+from fractal_tasks_core.roi import prepare_FOV_ROI_table\n\n-from fractal_tasks_core.lib_regions_of_interest import prepare_well_ROI_table\n+from fractal_tasks_core.roi import prepare_well_ROI_table\n\n-from fractal_tasks_core.lib_ROI_overlaps import remove_FOV_overlaps\n+from fractal_tasks_core.roi import remove_FOV_overlaps\n</code></pre>"},{"location":"version_updates/v0_14_0/#other","title":"Other","text":"<pre><code>-from fractal_tasks_core.lib_tables import write_table\n+from fractal_tasks_core.tables import write_table\n\n-from fractal_tasks_core.lib_masked_loading import masked_loading_wrapper\n+from fractal_tasks_core.masked_loading import masked_loading_wrapper\n\n-from fractal_tasks_core.lib_upscale_array import upscale_array\n+from fractal_tasks_core.upscale_array import upscale_array\n\n-from fractal_tasks_core.lib_write import OverwriteNotAllowedError\n+from fractal_tasks_core.zarr_utils import OverwriteNotAllowedError\n\n-from fractal_tasks_core.lib_write import open_zarr_group_with_overwrite\n+from fractal_tasks_core.zarr_utils import open_zarr_group_with_overwrite\n\n-from fractal_tasks_core.lib_write import prepare_label_group\n+from fractal_tasks_core.labels import prepare_label_group\n\n-from fractal_tasks_core.lib_zattrs_utils import get_table_path_dict\n+from fractal_tasks_core.utils import get_table_path_dict\n\n-from fractal_tasks_core.lib_zattrs_utils import rescale_datasets\n+from fractal_tasks_core.utils import rescale_datasets\n\n-from fractal_tasks_core.lib_read_fractal_metadata import get_parameters_from_metadata\n+from fractal_tasks_core.utils import get_parameters_from_metadata\n</code></pre>"}]}